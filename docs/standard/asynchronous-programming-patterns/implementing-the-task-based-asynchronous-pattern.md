---
title: Görev Tabanlı Zaman Uyumsuz Deseni Uygulama
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: a218633ed607222fec3e46629a9bcd614c3d0610
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62031193"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="289f9-102">Görev Tabanlı Zaman Uyumsuz Deseni Uygulama</span><span class="sxs-lookup"><span data-stu-id="289f9-102">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="289f9-103">Görev tabanlı zaman uyumsuz desen (TAP) üç yolla gerçekleştirebilirsiniz: Visual Studio'da C# ve Visual Basic derleyicileri kullanarak, el ile veya derleyici ve el yönteminin bir birleşimi yoluyla.</span><span class="sxs-lookup"><span data-stu-id="289f9-103">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="289f9-104">Aşağıdaki bölümlerde, her bir yöntemin ayrıntılı ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="289f9-104">The following sections discuss each method in detail.</span></span> <span data-ttu-id="289f9-105">DOKUNUN deseni hesaplama bağlantılı hem miyim/O-ilişkili zaman uyumsuz işlemleri uygulamak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289f9-105">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="289f9-106">[İş yükleri](#workloads) bölümde her işlem türü açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="289f9-106">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="289f9-107">DOKUNUN yöntemleri üretiliyor</span><span class="sxs-lookup"><span data-stu-id="289f9-107">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="289f9-108">Derleyiciler kullanma</span><span class="sxs-lookup"><span data-stu-id="289f9-108">Using the compilers</span></span>
<span data-ttu-id="289f9-109">İle başlayarak [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], ile öznitelendirilen herhangi bir yöntemi `async` anahtar sözcüğü (`Async` Visual Basic'te) zaman uyumsuz bir yöntem ve C# ve Visual Basic derleyicileri gerçekleştirme uygulamak için gerekli dönüştürmeleri olarak kabul edilir DOKUNUN kullanarak zaman uyumsuz yöntem.</span><span class="sxs-lookup"><span data-stu-id="289f9-109">Starting with [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="289f9-110">Zaman uyumsuz bir yöntem ya da döndürmelidir bir <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> veya <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> nesne.</span><span class="sxs-lookup"><span data-stu-id="289f9-110">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="289f9-111">İkincisi, işlev gövdesini döndürmelidir bir `TResult`, ve bu sonucu elde edilen görev nesnesi sunulacağını derleyici sağlar.</span><span class="sxs-lookup"><span data-stu-id="289f9-111">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="289f9-112">Benzer şekilde, Git Yöntemin gövdesi içinde işlenmeyen özel durumları için çıktı görevi sıralanmış ve bitecek şekilde elde edilen görevle neden <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> durumu.</span><span class="sxs-lookup"><span data-stu-id="289f9-112">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="289f9-113">Özel durum olduğunda bir <xref:System.OperationCanceledException> (veya türetilmiş tür) gelecek işlenmemiş, elde edilen görev, bu durumda biten <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> durumu.</span><span class="sxs-lookup"><span data-stu-id="289f9-113">The exception is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="289f9-114">DOKUNUN yöntemleri el ile oluşturma</span><span class="sxs-lookup"><span data-stu-id="289f9-114">Generating TAP methods manually</span></span>
<span data-ttu-id="289f9-115">Uygulama üzerinde daha iyi denetim için el ile DOKUNUN deseni uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="289f9-115">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="289f9-116">Öğesinden gösterilen ortak yüzey alanını derleyici dayanan <xref:System.Threading.Tasks?displayProperty=nameWithType> ad alanı ve türlerini destekleyen <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> ad alanı.</span><span class="sxs-lookup"><span data-stu-id="289f9-116">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="289f9-117">DOKUNUN kendiniz uygulamak için oluşturduğunuz bir <xref:System.Threading.Tasks.TaskCompletionSource%601> nesnesi, zaman uyumsuz işlemi gerçekleştirebilir ve tamamlandığında, çağrı <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, veya <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> yöntemi veya `Try` aşağıdaki yöntemlerden birini sürümü.</span><span class="sxs-lookup"><span data-stu-id="289f9-117">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="289f9-118">El ile bir TAP yöntemi uyguladığınızda, gösterilen zaman uyumsuz işlem tamamlandığında elde edilen görevi tamamlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="289f9-118">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="289f9-119">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="289f9-119">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="289f9-120">Karma yaklaşım</span><span class="sxs-lookup"><span data-stu-id="289f9-120">Hybrid approach</span></span>
 <span data-ttu-id="289f9-121">DOKUNUN el ile tasarımın uygulandığı ancak çekirdek mantığını derleyici uygulaması için temsilci seçmek için faydalı.</span><span class="sxs-lookup"><span data-stu-id="289f9-121">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="289f9-122">Örneğin, özel durumlar yöntemin doğrudan çağıran yerine aracılığıyla kullanıma çizgilerden kaçınabilirsiniz dışında bir derleyici tarafından oluşturulan zaman uyumsuz yöntem bağımsız değişkenleri doğrulamak istediğinizde, karma bir yaklaşım kullanmak isteyebilirsiniz <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> nesnesi:</span><span class="sxs-lookup"><span data-stu-id="289f9-122">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="289f9-123">Hızlı yolu iyileştirme uygulama ve önbelleğe alınmış bir görevi döndürmek istediğiniz zaman bu tür bir temsilci kullanışlı olduğu başka bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="289f9-123">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="289f9-124">İş yükleri</span><span class="sxs-lookup"><span data-stu-id="289f9-124">Workloads</span></span>
<span data-ttu-id="289f9-125">TAP yöntemi hesaplama bağlantılı hem miyim/O-ilişkili zaman uyumsuz işlemleri uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="289f9-125">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="289f9-126">Ancak, bunlar DOKUNUN yöntemleri herkese açık şekilde kitaplığından maruz kaldığında, (Bunlar ayrıca, hesaplama içerebilir, ancak tamamen hesaplama olmamalıdır) ben/Ç işlemleri gerektiren yükleri sağlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="289f9-126">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="289f9-127">İşlem bağlı yalnızca bir yöntemi ise yalnızca zaman uyumlu bir uygulama açılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="289f9-127">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="289f9-128">Kullandığı kod bir görev paralelliği elde etmek için ya da başka bir iş parçacığı için iş yüklerini boşaltmak üzere zaman uyumlu yöntemin bir çağrısını sarmalamak seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289f9-128">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="289f9-129">Ve bir yöntem, ı/O-ilişkili ise, bunu yalnızca zaman uyumsuz bir uygulama açığa çıkarılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="289f9-129">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="289f9-130">İşlem bağlı görevler</span><span class="sxs-lookup"><span data-stu-id="289f9-130">Compute-bound tasks</span></span>
<span data-ttu-id="289f9-131"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> Sınıfı ideal olarak uygun işlem bakımından yoğun işlemleri temsil etmek için.</span><span class="sxs-lookup"><span data-stu-id="289f9-131">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="289f9-132">İsteğe bağlı olarak varsayılan olarak, içinde özel destek avantajlarından yararlanır <xref:System.Threading.ThreadPool> verimli yürütme sağlamak için sınıf ve ayrıca önemli denetimi zaman, nerede ve nasıl sağladığı zaman uyumsuz hesaplamalar yürütün.</span><span class="sxs-lookup"><span data-stu-id="289f9-132">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="289f9-133">İşlem bağlı görevleri aşağıdaki yollarla oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="289f9-133">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="289f9-134">.NET Framework 4'te kullanmak <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> kabul eden bir temsilci yöntemi (genellikle bir <xref:System.Action%601> veya <xref:System.Func%601>) zaman uyumsuz olarak yürütülecek.</span><span class="sxs-lookup"><span data-stu-id="289f9-134">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="289f9-135">Sağlarsanız bir <xref:System.Action%601> yöntemi döndürür, temsilci bir <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> zaman uyumsuz yürütme bu temsilcinin temsil eden nesne.</span><span class="sxs-lookup"><span data-stu-id="289f9-135">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="289f9-136">Sağlarsanız bir <xref:System.Func%601> yöntemi döndürür, temsilci bir <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> nesne.</span><span class="sxs-lookup"><span data-stu-id="289f9-136">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="289f9-137">Overloads biri <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> yöntemi, bir iptal belirteci kabul (<xref:System.Threading.CancellationToken>), görev oluşturma seçenekleri (<xref:System.Threading.Tasks.TaskCreationOptions>) ve bir Görev Zamanlayıcı'yı (<xref:System.Threading.Tasks.TaskScheduler>), her biri, zamanlama ve yürütme görevin üzerinde ayrıntılı denetim sağlar.</span><span class="sxs-lookup"><span data-stu-id="289f9-137">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="289f9-138">Geçerli Görev Zamanlayıcı'yı hedefleyen bir Fabrika örnek statik bir özellik olarak kullanılabilir (<xref:System.Threading.Tasks.Task.Factory%2A>), <xref:System.Threading.Tasks.Task> sınıfı; örneğin: `Task.Factory.StartNew(…)`.</span><span class="sxs-lookup"><span data-stu-id="289f9-138">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="289f9-139">İçinde [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ve sonraki sürümlerinde (.NET Core ve .NET Standard dahil), statik <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> yöntemi için bir kısayol olarak <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="289f9-139">In the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="289f9-140">Kullanmanızı <xref:System.Threading.Tasks.Task.Run%2A> kolayca iş parçacığı havuzunu hedefleyen bir hesaplama bağlantılı görevini başlatmak üzere.</span><span class="sxs-lookup"><span data-stu-id="289f9-140">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="289f9-141">İçinde [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] ve sonraki sürümlerinde, bu işlem bağlı görevi başlatmak için tercih edilen mekanizması.</span><span class="sxs-lookup"><span data-stu-id="289f9-141">In the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="289f9-142">Kullanım `StartNew` doğrudan yalnızca görev üzerinde daha kapsamlı denetim istediğinizde.</span><span class="sxs-lookup"><span data-stu-id="289f9-142">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="289f9-143">Oluşturucular Kullanma `Task` türü veya `Start` oluşturmak ve ayrı olarak görevi zamanlamak istiyorsanız yöntemi.</span><span class="sxs-lookup"><span data-stu-id="289f9-143">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="289f9-144">Genel yöntemler yalnızca zaten başlatıldığından görev döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="289f9-144">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="289f9-145">Aşırı yüklemelerini kullanın <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="289f9-145">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="289f9-146">Bu yöntem, başka bir görev tamamlandığında zamanlanmış yeni bir görev oluşturur.</span><span class="sxs-lookup"><span data-stu-id="289f9-146">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="289f9-147">Bazı <xref:System.Threading.Tasks.Task.ContinueWith%2A> aşırı bir iptal belirteci, devamlılık seçenekleri ve zamanlama ve yürütme devamlılık görevinin üzerinde daha iyi denetim için bir Görev Zamanlayıcı kabul etmiş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="289f9-147">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="289f9-148">Kullanım <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> ve <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="289f9-148">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="289f9-149">Bu yöntemlerin tümü veya herhangi biri sağlanan bir dizi görev tamamlandıktan sonra zamanlanan yeni bir görev oluşturun.</span><span class="sxs-lookup"><span data-stu-id="289f9-149">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="289f9-150">Bu yöntemler de zamanlama denetlemek için aşırı yüklemeler ve bu görevlerin yürütülmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="289f9-150">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="289f9-151">Görevi çalıştırmak başlamadan önce bir iptal isteği alırsa hesaplama bağlantılı görevleri'nde, sistem zamanlanmış bir görevin yürütülmesini engelleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289f9-151">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="289f9-152">Örneğin, bir iptal belirteci sağlarsanız olarak (<xref:System.Threading.CancellationToken> nesne), bu belirteci izleyen belirteç için zaman uyumsuz kodu geçirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289f9-152">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="289f9-153">Yukarıda açıklanan yöntemlerden birini belirtece gibi sağlayabilir `StartNew` veya `Run` böylece `Task` çalışma zamanı belirteç de izlemek.</span><span class="sxs-lookup"><span data-stu-id="289f9-153">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="289f9-154">Örneğin, görüntüyü işleyen zaman uyumsuz bir yöntem düşünün.</span><span class="sxs-lookup"><span data-stu-id="289f9-154">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="289f9-155">İşleme sırasında bir iptal isteğine geldiğinde, erken çıkış kodu, görevin iptal belirtecini yoklama.</span><span class="sxs-lookup"><span data-stu-id="289f9-155">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="289f9-156">Ayrıca, işleme başlamadan önce iptal isteği alınırsa, işleme işlemi önlemek isteyeceksiniz:</span><span class="sxs-lookup"><span data-stu-id="289f9-156">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="289f9-157">İşlem bağlı görevleri bitiş içinde bir <xref:System.Threading.Tasks.TaskStatus.Canceled> en az biri aşağıdaki koşullardan biri doğru olup olmadığını belirtin:</span><span class="sxs-lookup"><span data-stu-id="289f9-157">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="289f9-158">Aracılığıyla bir iptal isteğine ulaşan <xref:System.Threading.CancellationToken> oluşturma yöntemi için bağımsız değişken olarak sağlanan nesne (örneğin, `StartNew` veya `Run`) görev geçişleri önce <xref:System.Threading.Tasks.TaskStatus.Running> durumu.</span><span class="sxs-lookup"><span data-stu-id="289f9-158">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="289f9-159">Bir <xref:System.OperationCanceledException> özel durum işlenmemiş özel durum aynı içerdiğinden bu tür bir görev gövdesinde gider <xref:System.Threading.CancellationToken> göreve geçirilen ve iptalin istendiğini belirtecini gösterir.</span><span class="sxs-lookup"><span data-stu-id="289f9-159">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="289f9-160">Görev başka bir özel durum işlenmemiş görevin gövdesinden aşması durumunda, biten <xref:System.Threading.Tasks.TaskStatus.Faulted> durumu ve görev ya da sonuç bir özel durum oluşturulmasına neden olan erişim bekleyin girişimleri.</span><span class="sxs-lookup"><span data-stu-id="289f9-160">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="289f9-161">Ben/O-bağımlı görevler</span><span class="sxs-lookup"><span data-stu-id="289f9-161">I/O-bound tasks</span></span>
<span data-ttu-id="289f9-162">Doğrudan tamamen yürütme için bir iş parçacığı tarafından yedeklenmemelidir bir görev oluşturmak için kullanın <xref:System.Threading.Tasks.TaskCompletionSource%601> türü.</span><span class="sxs-lookup"><span data-stu-id="289f9-162">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="289f9-163">Bu tür sunan bir <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> ilişkili bir döndüren özellik <xref:System.Threading.Tasks.Task%601> örneği.</span><span class="sxs-lookup"><span data-stu-id="289f9-163">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="289f9-164">Bu görev yaşam döngüsünü denetleyen <xref:System.Threading.Tasks.TaskCompletionSource%601> gibi yöntemler <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>ve bunların `TrySet` çeşitleri.</span><span class="sxs-lookup"><span data-stu-id="289f9-164">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="289f9-165">Belirtilen bir süre sonra tamamlanacak bir görev oluşturmak istediğinizi varsayalım.</span><span class="sxs-lookup"><span data-stu-id="289f9-165">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="289f9-166">Örneğin, kullanıcı arabiriminde bir etkinlik geciktirmek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289f9-166">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="289f9-167"><xref:System.Threading.Timer?displayProperty=nameWithType> Sınıfı zaten süreyi ve kullanarak belirli bir süre sonra zaman uyumsuz olarak bir temsilci çağırma yeteneği sağlar <xref:System.Threading.Tasks.TaskCompletionSource%601> koyabilirsiniz bir <xref:System.Threading.Tasks.Task%601> Zamanlayıcıyı, örneğin ön:</span><span class="sxs-lookup"><span data-stu-id="289f9-167">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="289f9-168">İle başlayarak [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> yöntemi, bu amaç için sağlanır ve bunu başka bir zaman uyumsuz yöntemde, örneğin, bir zaman uyumsuz Yoklama döngüsü uygulamak için kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="289f9-168">Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="289f9-169"><xref:System.Threading.Tasks.TaskCompletionSource%601> Sınıfı, genel olmayan karşılığı yok.</span><span class="sxs-lookup"><span data-stu-id="289f9-169">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="289f9-170">Ancak, <xref:System.Threading.Tasks.Task%601> türetildiği <xref:System.Threading.Tasks.Task>, genel kullanabilmeniz için <xref:System.Threading.Tasks.TaskCompletionSource%601> yalnızca bir görev döndüren miyim/O-bağlı yöntemler için nesne.</span><span class="sxs-lookup"><span data-stu-id="289f9-170">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="289f9-171">Bunu yapmak için bir kaynak ile bir kukla kullanabilirsiniz `TResult` (<xref:System.Boolean> kullanıcısı hakkında endişe ancak ek olarak, iyi bir varsayılan seçim <xref:System.Threading.Tasks.Task> alta dönüştürme işlemi için bir <xref:System.Threading.Tasks.Task%601>, özel bir kullanabilirsiniz `TResult` bunun yerine yazın).</span><span class="sxs-lookup"><span data-stu-id="289f9-171">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="289f9-172">Örneğin, `Delay` önceki örnekte yöntemi ortaya çıkan yanı sıra geçerli saati uzaklığı döndürür (`Task<DateTimeOffset>`).</span><span class="sxs-lookup"><span data-stu-id="289f9-172">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="289f9-173">Böyle bir sonuç değeri gereksizse yöntemi bunun yerine şu şekilde kodlanmasını (dönüş türü değişikliğini ve bağımsız değişkenin Not <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span><span class="sxs-lookup"><span data-stu-id="289f9-173">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="289f9-174">Karma hesaplama bağlantılı ve ben/O-bağımlı görevler</span><span class="sxs-lookup"><span data-stu-id="289f9-174">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="289f9-175">Zaman uyumsuz yöntemler işlem bağlı veya miyim/O-bağlama işlemleri sınırlı değildir ancak ikisinin karışımı temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="289f9-175">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="289f9-176">Aslında, birden çok zaman uyumsuz işlemler genellikle daha büyük karma işlemlere birleştirilir.</span><span class="sxs-lookup"><span data-stu-id="289f9-176">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="289f9-177">Örneğin, önceki bir örnekte gösterilen `RenderAsync` yöntemi, bazı giriş `imageData` verilerine göre bir resmi işlemek için yoğun bir hesaplama işlem gerçekleştirdi.</span><span class="sxs-lookup"><span data-stu-id="289f9-177">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="289f9-178">Bu `imageData` zaman uyumsuz olarak erişen bir web hizmetinden gelebilir:</span><span class="sxs-lookup"><span data-stu-id="289f9-178">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="289f9-179">Tek bir iptal belirteci aracılığıyla birden çok zaman uyumsuz işlemler nasıl akıtılan, bu örnek ayrıca gösterir.</span><span class="sxs-lookup"><span data-stu-id="289f9-179">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="289f9-180">Daha fazla bilgi için bkz: iptal kullanım bölümünde [görev tabanlı zaman uyumsuz desen kullanma](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="289f9-180">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="289f9-181">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="289f9-181">See also</span></span>

- [<span data-ttu-id="289f9-182">Görev Tabanlı Zaman Uyumsuz Desen (TAP)</span><span class="sxs-lookup"><span data-stu-id="289f9-182">Task-based Asynchronous Pattern (TAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="289f9-183">Görev Tabanlı Zaman Uyumsuz Desen Kullanma</span><span class="sxs-lookup"><span data-stu-id="289f9-183">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="289f9-184">Diğer Zaman Uyumsuz Desen ve Türlerle Birlikte Çalışma</span><span class="sxs-lookup"><span data-stu-id="289f9-184">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)

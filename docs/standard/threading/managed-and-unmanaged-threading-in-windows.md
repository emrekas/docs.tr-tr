---
title: Windows'da Yönetilen ve Yönetilmeyen İş Parçacığı Oluşturma
ms.date: 10/24/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- threading [.NET], managed
- threads and fibers [.NET]
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: da32d514b19424487cebc1d113388cfa9a2dbdf0
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69913236"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="b1411-102">Windows 'da yönetilen ve yönetilmeyen iş parçacığı</span><span class="sxs-lookup"><span data-stu-id="b1411-102">Managed and unmanaged threading in Windows</span></span>

<span data-ttu-id="b1411-103">Tüm iş parçacıklarının yönetimi, ortak dil çalışma <xref:System.Threading.Thread> zamanı tarafından oluşturulan iş parçacıkları ve kodu yürütmek için yönetilen ortama girerken çalışma zamanının dışında oluşturulanlar dahil olmak üzere sınıfı aracılığıyla yapılır.</span><span class="sxs-lookup"><span data-stu-id="b1411-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="b1411-104">Çalışma zamanı, işlem sırasında yönetilen yürütme ortamında kod yürüten tüm iş parçacıklarını izler.</span><span class="sxs-lookup"><span data-stu-id="b1411-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="b1411-105">Diğer iş parçacıklarını izlemez.</span><span class="sxs-lookup"><span data-stu-id="b1411-105">It does not track any other threads.</span></span> <span data-ttu-id="b1411-106">İş parçacıkları, yönetilen yürütme ortamını COM birlikte çalışma aracılığıyla girebilir (çalışma zamanı yönetilen nesneleri yönetilmeyen dünyayı COM nesneleri olarak kullanıma sunduğundan), COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) işlevini ve platform çağrılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="b1411-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="b1411-107">Yönetilmeyen bir iş parçacığı, örneğin, com çağrılabilir bir sarmalayıcı aracılığıyla çalışma zamanına girdiğinde, sistem, iç yönetilen <xref:System.Threading.Thread> bir nesneyi aramak için iş parçacığının yerel depo parçacığını denetler.</span><span class="sxs-lookup"><span data-stu-id="b1411-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="b1411-108">Bir tane bulunursa, çalışma zamanı bu iş parçacığının zaten farkında olur.</span><span class="sxs-lookup"><span data-stu-id="b1411-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="b1411-109">Ancak, bir tane bulamazsa, çalışma zamanı yeni <xref:System.Threading.Thread> bir nesne oluşturur ve bu iş parçacığının iş parçacığı yerel deposuna yüklenir.</span><span class="sxs-lookup"><span data-stu-id="b1411-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="b1411-110">Yönetilen iş parçacığında, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> kararlı yönetilen iş parçacığı kimliğidir.</span><span class="sxs-lookup"><span data-stu-id="b1411-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="b1411-111">İş parçacığınız kullanım ömrü boyunca, bu değeri aldığınız uygulama etki alanından bağımsız olarak diğer herhangi bir iş parçacığından elde etmeyecektir.</span><span class="sxs-lookup"><span data-stu-id="b1411-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b1411-112">Yönetilmeyen bir konak yönetilen ve yönetilmeyen iş parçacıkları arasındaki ilişkiyi denetleyebildiğinden, bir işletim sistemi **tehdit** , yönetilen bir iş parçacığı ile sabit ilişkiye sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="b1411-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="b1411-113">Özellikle, gelişmiş bir ana bilgisayar aynı işletim sistemi iş parçacığında birçok yönetilen iş parçacığını zamanlamak veya yönetilen bir iş parçacığını farklı işletim sistemi iş parçacıkları arasında taşımak için fiber API 'YI kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="b1411-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="b1411-114">Win32 iş parçacığından yönetilen iş parçacığına eşleme</span><span class="sxs-lookup"><span data-stu-id="b1411-114">Mapping from Win32 threading to managed threading</span></span>

 <span data-ttu-id="b1411-115">Aşağıdaki tablo, Win32 iş parçacığı öğelerini yaklaşık çalışma zamanına eşit olarak eşler.</span><span class="sxs-lookup"><span data-stu-id="b1411-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="b1411-116">Bu eşlemenin aynı işlevselliği temsil etmediği unutulmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b1411-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="b1411-117">Örneğin, **TerminateThread** **finally** yan tümceleri çalıştırmaz veya kaynakları serbest bırakırsanız ve engellenemez.</span><span class="sxs-lookup"><span data-stu-id="b1411-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="b1411-118">Ancak tüm geri alma kodunuzu <xref:System.Threading.Thread.ResetAbort%2A> yürütür,tümkaynaklarıgerikazanırvekullanılarakreddedilebilir.<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b1411-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="b1411-119">İşlevlerle ilgili varsayımlar yapmadan önce belgeleri okuduğunuzdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="b1411-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="b1411-120">Win32 'te</span><span class="sxs-lookup"><span data-stu-id="b1411-120">In Win32</span></span>|<span data-ttu-id="b1411-121">Ortak dil çalışma zamanında</span><span class="sxs-lookup"><span data-stu-id="b1411-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="b1411-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="b1411-122">**CreateThread**</span></span>|<span data-ttu-id="b1411-123">**Iş parçacığının** birleşimi ve<xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="b1411-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="b1411-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="b1411-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="b1411-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-126">**ResumeThread Iş parçacığı**</span><span class="sxs-lookup"><span data-stu-id="b1411-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-127">**Kullanılmadığında**</span><span class="sxs-lookup"><span data-stu-id="b1411-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-128">İş parçacığı tanıtıcısından **WaitForSingleObject**</span><span class="sxs-lookup"><span data-stu-id="b1411-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="b1411-129">**ExitThread**</span></span>|<span data-ttu-id="b1411-130">Eşdeğer değil</span><span class="sxs-lookup"><span data-stu-id="b1411-130">No equivalent</span></span>|  
|<span data-ttu-id="b1411-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="b1411-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="b1411-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-133">Eşdeğer değil</span><span class="sxs-lookup"><span data-stu-id="b1411-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-134">Eşdeğer değil</span><span class="sxs-lookup"><span data-stu-id="b1411-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="b1411-135">**CoInitializeEx** 'a kapat (Ole32. DOSYASıNı</span><span class="sxs-lookup"><span data-stu-id="b1411-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="b1411-136">Yönetilen iş parçacıkları ve com apartmanlar</span><span class="sxs-lookup"><span data-stu-id="b1411-136">Managed threads and COM apartments</span></span>

<span data-ttu-id="b1411-137">Yönetilen bir iş parçacığı, [tek iş parçacıklı](/windows/desktop/com/single-threaded-apartments) veya çok [iş parçacıklı](/windows/desktop/com/multithreaded-apartments) bir grubu barındıracak olduğunu göstermek için işaretlenebilir.</span><span class="sxs-lookup"><span data-stu-id="b1411-137">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="b1411-138">(COM iş parçacığı mimarisi hakkında daha fazla bilgi için bkz. [süreçler, Iş parçacıkları ve apartmanlar](/windows/desktop/com/processes--threads--and-apartments).) Sınıfının, <xref:System.Threading.Thread.SetApartmentState%2A> ve<xref:System.Threading.Thread.TrySetApartmentState%2A> yöntemleri, bir iş parçacığının Grup durumunu döndürür ve atar. <xref:System.Threading.Thread.GetApartmentState%2A> <xref:System.Threading.Thread></span><span class="sxs-lookup"><span data-stu-id="b1411-138">(For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="b1411-139">Durum ayarlanmamışsa, <xref:System.Threading.Thread.GetApartmentState%2A> döndürür <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b1411-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b1411-140">Özelliği yalnızca iş parçacığı <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> durumundayken ayarlanabilir; bir iş parçacığı için yalnızca bir kez ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="b1411-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="b1411-141">Grup durumu, iş parçacığı başlatılmadan önce ayarlanmamışsa, iş parçacığı, çok iş parçacıklı apartman (MTA) olarak başlatılır.</span><span class="sxs-lookup"><span data-stu-id="b1411-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="b1411-142">Sonlandırıcı iş parçacığı ve tarafından <xref:System.Threading.ThreadPool> denetlenen tüm iş parçacıkları MTA.</span><span class="sxs-lookup"><span data-stu-id="b1411-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="b1411-143">Uygulama başlangıç kodu için, grup durumunu denetlemek için tek yol, <xref:System.MTAThreadAttribute> <xref:System.STAThreadAttribute> veya öğesini giriş noktası yordamına uygulamaktır.</span><span class="sxs-lookup"><span data-stu-id="b1411-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="b1411-144">.NET Framework 1,0 ve 1,1 ' de, <xref:System.Threading.Thread.ApartmentState%2A> özellik ilk kod satırı olarak ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="b1411-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="b1411-145">.NET Framework 2,0 ' de buna izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="b1411-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="b1411-146">COM 'a sunulan yönetilen nesneler, serbest iş parçacıklı Sıralayıcı 'nın toplanmamış gibi davranır.</span><span class="sxs-lookup"><span data-stu-id="b1411-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="b1411-147">Diğer bir deyişle, ücretsiz iş parçacıklı bir şekilde herhangi bir COM grubundan çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="b1411-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="b1411-148">Bu serbest iş parçacıklı davranışı sergilemeyen tek yönetilen nesneler, veya <xref:System.EnterpriseServices.ServicedComponent> <xref:System.Runtime.InteropServices.StandardOleMarshalObject>' den türetilen nesnelerdir.</span><span class="sxs-lookup"><span data-stu-id="b1411-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="b1411-149">Yönetilen dünyada, bağlamlar ve bağlam bağlantılı yönetilen örnekler kullanmadığınız <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> durumlar için destek yoktur.</span><span class="sxs-lookup"><span data-stu-id="b1411-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="b1411-150">Kurumsal Hizmetler kullanıyorsanız, nesnenizin ' den <xref:System.EnterpriseServices.ServicedComponent> türetmeniz gerekir (Bu, öğesinden <xref:System.ContextBoundObject>türetilir).</span><span class="sxs-lookup"><span data-stu-id="b1411-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="b1411-151">Yönetilen kod COM nesnelerine aradığında, her zaman COM kurallarını izler.</span><span class="sxs-lookup"><span data-stu-id="b1411-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="b1411-152">Diğer bir deyişle, OLE32 tarafından dikte edildiği gibi COM apartman proxy 'leri ve COM+ 1,0 bağlam sarmalayıcıları aracılığıyla çağrı yapılır.</span><span class="sxs-lookup"><span data-stu-id="b1411-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="b1411-153">Sorunları engelleme</span><span class="sxs-lookup"><span data-stu-id="b1411-153">Blocking issues</span></span>  

<span data-ttu-id="b1411-154">Bir iş parçacığı, yönetilmeyen koddaki iş parçacığını engelleyen işletim sistemine yönetilmeyen bir çağrı yapıyorsa, çalışma zamanı veya <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>için denetimi almaz.</span><span class="sxs-lookup"><span data-stu-id="b1411-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1411-155">Durumunda <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, çalışma zamanı, iş parçacığını **iptal** için işaretler ve yönetilen kodu yeniden girdiğinde bunun denetimini alır.</span><span class="sxs-lookup"><span data-stu-id="b1411-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="b1411-156">Yönetilmeyen engelleme yerine yönetilen engellemeyi kullanmanız tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="b1411-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="b1411-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType><xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> ,,<xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> , ,<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>,, vb.<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>tüm ve için tamamen yanıt veriyor. <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType> <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b1411-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1411-158">Ayrıca, iş parçacığın tek iş parçacıklı bir apartman halinde olması halinde, iş parçacığı engellenirken tüm bu yönetilen engelleyici işlemler, ağınızdaki iletileri doğru bir şekilde kaklacaktır.</span><span class="sxs-lookup"><span data-stu-id="b1411-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  

## <a name="threads-and-fibers"></a><span data-ttu-id="b1411-159">İş parçacıkları ve fiberler</span><span class="sxs-lookup"><span data-stu-id="b1411-159">Threads and fibers</span></span>

<span data-ttu-id="b1411-160">.NET iş parçacığı modeli [lifleri görmeyin](/windows/desktop/procthread/fibers)'yi desteklemez.</span><span class="sxs-lookup"><span data-stu-id="b1411-160">The .NET threading model does not support [fibers](/windows/desktop/procthread/fibers).</span></span> <span data-ttu-id="b1411-161">Fibers kullanılarak uygulanan hiçbir yönetilmeyen işlevi çağırmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b1411-161">You should not call into any unmanaged function that is implemented by using fibers.</span></span> <span data-ttu-id="b1411-162">Bu tür çağrılar, .NET çalışma zamanının kilitlenmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="b1411-162">Such calls may result in a crash of the .NET runtime.</span></span>

## <a name="see-also"></a><span data-ttu-id="b1411-163">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="b1411-163">See also</span></span>

- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>
- <xref:System.Threading.ThreadState>
- <xref:System.EnterpriseServices.ServicedComponent>
- <xref:System.Threading.Thread>
- <xref:System.Threading.Monitor>

---
title: Sunucusuz mimari dikkat edilmesi gerekenler - sunucusuz uygulamalar
description: Durum Yönetimi ve ölçeklendirmek için kalıcı depolama sunucusuz uygulama mimarileri oluşturma sorunlarından günlüğe kaydetme, izleme ve tanılama anlayın.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: b12a09c0fcef7e7ff954a3f959fb9e3080a6e859
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61940952"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="f669d-103">Sunucusuz mimaride dikkat edilmesi gerekenler</span><span class="sxs-lookup"><span data-stu-id="f669d-103">Serverless architecture considerations</span></span>

<span data-ttu-id="f669d-104">Sunucusuz bir mimari benimsenmesi, bazı zorluklar geliyor.</span><span class="sxs-lookup"><span data-stu-id="f669d-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="f669d-105">Bu bölümde daha yaygın konuları dikkat edilmesi gereken bazı keşfediyor.</span><span class="sxs-lookup"><span data-stu-id="f669d-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="f669d-106">Bu zorluklar çözümleri sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f669d-106">All of these challenges have solutions.</span></span> <span data-ttu-id="f669d-107">Tüm mimari seçenek olarak, sunucusuz mimariye geçin kararı yalnızca dikkatle Artıları ve eksileri dikkate sonra yapılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f669d-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="f669d-108">Uygulamanızın ihtiyaçlarına bağlı olarak, sunucusuz bir uygulama belirli bileşenler için doğru çözüm değildir karar verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f669d-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="f669d-109">Durumunu yönetme</span><span class="sxs-lookup"><span data-stu-id="f669d-109">Managing state</span></span>

<span data-ttu-id="f669d-110">Sunucusuz işlevler ile mikro gibi genel olarak, varsayılan olarak durum bilgisiz olduğundan.</span><span class="sxs-lookup"><span data-stu-id="f669d-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="f669d-111">Kısa ömürlü, ölçeği genişletme ve merkezi bir hata noktası olmadan dayanıklılık sağlamak için kaçınarak durumunun sunucusuz sağlar.</span><span class="sxs-lookup"><span data-stu-id="f669d-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="f669d-112">Bazı durumlarda, iş süreçlerini durumu gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f669d-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="f669d-113">İşleminiz, durumu gerektiriyorsa, iki seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="f669d-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="f669d-114">Sunucusuz değerinden başka bir modelini benimseyin ve durumu sağlayan ayrı bir hizmet ile etkileşimde bulunma.</span><span class="sxs-lookup"><span data-stu-id="f669d-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="f669d-115">Durum ekleme çözüm karmaşık hale Ölçekle daha zor hale ve olası bir tek hata noktası oluşturun.</span><span class="sxs-lookup"><span data-stu-id="f669d-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="f669d-116">İşlevinizi durumu kesinlikle gerekli olup olmadığını dikkatlice düşünün.</span><span class="sxs-lookup"><span data-stu-id="f669d-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="f669d-117">Yanıt "Evet" ise, hala ile sunucusuz uygulama mantıklıdır olup olmadığını belirler.</span><span class="sxs-lookup"><span data-stu-id="f669d-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="f669d-118">Sunucusuz avantajlarını ödün vermeden durumu benimsemek için çeşitli çözümler vardır.</span><span class="sxs-lookup"><span data-stu-id="f669d-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="f669d-119">Diğer popüler çözümlerden bazıları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="f669d-119">Some of the more popular solutions include:</span></span>

* <span data-ttu-id="f669d-120">Bir geçici veri deposu ve Redis gibi dağıtılmış önbellek kullanma</span><span class="sxs-lookup"><span data-stu-id="f669d-120">Use a temporary data store or distributed cache, like Redis</span></span>
* <span data-ttu-id="f669d-121">Veritabanında, SQL veya CosmosDB gibi Store durumu</span><span class="sxs-lookup"><span data-stu-id="f669d-121">Store state in a database, like SQL or CosmosDB</span></span>
* <span data-ttu-id="f669d-122">Dayanıklı işlevler gibi bir iş akışı altyapısı aracılığıyla durum işleme</span><span class="sxs-lookup"><span data-stu-id="f669d-122">Handle state through a workflow engine like durable functions</span></span>

<span data-ttu-id="f669d-123">Alt çizgi ile sunucusuz uygulamak için kullanılabiliyor işlemleri içinde herhangi bir durumu yönetim gereksinimini farkında olmalıdır ' dir.</span><span class="sxs-lookup"><span data-stu-id="f669d-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="f669d-124">Uzun süre çalışan işlemler</span><span class="sxs-lookup"><span data-stu-id="f669d-124">Long-running processes</span></span>

<span data-ttu-id="f669d-125">Birçok yararından biri sunucusuz kısa ömürlü olan işlemleri güvenir.</span><span class="sxs-lookup"><span data-stu-id="f669d-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="f669d-126">Kısa çalışma zamanları, kaynakları konak arasında uç ve Paylaşım işlevleri işlevleri gibi boşaltmak sunucusuz sağlayıcı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="f669d-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="f669d-127">Çoğu bulut sağlayıcıları işlevinizi yaklaşık 10 dakika olarak çalıştırabilirsiniz toplam süreyi sınırlamak.</span><span class="sxs-lookup"><span data-stu-id="f669d-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="f669d-128">İşleminizi daha uzun sürebilir, alternatif bir uygulama düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f669d-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="f669d-129">Bazı özel durumlar ve çözümleri vardır.</span><span class="sxs-lookup"><span data-stu-id="f669d-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="f669d-130">İşleminizi ayrı ayrı çalıştırmak için daha az zaman alan daha küçük bileşenlere ayırmak için bir çözüm olabilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="f669d-131">İşleminizi bağımlılıklar nedeniyle uzun çalışırsa, dayanıklı işlevler gibi bir çözüm kullanarak zaman uyumsuz iş akışı göz önünde bulundurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f669d-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="f669d-132">Dayanıklı İşlevler, duraklatmak ve tamamlamak için bir dış işlem beklediği sırada işleminizin durumunu sürdürün.</span><span class="sxs-lookup"><span data-stu-id="f669d-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="f669d-133">Zaman uyumsuz işleme gerçek işlem sürerken süreyi azaltır.</span><span class="sxs-lookup"><span data-stu-id="f669d-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="f669d-134">Başlangıç zamanı</span><span class="sxs-lookup"><span data-stu-id="f669d-134">Startup time</span></span>

<span data-ttu-id="f669d-135">Sunucusuz uygulamalar ile olası bir sorunu başlangıç zamanı geldi.</span><span class="sxs-lookup"><span data-stu-id="f669d-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="f669d-136">Kaynak tasarrufu yapmak için "üzerine." altyapı birçok sunucusuz sağlayıcısı oluşturma</span><span class="sxs-lookup"><span data-stu-id="f669d-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="f669d-137">Sunucusuz bir işlev bir süre sonra tetiklendiğinde işlevi barındırmak için gereken kaynakları oluşturma veya yeniden başlatma gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="f669d-138">Bazı durumlarda, hazırlıksız başlatma işlemlerinden doğan birkaç saniye gecikmelerine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="f669d-139">Başlangıç zaman sağlayıcıları ve hizmet düzeyleri arasında değişir.</span><span class="sxs-lookup"><span data-stu-id="f669d-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="f669d-140">İçin uygulamanın başarısını en aza indirmek önemliyse adresi başlangıç süresi birkaç yaklaşımları vardır.</span><span class="sxs-lookup"><span data-stu-id="f669d-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

* <span data-ttu-id="f669d-141">Bazı sağlayıcılar, altyapı "her zaman açık" olduğu garanti hizmet düzeyleri için ödeme açmasına imkan tanıyın.</span><span class="sxs-lookup"><span data-stu-id="f669d-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
* <span data-ttu-id="f669d-142">("Açık" olarak korumak için uç nokta ping) bir etkin tutma mekanizması uygulamayın.</span><span class="sxs-lookup"><span data-stu-id="f669d-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
* <span data-ttu-id="f669d-143">Kubernetes gibi Orchestration (yeni örnekleri hızla çalıştırarak son derece hızlı, bu nedenle konak zaten çalışıyor) kapsayıcılı işlevi bir yaklaşım kullanın.</span><span class="sxs-lookup"><span data-stu-id="f669d-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="f669d-144">Veritabanı güncelleştirmelerine ve geçişler</span><span class="sxs-lookup"><span data-stu-id="f669d-144">Database updates and migrations</span></span>

<span data-ttu-id="f669d-145">Sunucusuz kod tüm uygulamayı yeniden dağıtmak zorunda kalmadan yeni işlevleri serbest bırakabilirsiniz avantajlıdır.</span><span class="sxs-lookup"><span data-stu-id="f669d-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="f669d-146">Bu avantaj, ilgili ilişkisel bir veritabanı olduğunda bir dezavantajı hale gelebilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="f669d-147">Veritabanı şemalarını değişiklikler ile sunucusuz güncelleştirmelerini eşitlemek zordur.</span><span class="sxs-lookup"><span data-stu-id="f669d-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="f669d-148">Ek zorlukları şeyler ters gittiğinde ve değişikliklerin geri alınması sorulmuş.</span><span class="sxs-lookup"><span data-stu-id="f669d-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="f669d-149">Veri bütünlüğü mikro hizmetler ve sunucusuz işlevler için en iyi uygulama kendi verilerinin sahibi olan bir nedenidir.</span><span class="sxs-lookup"><span data-stu-id="f669d-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="f669d-150">Değişiklikleri hesaplama ve verileri tek bir birim olarak dağıtmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f669d-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="f669d-151">Birçok eski sistemi sunucusuz mimari ile mutabık büyük bir arka uç veritabanı özelliği gerçeğidir.</span><span class="sxs-lookup"><span data-stu-id="f669d-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="f669d-152">Şema sürümü çözmek için yaygın bir yaklaşım, hiçbir zaman var olan özellikleri ve sütunları değiştirmek, ancak bunun yerine yeni bilgiler ekleyin sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="f669d-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="f669d-153">Örneğin, Boole taşımak için bir değişiklik düşünün "tamamlandı" bayrak "tamamlanmış bir tarih." için bir Yapılacaklar listesi için</span><span class="sxs-lookup"><span data-stu-id="f669d-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="f669d-154">Eski alan kaldırma yerine veritabanı değişiklik olur:</span><span class="sxs-lookup"><span data-stu-id="f669d-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="f669d-155">Yeni "tamamlanma tarihi" alanı ekleyin.</span><span class="sxs-lookup"><span data-stu-id="f669d-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="f669d-156">Tamamlanma tarihi geçerli tarihten sonra olup olmadığını değerlendirir hesaplanan bir işlev "tamamlandı" Boole alana dönüştürün.</span><span class="sxs-lookup"><span data-stu-id="f669d-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="f669d-157">Tamamlanan Boolean ayarlandığında geçerli tarihe tamamlanma tarihi ayarlamak için bir tetikleyici ekleme true.</span><span class="sxs-lookup"><span data-stu-id="f669d-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="f669d-158">Değişiklikler dizisini, eski kodu yeni sunucusuz işlevler yeni alan yararlanabilirsiniz "olduğu gibi" çalışmasına devam etmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f669d-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="f669d-159">Verileri sunucusuz mimarileri hakkında daha fazla bilgi için bkz. [Dağıtılmış veri yönetimi için sorunlar ve çözümler](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md).</span><span class="sxs-lookup"><span data-stu-id="f669d-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="f669d-160">Ölçeklendirme</span><span class="sxs-lookup"><span data-stu-id="f669d-160">Scaling</span></span>

<span data-ttu-id="f669d-161">Bu sunucusuz "sunucusu yok." anlamına yaygın bir yanılgıdır</span><span class="sxs-lookup"><span data-stu-id="f669d-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="f669d-162">Bu aslında "daha az." sunucusudur</span><span class="sxs-lookup"><span data-stu-id="f669d-162">It's in fact "less server."</span></span> <span data-ttu-id="f669d-163">Var. bir yedekleme altyapısı ölçeklendirme için ne zaman geldiğini anlamak önemlidir gerçeğidir.</span><span class="sxs-lookup"><span data-stu-id="f669d-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="f669d-164">En sunucusuz platformları, bir dizi olay yoğunluklu artırdığı durumlarda altyapı nasıl ölçeklendirilmesi gereken işlemek için denetimleri sağlayın.</span><span class="sxs-lookup"><span data-stu-id="f669d-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="f669d-165">Çeşitli seçenekler arasından seçim yapabilirsiniz, ancak stratejinizi işlevi bağlı olarak değişebilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="f669d-166">Ayrıca, böylece işlevleri aynı konakta aynı ölçek seçenekleri işlevleri genellikle bir ilgili konak altında çalışır.</span><span class="sxs-lookup"><span data-stu-id="f669d-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="f669d-167">Bu nedenle düzenlemek ve birlikte ölçek gereksinimlerine göre hangi işlevleri barındırılan danışmanlık gereklidir.</span><span class="sxs-lookup"><span data-stu-id="f669d-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="f669d-168">Kurallar nasıl ölçek büyütme sıklığını belirtin (ana bilgisayar kaynakları artırabilirsiniz) ve çeşitli parametrelere göre ölçeklendirme (ana bilgisayar örneklerinin sayısının artması).</span><span class="sxs-lookup"><span data-stu-id="f669d-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="f669d-169">Ölçekler için Tetikleyiciler, zamanlama, istek hızları, CPU kullanımı ve bellek kullanımını içerebilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="f669d-170">Genellikle daha yüksek performans, daha büyük bir maliyetle birlikte gelir.</span><span class="sxs-lookup"><span data-stu-id="f669d-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="f669d-171">Hızlı bir şekilde ne zaman istek hızı anda arttıkça daha ucuz, tüketim tabanlı yaklaşımlar ölçeği değil.</span><span class="sxs-lookup"><span data-stu-id="f669d-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="f669d-172">"Ödeme ve sigorta Maliyet" ön ödeme arasında bir denge olduğu kesin olarak "Git" ve riski talepte ani bir artış nedeniyle yavaş yanıtlar.</span><span class="sxs-lookup"><span data-stu-id="f669d-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="f669d-173">İzleme, izleme ve günlüğe kaydetme</span><span class="sxs-lookup"><span data-stu-id="f669d-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="f669d-174">DevOps genellikle kaçan bir yönünü uygulamalar dağıtıldıktan sonra izler.</span><span class="sxs-lookup"><span data-stu-id="f669d-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="f669d-175">Sunucusuz işlevler izleme için bir strateji olması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f669d-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="f669d-176">En büyük zorluk genellikle bağıntı veya bir kullanıcı aynı etkileşim bir parçası olarak birden çok işlevi çağırdığında algılamayı olur.</span><span class="sxs-lookup"><span data-stu-id="f669d-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="f669d-177">Üçüncü taraf araçlarla günlük konsol aktarılabilen en sunucusuz platformları sağlar.</span><span class="sxs-lookup"><span data-stu-id="f669d-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="f669d-178">Telemetri toplama işlemini otomatikleştirme, oluşturun ve bağıntı kimlikleri izleme ve ayrıntılı bilgiler sağlamak için belirli eylemleri izlemek için seçenekleri vardır.</span><span class="sxs-lookup"><span data-stu-id="f669d-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="f669d-179">Azure Gelişmiş sağlar [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) izleme ve analiz için.</span><span class="sxs-lookup"><span data-stu-id="f669d-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="f669d-180">Hizmetler arası bağımlılıkları</span><span class="sxs-lookup"><span data-stu-id="f669d-180">Inter-service dependencies</span></span>

<span data-ttu-id="f669d-181">Sunucusuz bir mimari diğer işlevleri kullanan işlevler içerebilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="f669d-182">Aslında, onu birden çok hizmet birbiriyle etkileşim ya da dağıtılmış işlem bir parçası olarak çağırmak için sunucusuz bir mimari seyrek değil.</span><span class="sxs-lookup"><span data-stu-id="f669d-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="f669d-183">Güçlü bir bağ önlemek için Hizmetleri birbirine doğrudan başvuru yoksa önerilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="f669d-184">Bir hizmet için uç nokta değişmesi gerektiğinde, doğrudan başvuruların önemli yeniden düzenleme neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="f669d-185">Önerilen çözüm uygun uç noktaya bir istek türü sağlayan bir kayıt defteri gibi bir hizmet bulma mekanizma sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="f669d-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="f669d-186">Hizmetler arasındaki iletişimi için kuyruklar veya konular gibi Mesajlaşma Hizmetleri yararlanarak başka bir çözümdür.</span><span class="sxs-lookup"><span data-stu-id="f669d-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="f669d-187">Hata Yönetimi ve dayanıklılık sağlama</span><span class="sxs-lookup"><span data-stu-id="f669d-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="f669d-188">Dikkate almak önemlidir *devre kesici düzeni*: Herhangi bir nedenle bir hizmet başarısız olmaya devam ederse, bu hizmeti tekrar tekrar çağırmak için önerilir değil.</span><span class="sxs-lookup"><span data-stu-id="f669d-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="f669d-189">Bunun yerine alternatif bir hizmet olarak adlandırılır veya bağımlı hizmetinin sistem durumunu yeniden kurulur kadar bir ileti döndürdü.</span><span class="sxs-lookup"><span data-stu-id="f669d-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="f669d-190">Sunucusuz mimari stratejisi çözme ve hizmet içi bağımlılıkları yönetmek için dikkate almanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f669d-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="f669d-191">Devre kesici düzeni devam etmek için Hizmetleri hataya dayanıklı ve dayanıklı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f669d-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="f669d-192">Hataya dayanıklılık özelliği bile beklenmeyen özel durum sonra çalışmaya devam etmesini uygulamanızın başvurduğu veya geçersiz durumları karşılaşıldı.</span><span class="sxs-lookup"><span data-stu-id="f669d-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="f669d-193">Dayanıklılığı genellikle bir işlev kod ve özel durumları işlemek nasıl yazılmış oluşur.</span><span class="sxs-lookup"><span data-stu-id="f669d-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="f669d-194">Dayanıklılık nasıl özellikli uygulamanın hatalardan Kurtarma sırasında olduğu için ifade eder.</span><span class="sxs-lookup"><span data-stu-id="f669d-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="f669d-195">Dayanıklılığı genellikle sunucusuz platform tarafından yönetilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="f669d-196">Platform var olan bir başarısız olduğunda yeni bir sunucusuz işlev örneği oluşturan dönmeye başlatabilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="f669d-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="f669d-197">Platform, ayrıca her yeni örneği başarısız olduğunda yeni örnekleri hızla çalıştırarak durdurmak akıllı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f669d-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="f669d-198">Daha fazla bilgi için [devre kesici desenini uygulama](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="f669d-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="f669d-199">Sürüm oluşturma ve yeşil/mavi dağıtımları</span><span class="sxs-lookup"><span data-stu-id="f669d-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="f669d-200">Sunucusuz, önemli bir avantajı tüm uygulamayı yeniden dağıtmak zorunda kalmadan belirli bir işlev yükseltmek yeteneğidir.</span><span class="sxs-lookup"><span data-stu-id="f669d-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="f669d-201">Başarılı olması yükseltmeler için bunların çağrılması Hizmetleri kodunun doğru sürüme yönlendirilebilmesi işlevleri tutulan olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f669d-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="f669d-202">Yeni sürümlerini dağıtmak için bir strateji de önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f669d-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="f669d-203">Yaygın bir yaklaşım "Yeşil/dağıtımları mavi." kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="f669d-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="f669d-204">Yeşil dağıtım geçerli bir işlevdir.</span><span class="sxs-lookup"><span data-stu-id="f669d-204">The green deployment is the current function.</span></span> <span data-ttu-id="f669d-205">Yeni "mavi" sürümü üretime dağıtılmadan ve test.</span><span class="sxs-lookup"><span data-stu-id="f669d-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="f669d-206">Yeni sürümü Canlı gelecektir geçişleri test ederken, yeşil ve mavi sürümleri değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="f669d-207">Herhangi bir sorun karşılaşılırsa geri değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f669d-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="f669d-208">Sürüm oluşturma ve yeşil/mavi dağıtımlarını destekleyen bir bileşimi sürüm değişikliklerini uyum sağlamak için İşlevler yazma ve dağıtımları işlemek için sunucusuz platformu ile çalışma gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f669d-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span> <span data-ttu-id="f669d-209">Olası bir yaklaşım açıklanmıştır proxy'leri kullanmaktır [Azure sunucusuz platformu](azure-functions.md#proxies) bölüm.</span><span class="sxs-lookup"><span data-stu-id="f669d-209">One possible approach is to use proxies, which are described in the [Azure serverless platform](azure-functions.md#proxies) chapter.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="f669d-210">[Önceki](serverless-architecture.md)
>[İleri](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="f669d-210">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>
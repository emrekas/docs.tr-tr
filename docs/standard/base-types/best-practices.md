---
title: .NET içinde normal ifadeler için en iyi uygulamalar
description: . NET'te verimli ve etkili normal ifadeler oluşturmayı öğrenin.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
author: rpetrusha
ms.author: ronpet
ms.custom: serodec18
ms.openlocfilehash: 02847a813566c4675f7df2c88fa2e4e1f6138ecb
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/10/2018
ms.locfileid: "53152818"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="a7ec7-103">.NET içinde normal ifadeler için en iyi uygulamalar</span><span class="sxs-lookup"><span data-stu-id="a7ec7-103">Best Practices for Regular Expressions in .NET</span></span>
<a name="top"></a> <span data-ttu-id="a7ec7-104">.NET içinde normal ifade altyapısı yerine desen karşılaştırma ve metin eşleşen metni işleyen güçlü, tam özellikli bir araçtır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="a7ec7-105">Çoğu durumda desen eşleme işlemini hızlı ve verimli şekilde yapar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="a7ec7-106">Ancak bazı durumlarda normal ifade motoru çok yavaş görünebilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="a7ec7-107">Aşırı durumlarda saatler ve hatta günler boyunca görece küçük bir girişi işlerken yanıt vermeyi durdurmuş gibi bile görünebilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>  
  
 <span data-ttu-id="a7ec7-108">Bu konu, normal ifadelerinin en iyi performansa ulaşabilmesi için geliştiricilerin benimseyebileceği en iyi yöntemlerden bazılarını özetlemektedir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span> <span data-ttu-id="a7ec7-109">Aşağıdaki bölümleri içerir:</span><span class="sxs-lookup"><span data-stu-id="a7ec7-109">It contains the following sections:</span></span>  
  
-   [<span data-ttu-id="a7ec7-110">Giriş kaynağını düşünün</span><span class="sxs-lookup"><span data-stu-id="a7ec7-110">Consider the Input Source</span></span>](#InputSource)  
  
-   [<span data-ttu-id="a7ec7-111">Nesne örneklemesini uygun şekilde yönetme</span><span class="sxs-lookup"><span data-stu-id="a7ec7-111">Handle Object Instantiation Appropriately</span></span>](#ObjectInstantiation)  
  
-   [<span data-ttu-id="a7ec7-112">Geri izlemenin alma</span><span class="sxs-lookup"><span data-stu-id="a7ec7-112">Take Charge of Backtracking</span></span>](#Backtracking)  
  
-   [<span data-ttu-id="a7ec7-113">Zaman aşımı değerlerini kullanma</span><span class="sxs-lookup"><span data-stu-id="a7ec7-113">Use Time-out Values</span></span>](#Timeouts)  
  
-   [<span data-ttu-id="a7ec7-114">Yalnızca gerekli olduğunda yakala</span><span class="sxs-lookup"><span data-stu-id="a7ec7-114">Capture Only When Necessary</span></span>](#Capture)  
  
-   [<span data-ttu-id="a7ec7-115">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="a7ec7-115">Related Topics</span></span>](#RelatedTopics)  
  
<a name="InputSource"></a>   
## <a name="consider-the-input-source"></a><span data-ttu-id="a7ec7-116">Giriş Kaynağını düşünün</span><span class="sxs-lookup"><span data-stu-id="a7ec7-116">Consider the Input Source</span></span>  
 <span data-ttu-id="a7ec7-117">Genelde normal ifadeler iki tür giriş kabul edebilir: sınırlandırılmış ya da sınırlandırılmamış.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-117">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="a7ec7-118">Kısıtlı giriş, bilinen ya da güvenilir bir kaynaktan geldiği bilinen ve ön tanımlı bir biçim izleyen metindir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-118">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="a7ec7-119">Sınırlandırılmamış girdi, bir web kullanıcısı gibi güvenilir olmayan bir kaynaktan gelen ve önceden tanımlı veya beklenen bir biçime uymayabilecek bir metindir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-119">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>  
  
 <span data-ttu-id="a7ec7-120">Normal ifade desenleri genelde geçerli girişi eşlemek için yazılır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-120">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="a7ec7-121">Diğer bir deyişle, geliştiriciler eşleştirmek istedikleri metni inceler ve bu metinle eşleşen normal bir ifade deseni yazarlar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-121">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="a7ec7-122">Geliştiriciler daha sonra bu desenin düzeltme ya da daha fazla ayrıntı gerektirip gerektirmediğini, birden çok geçerli giriş öğesini test ederek belirler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-122">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="a7ec7-123">Desen gereçli olduğu kabul edilen tüm girdilerle eşleştiğinde, üretime hazır kabul edilir ve çıkacak uygulamaya dahil edilebilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-123">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="a7ec7-124">Bu, normal bir ifade desenini, kısıtlanmış girdiyle eşleşme için uygun hale getirir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-124">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="a7ec7-125">Ancak sınırlandırılmamış girişin eşlenmesi uygun hale getirmez.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-125">However, it does not make it suitable for matching unconstrained input.</span></span>  
  
 <span data-ttu-id="a7ec7-126">Sınırlandırılmamış girdide eşlemek yapmak için, normal bir ifade üç tür metni verimli olarak işleyebilmelidir:</span><span class="sxs-lookup"><span data-stu-id="a7ec7-126">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>  
  
-   <span data-ttu-id="a7ec7-127">Normal ifade deseniyle eşleşen metin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-127">Text that matches the regular expression pattern.</span></span>  
  
-   <span data-ttu-id="a7ec7-128">Normal ifade deseniyle eşleşmeyen metin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-128">Text that does not match the regular expression pattern.</span></span>  
  
-   <span data-ttu-id="a7ec7-129">Normal ifade deseniyle neredeyse eşleşen metin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-129">Text that nearly matches the regular expression pattern.</span></span>  
  
 <span data-ttu-id="a7ec7-130">Son metin türü, sınırlandırılmış girdi işlemek üzere yazılmış bir normal ifade için özellikle sorunludur.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-130">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="a7ec7-131">Bu normal ifade ayrıca kapsamlı dayanıyorsa [geri izlemenin](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), normal ifade motoru normal dışı miktarda zamanı ayırabilirsiniz (bazı durumlarda saatler ya da günler) görünüşte zararsız bir metni işlemeye.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-131">If that regular expression also relies on extensive [backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="a7ec7-132">Aşağıdaki örnek, aşırı miktarda geri dönüş kullanma eğiliminde olan ve geçerli e-posta adreslerini reddetmesi olası bir normal ifadeyi kullanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-132">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="a7ec7-133">Bir e-posta doğrulama yordamında kullanmamalısınız.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-133">You should not use it in an email validation routine.</span></span> <span data-ttu-id="a7ec7-134">E-posta adreslerini onaylayan bir normal ifade isterseniz bkz [nasıl yapılır: Dizelerin geçerli e-posta biçiminde olduğunu doğrulama](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="a7ec7-134">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
 <span data-ttu-id="a7ec7-135">Örneğin bir e-posta adresinin takma adını onaylamak için çok yaygın kullanılan ama son derece sorunlu normal ifade düşünün.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-135">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="a7ec7-136">Normal ifade `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` ne ve ardından sıfır veya daha fazla alfasayısal karakter, nokta veya kısa çizgi, alfasayısal bir karakterle oluşan bir geçerli e-posta adresi olarak kabul edilir için yazılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-136">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="a7ec7-137">Normal ifade, alfasayısal bir karakterle bitmelidir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-137">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="a7ec7-138">Ancak aşağıdaki örnekte gösterildiği gibi, bu normal ifade geçerli girişi kolayca yönetmesine rağmen performansı neredeyse geçerli girişi işlerken çok yetersizdir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-138">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]  
  
 <span data-ttu-id="a7ec7-139">Örneğin çıktısında gösterildiği üzere normal ifade motoru geçerli e-posta takma adlarını, uzunluğundan bağımsız olarak yaklaşık aynı zaman aralığında işler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-139">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="a7ec7-140">Diğer taraftan, yakın geçerli e-posta adresi beşten fazla karakter içeriyorsa, işlem zamanı dizedeki ek her karakter için yaklaşık iki kat olacaktır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-140">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="a7ec7-141">Bunun anlamı, neredeyse geçerli 28-karakter dizesi işlemek için bir saatten fazla götürecek ve neredeyse geçerli 33-karakter dizesi işlemek için neredeyse bir gün sürecektir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-141">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>  
  
 <span data-ttu-id="a7ec7-142">Bu düzenli ifade yalnızca eşlenecek girişin biçimi düşünülerek geliştirildiğinden desen ile eşleşmeyen girişi hesaba katamaz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-142">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="a7ec7-143">Bu da normal ifade deseniyle neredeyse eşleşen sınırlandırılmamış girdinin performansı önemli ölçüde düşürmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-143">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>  
  
 <span data-ttu-id="a7ec7-144">Bu sorunu çözmek için, şunları yapabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="a7ec7-144">To solve this problem, you can do the following:</span></span>  
  
-   <span data-ttu-id="a7ec7-145">Bir desen geliştirirken, özellikle de normal ifadeniz sınırlandırılmamış girdiyi işlemek üzere tasarlandıysa, geri dönüşün normal ifade altyapısının performansını nasıl etkileyeceğini düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-145">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="a7ec7-146">Daha fazla bilgi için [olması, ücretsiz olarak geri](#Backtracking) bölümü.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-146">For more information, see the [Take Charge of Backtracking](#Backtracking) section.</span></span>  
  
-   <span data-ttu-id="a7ec7-147">Normal ifadenizi geçerli girdilerin yanı sıra gereçsiz ve neredeyse geçerli girdiler de kullanarak baştan aşağı test edin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-147">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="a7ec7-148">Belirli bir normal ifadeye girdi üretmek için kullanabileceğiniz [Rex](https://www.microsoft.com/en-us/research/project/rex-regular-expression-exploration/), Microsoft Research'den bir normal ifade İnceleme aracı.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-148">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/en-us/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>  
  
 [<span data-ttu-id="a7ec7-149">Başa dön</span><span class="sxs-lookup"><span data-stu-id="a7ec7-149">Back to top</span></span>](#top)  
  
<a name="ObjectInstantiation"></a>   
## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="a7ec7-150">Nesne Örneklemesini Uygun Şekilde Yönetme</span><span class="sxs-lookup"><span data-stu-id="a7ec7-150">Handle Object Instantiation Appropriately</span></span>  
 <span data-ttu-id="a7ec7-151">Yaklaşımının temelindeki. NET normal ifade nesnesi modeli <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> sınıfı, normal ifade motorunu temsil eder.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-151">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="a7ec7-152">Genellikle, normal ifade performansını etkileyen tekil en büyük faktör şeklidir <xref:System.Text.RegularExpressions.Regex> altyapısı kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-152">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="a7ec7-153">Normal bir ifadeyi tanımlama, normal ifade motorunu bir normal ifade deseni ile sıkı şekilde eşlemeyi içerir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-153">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="a7ec7-154">İşlem eşlenmesiyle, mi, örnekleme içerdiğini bir <xref:System.Text.RegularExpressions.Regex> nesnesine, yapıcısına bir normal ifade deseni geçerek veya statik bir yöntemi, normal ifade desenini çözümlenecek dizeyle birlikte geçirerek çağırmak, tarafından zorunluluktur bir pahalı bir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-154">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7ec7-155">Yorumlanmış ve derlenmiş normal ifadelerin kullanımının performans etkilerinin daha ayrıntılı bir açıklaması için bkz: [normal ifade performansını en iyi duruma getirme, Kısım II: Ücret, geri alma](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) bkz.BCL Ekibi blogunda.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-155">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) in the BCL Team blog.</span></span>  
  
 <span data-ttu-id="a7ec7-156">Normal ifade altyapısını belirli bir normal ifade deseniyle birleştirebilir, sonra altyapıyı birkaç şekilde metin eşlemesi yapmak üzere kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="a7ec7-156">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>  
  
-   <span data-ttu-id="a7ec7-157">Gibi bir statik desen eşleme yöntemini çağırabilirsiniz <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-157">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a7ec7-158">Bu, bir normal ifade nesnesine öndeğer atanmasını gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-158">This does not require instantiation of a regular expression object.</span></span>  
  
-   <span data-ttu-id="a7ec7-159">Örneği oluşturabilir bir <xref:System.Text.RegularExpressions.Regex> nesne ve yorumlanan normal ifade örneğinin desen eşleme yöntemini çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-159">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="a7ec7-160">Bu, normal ifade altyapısını bir normal ifade desenine bağlamak için varsayılan yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-160">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="a7ec7-161">Sonuç olduğunda bir <xref:System.Text.RegularExpressions.Regex> nesnesi örneği olmadan bir `options` içeren bağımsız değişken <xref:System.Text.RegularExpressions.RegexOptions.Compiled> bayrağı.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-161">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>  
  
-   <span data-ttu-id="a7ec7-162">Örneği oluşturabilir bir <xref:System.Text.RegularExpressions.Regex> nesne ve derlenmiş normal ifade örneğinin desen eşleme yöntemini çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-162">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="a7ec7-163">Normal ifade nesneleri derlenmiş desenleri temsil eder ne zaman bir <xref:System.Text.RegularExpressions.Regex> nesnesi örneği ile bir `options` içeren bağımsız değişken <xref:System.Text.RegularExpressions.RegexOptions.Compiled> bayrağı.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-163">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>  
  
-   <span data-ttu-id="a7ec7-164">Oluşturabileceğiniz özel amaçlı <xref:System.Text.RegularExpressions.Regex> bir belirli bir normal ifade deseniyle katı olarak birleştirilmiş sıkı bir şekilde nesne, derleyebilir ve tek başına bir derleme için kaydedin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-164">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="a7ec7-165">Çağrı yaparak bunu <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-165">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a7ec7-166">Normal ifade eşleme yöntemlerini çağırma biçiminizin uygulamanız üzerinde önemli bir etkisi olabilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-166">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="a7ec7-167">Aşağıdaki bölümler, uygulamanızın performansını iyileştirmek için statik yöntem çağrılarının, yorumlanan normal ifadelerin ve derlenmiş normal ifadelerin ne zaman kullanılacağını tartışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-167">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7ec7-168">Yöntem çağrılarında aynı normal ifade tekrar tekrar kullanılıyorsa veya uygulama normal ifade nesnelerini yoğun olarak kullanıyorsa, yöntem çağrısının biçimi (statik, yorumlanan, derlenmiş) performansı etkiler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-168">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>  
  
### <a name="static-regular-expressions"></a><span data-ttu-id="a7ec7-169">Statik Normal İfadeler</span><span class="sxs-lookup"><span data-stu-id="a7ec7-169">Static Regular Expressions</span></span>  
 <span data-ttu-id="a7ec7-170">Statik normal ifade yöntemleri, bir normal ifade nesnesine aynı normal ifadeyi tekrar tekrar ön değer olarak atamaya alternatif olarak önerilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-170">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="a7ec7-171">Normal ifade nesneleri tarafından kullanılan normal ifade desenlerinden farklı olarak örnek yöntemi çağrılarında kullanılan desenlerin işlem kodları veya derlenmiş Microsoft ara dili (MSIL), normal ifade motoru tarafından dahili olarak önbelleğe alınır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-171">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in instance method calls is cached internally by the regular expression engine.</span></span>  
  
 <span data-ttu-id="a7ec7-172">Örneğin bir olay işleyicisi, kullanıcı girişini onaylamak için sık sık başka bir yöntem çağırır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-172">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="a7ec7-173">Bunu aşağıdaki kodda yansıtılan bir <xref:System.Windows.Forms.Button> denetimin <xref:System.Windows.Forms.Control.Click> yöntemini çağırmak için kullanılan olay `IsValidCurrency`, kullanıcının bir para simgesi ve en az bir adet ondalık rakam ardından girdiği olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-173">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]  
  
 <span data-ttu-id="a7ec7-174">Bir çok verimsiz bir uygulaması `IsValidCurrency` yöntemi, aşağıdaki örnekte gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-174">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="a7ec7-175">Her yöntem çağrısının yeniden başlattığına dikkat edin bir <xref:System.Text.RegularExpressions.Regex> aynı desene sahip bir nesne.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-175">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="a7ec7-176">Bu ise normal ifade deseninin yöntem her çağrıldığında tekrar derlenmesi gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-176">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]  
  
 <span data-ttu-id="a7ec7-177">Bu Verimsiz kodu statik bir çağrıyla değiştirmelisiniz <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-177">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a7ec7-178">Bu örneği oluşturmak için ihtiyacını ortadan kaldıran bir <xref:System.Text.RegularExpressions.Regex> nesne her zaman bir desen eşleme yöntemini çağırmak istediğinizde ve normal ifade altyapısının normal ifadenin derlenmiş bir sürümünü önbelleğinden almasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-178">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]  
  
 <span data-ttu-id="a7ec7-179">Varsayılan olarak, en son kullanılan 15 statik normal ifade deseni önbelleğe alınır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-179">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="a7ec7-180">Ayarlayarak, çok sayıda önbelleğe alınmış statik normal ifade gerektiren uygulamalarda, önbellek boyutu ayarlanabilir <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> özelliği.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-180">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="a7ec7-181">Normal ifade `\p{Sc}+\s*\d+` kullanılan bu örnek giriş dizesinde bir para birimi sembolü ve en az bir adet ondalık rakam olduğunu doğrulamaktır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-181">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="a7ec7-182">Desen aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-182">The pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7ec7-183">Desen</span><span class="sxs-lookup"><span data-stu-id="a7ec7-183">Pattern</span></span>|<span data-ttu-id="a7ec7-184">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a7ec7-184">Description</span></span>|  
|-------------|-----------------|  
|`\p{Sc}+`|<span data-ttu-id="a7ec7-185">Unicode Sembolü, Para Birimi kategorisinde bir ya da daha fazla karakter eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-185">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|  
|`\s*`|<span data-ttu-id="a7ec7-186">Sıfır veya daha fazla boşluk karakteriyle eşleş.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-186">Match zero or more white-space characters.</span></span>|  
|`\d+`|<span data-ttu-id="a7ec7-187">Bir veya daha fazla ondalık basamağı eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-187">Match one or more decimal digits.</span></span>|  
  
<a name="Interpreted"></a>   
### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="a7ec7-188">Yorumlanan vs. Derlenmiş normal ifadeler</span><span class="sxs-lookup"><span data-stu-id="a7ec7-188">Interpreted vs. Compiled Regular Expressions</span></span>  
 <span data-ttu-id="a7ec7-189">Normal ifade motoruna belirtimi bağlı olmayan normal ifade desenleri <xref:System.Text.RegularExpressions.RegexOptions.Compiled> seçeneği yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-189">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="a7ec7-190">Bir normal ifade nesnesi örneği oluşturulduğunda, normal ifade altyapısı normal ifadeyi bir dizi işlem koduna dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-190">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="a7ec7-191">Bir örnek yöntemi çağrıldığında, işlem kodları MSIL'ye dönüştürülür ve JIT derleyicisi tarafından yürütülür.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-191">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="a7ec7-192">Benzer şekilde, statik bir normal ifade yöntemi çağrıldığı ve normal ifade önbellekte bulunamadığı zaman, normal ifade altyapısı normal ifadeyi bir dizi işlem koduna dönüştürür ve bunları önbellekte depolar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-192">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="a7ec7-193">Daha sonra işlem kodlarını MSIL'ye dönüştürür, bu sayede JIT derleyicisi bunları yürütebilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-193">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="a7ec7-194">Yorumlanmış normal ifadeler, daha yavaş yürütme sürelerine karşın açılış süresini azaltır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-194">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="a7ec7-195">Bundan dolayı bunlar, normal ifade az sayıda yöntem çağrısında kullanıldığında ya da normal ifade yöntemine yapılan kesin çağrı sayısı bilinmiyor ancak küçük olması bekleniyorsa en iyi şekilde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-195">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="a7ec7-196">Yöntem çağrıları arttıkça performans kazancı daha az başlangıç saatinden sayısı daha yavaş yürütme hızını outstripped gibi.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-196">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>  
  
 <span data-ttu-id="a7ec7-197">Normal ifade motoruna belirtimi normal ifade desenleri <xref:System.Text.RegularExpressions.RegexOptions.Compiled> seçeneği derlenir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-197">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="a7ec7-198">Bu, bir normal ifade nesnesi örneği oluşturulduğunda veya statik bir normal ifade yöntemi çağrıldığında ve normal ifade önbellekte bulunamadığında, normal ifade altyapısının normal ifadeyi ara bir işlem kodu kümesine, sonra da bunu MSIL'ye dönüştürdüğü anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-198">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="a7ec7-199">Bir yöntem çağrıldığında, JIT derleyici MSIL'yi yürütür.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-199">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="a7ec7-200">Yorumlanmış normal ifadelerin aksine, derlenmiş normal ifadeler açılış süresini artırır ancak ayrı desen eşleme yöntemlerini daha hızlı yürütür.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-200">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="a7ec7-201">Sonuç olarak normal ifade derlemekten kaynaklanan sonuçlardan yararlanan performans çağrılan normal ifade yöntemlerinin sayısı oranında artar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-201">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>  
  
 <span data-ttu-id="a7ec7-202">Özetlemek gerekirse, normal ifade yöntemlerini belirli bir normal ifadeyle nispeten ender olarak çağırıyorsanız, yorumlanan normal ifadeler kullanmanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-202">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="a7ec7-203">Normal ifade yöntemlerinizi oldukça sık olarak belirli bir normal ifadeyle çağırıyorsanız, derlenmiş normal ifadeler kullanmalısınız.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-203">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="a7ec7-204">Yorumlanan normal ifadelerin yürütülme hızlarındaki yavaşlığın bunların başlama süresinin kısa olmasından elde edilen avantajı ortadan kaldırmaya başladığı eşiği veya derlenmiş normal ifadelerin başlama süresinin uzunluğunun bunların yürütülme hızından elde edilen avantajı ortadan kaldırmaya başladığı eşiği belirlemek güçtür.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-204">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="a7ec7-205">Normal ifadenin karmaşıklığı ve bunun işlediği özel veri gibi çeşitli faktörlere bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-205">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="a7ec7-206">Yorumlanan mi, derlenmiş normal ifadeler, belirli uygulama senaryonuzda en iyi performansı sunan belirlemek için kullanabileceğiniz <xref:System.Diagnostics.Stopwatch> bunların yürütme sürelerini karşılaştırmak üzere sınıfı.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-206">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>  
  
 <span data-ttu-id="a7ec7-207">Aşağıdaki örnek metni Theodore Dreiser'ın tüm cümleleri okunurken ilk on okurken derlenmiş ve yorumlanan normal ifadelerin ve performansını karşılaştırır *The Financier*.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-207">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="a7ec7-208">Örneğin çıktısında gösterildiği üzere normal ifade eşleme yöntemlerine yalnızca on çağrı yapıldığında, yorumlanan bir normal ifade derlenmiş bir normal ifadeden daha iyi performans sergiler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-208">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="a7ec7-209">Ancak derlenmiş bir normal ifade, daha fazla sayıda çağrı yapıldığında (bu örnekte 13.000'den fazla) daha iyi performans gösterir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-209">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]  
  
 <span data-ttu-id="a7ec7-210">Örnekte kullanılan normal ifade deseni `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, aşağıdaki tabloda gösterildiği gibi tanımlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-210">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7ec7-211">Desen</span><span class="sxs-lookup"><span data-stu-id="a7ec7-211">Pattern</span></span>|<span data-ttu-id="a7ec7-212">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a7ec7-212">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7ec7-213">Bir sözcük sınırında eşleşmeye başla.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-213">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="a7ec7-214">Bir veya daha fazla sözcük karakteri eşleştir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-214">Match one or more word characters.</span></span>|  
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="a7ec7-215">Arkasından bir yeni satır karakteri gelen sıfır ya da bir satır başı veya arkasından bir boşluk karakteri gelen sıfır ya da bir virgül eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-215">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|  
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="a7ec7-216">Arkasından sıfır ya da bir satır başı ve bir yeni satır karakteri veya sıfır ya da bir virgül ve sonra boşluk karakteri gelen bir ya da daha fazla sözcük karakterinin sıfır ya da daha fazla oluşumunu eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-216">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|  
|`\w+`|<span data-ttu-id="a7ec7-217">Bir veya daha fazla sözcük karakteri eşleştir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-217">Match one or more word characters.</span></span>|  
|`[.?:;!]`|<span data-ttu-id="a7ec7-218">Bir nokta, soru işareti, iki nokta üst üste, noktalı virgül ya da ünlem işareti eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-218">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|  
  
### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="a7ec7-219">Normal ifadeler: Bir derlemeye derlenen</span><span class="sxs-lookup"><span data-stu-id="a7ec7-219">Regular Expressions: Compiled to an Assembly</span></span>  
 <span data-ttu-id="a7ec7-220">.NET, derlenmiş normal ifadeler içeren bir bütünleştirilmiş kod oluşturmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-220">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="a7ec7-221">Bu, normal ifade derlemesinin uğradığı performans düşüşünü çalışma zamanından tasarım zamanına taşır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-221">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="a7ec7-222">Ancak, bazı ek işleri de içerir: Normal ifadeleri önceden tanımlamanız ve bunları bir derlemeye derlemek gerekir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-222">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="a7ec7-223">Derleyici daha sonra, derlemenin normal ifadelerini kullanan kaynak kodunu derlerken bu derlemeye başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-223">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="a7ec7-224">Derleme içinde derlenen her normal ifade, türetilen bir sınıf tarafından temsil edilen <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-224">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>  
  
 <span data-ttu-id="a7ec7-225">Normal ifadeleri bir derleme olarak derlemek için çağrı <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> yöntemi ve bir dizi geçirin <xref:System.Text.RegularExpressions.RegexCompilationInfo> derlenecek normal ifadeleri temsil eden nesneleri ve bir <xref:System.Reflection.AssemblyName> olmasını derleme hakkında bilgi içeren nesne oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-225">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>  
  
 <span data-ttu-id="a7ec7-226">Aşağıdaki durumlarda normal ifadeleri bütünleşik bir dosyaya derlemenizi öneririz:</span><span class="sxs-lookup"><span data-stu-id="a7ec7-226">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>  
  
-   <span data-ttu-id="a7ec7-227">Yeniden kullanılabilir normal ifadeler üretmek isteyen yetkin bir geliştiriciyseniz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-227">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>  
  
-   <span data-ttu-id="a7ec7-228">Normal ifadenizin desen eşleme yöntemlerinizin belirsiz kere (bir ya da iki kezden binlerce ya da on binlerce defa) çağrılmasını bekliyorsanız.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-228">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="a7ec7-229">Derlenmiş veya yorumlanan normal ifadelerden farklı olarak, ayrı derlemelere derlenen normal ifadeler, yöntem çağrısı sayısından bağımsız olarak tutarlı bir performans sunar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-229">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>  
  
 <span data-ttu-id="a7ec7-230">Performansı en iyi hale getirmek için derlenmiş normal ifadeler kullanıyorsanız, derlemeyi oluşturmak, normal ifade motorunu yüklemek ve bunun desen eşleyen yöntemlerini yürütmek için yansıtma kullanmamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-230">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="a7ec7-231">Bu, normal ifade desenlerini dinamik olarak oluşturmaktan kaçınmanızı ve desen eşleme seçeneklerini (örneğin harf büyüklüğüne duyarlı eşleme) derleme oluşturulurken belirtmenizi gerekli kılar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-231">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="a7ec7-232">Ayrıca derlemeyi, normal ifadeyi kullanan koddan oluşturan kodu ayırmanızı gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-232">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>  
  
 <span data-ttu-id="a7ec7-233">Aşağıdaki örnek, derlenmiş bir normal ifade içeren bir derlemenin nasıl oluşturulacağını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-233">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="a7ec7-234">Adlı bir derleme oluşturur `RegexLib.dll` bir tek normal ifade sınıfına sahip `SentencePattern`, cümle eşleşmeli normal ifade içeren kullanılan desen [vs yorumlanır. Derlenmiş normal ifadeler](#Interpreted) bölümü.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-234">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#Interpreted) section.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]  
  
 <span data-ttu-id="a7ec7-235">Örnek bir yürütülebilir dosyayı ve çalışma derlendiğinde adlı bir derleme oluşturur. `RegexLib.dll`.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-235">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="a7ec7-236">Normal ifade adlı bir sınıf tarafından temsil edilen `Utilities.RegularExpressions.SentencePattern` sınıfından türetilen <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-236">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="a7ec7-237">Aşağıdaki örnek, derlenmiş normal ifadeyi Theodore Dreiser'ın metni cümleler ayıklamak için ardından kullanır *The Financier*.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-237">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]  
  
 [<span data-ttu-id="a7ec7-238">Başa dön</span><span class="sxs-lookup"><span data-stu-id="a7ec7-238">Back to top</span></span>](#top)  
  
<a name="Backtracking"></a>   
## <a name="take-charge-of-backtracking"></a><span data-ttu-id="a7ec7-239">Geriye Dönüşü Denetimini El Alma</span><span class="sxs-lookup"><span data-stu-id="a7ec7-239">Take Charge of Backtracking</span></span>  
 <span data-ttu-id="a7ec7-240">Sıradan şekilde, normal ifade motoru bir giriş dizsi içinde ilerlemek ve bunu bir normal ifade deseni ile karşılaştırmak için doğrusal ilerlemeyi kullanır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-240">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="a7ec7-241">Ancak, gibi belirsiz miktar belirleyiciler `*`, `+`, ve `?` kullanılan normal ifade deseninde, normal ifade altyapısı başarılı kısmi eşleşmelerin bir kısmını verin ve önceden kaydedilmiş bir duruma geri dönebilir ve tüm desen için başarılı bir eşleşme aramak amacıyla.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-241">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="a7ec7-242">Bu işlem geri dönüş olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-242">This process is known as backtracking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7ec7-243">Geri izleme hakkında daha fazla bilgi için bkz: [normal ifade davranışının ayrıntıları](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) ve [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="a7ec7-243">For more information on backtracking, see [Details of Regular Expression Behavior](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) and [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="a7ec7-244">Geri izlemenin ayrıntılı bir açıklaması için bkz: [normal ifade performansını en iyi duruma getirme, Kısım II: Ücret, geri alma](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) bkz.BCL Ekibi blogunda.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-244">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) in the BCL Team blog.</span></span>  
  
 <span data-ttu-id="a7ec7-245">Geri dönüş için destek, normal ifadelere güç ve esneklik kazandırır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-245">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="a7ec7-246">Ayrıca normal ifade motorunun çalışmasının denetlenmesini sorumluluğunu normal ifade geliştiricisine teslim eder.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-246">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="a7ec7-247">Geliştiriciler genelde bu sorumluluğun farkında olmadığından, geri dönüşü yanlış kullanmaları ya da aşırı geri dönüşe bağımlılıkları genelde normal ifade performansının düşmesinde önemli bir rol oynar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-247">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="a7ec7-248">En kötü senaryoda yürütme süresi girdi dizesinde her ek karakter ile iki katına çıkar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-248">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="a7ec7-249">Aslında geri izlemeyi aşırı şekilde kullanarak, girişin normal ifade desenini yakın eşlemesi halinde sonsuz bir döngünün program eşdeğerini oluşturmak kolaydır; normal ifade motorunun görece kısa bir giriş dizesini işlemesi saatler ve hatta günler alabilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-249">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>  
  
 <span data-ttu-id="a7ec7-250">Genelde, geri izlemenin bir eşleme için gerekli olmadığı gerçeğine rağmen uygulamalar geri izleme kullandıkları için bir ceza öder.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-250">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="a7ec7-251">Örneğin, normal ifade `\b\p{Lu}\w*\b` aşağıdaki tabloda gösterildiği gibi bir büyük harf karakteri ile başlayan tüm sözcüklerle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-251">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>  
  
|<span data-ttu-id="a7ec7-252">Desen</span><span class="sxs-lookup"><span data-stu-id="a7ec7-252">Pattern</span></span>|<span data-ttu-id="a7ec7-253">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a7ec7-253">Description</span></span>|  
|-|-|  
|`\b`|<span data-ttu-id="a7ec7-254">Bir sözcük sınırında eşleşmeye başla.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-254">Begin the match at a word boundary.</span></span>|  
|`\p{Lu}`|<span data-ttu-id="a7ec7-255">Bir büyük harfli karakter eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-255">Match an uppercase character.</span></span>|  
|`\w*`|<span data-ttu-id="a7ec7-256">Sıfır veya daha fazla sözcük karakteriyle eşleş.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-256">Match zero or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="a7ec7-257">Eşlemeyi bir sözcük sınırında sonlandır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-257">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="a7ec7-258">Bir kelime sınırı bir kelime karakteri ile aynı ya da bunu bir alt kümesi olmadığından, normal ifade motorunun kelime karakterlerini eşlerken bir kelime sınırı geçirmesi mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-258">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="a7ec7-259">Bunun anlamı şudur: bu normal ifadede geri dönüş, herhangi bir eşleşmenin genel başarısına hiçbir zaman katkıda bulunamaz; olsa olsa performansı düşürebilir, çünkü normal ifade altyapısı başarılı her sözcük karakteri eşleşmesindeki durumunu kaydetmeye zorlanır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-259">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>  
  
 <span data-ttu-id="a7ec7-260">Geri izlemenin gerekli olmadığını belirlerseniz, onu kullanarak devre dışı bırakabilirsiniz `(?>subexpression)` dil öğesi.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-260">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element.</span></span> <span data-ttu-id="a7ec7-261">Aşağıdaki örnek, bir girdi dizesini iki normal ifade kullanarak ayrıştırmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-261">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="a7ec7-262">Birincisi, `\b\p{Lu}\w*\b`, geri dönüş kullanır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-262">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="a7ec7-263">İkinci `\b\p{Lu}(?>\w*)\b`, geri izlemeyi devre dışı bırakır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-263">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="a7ec7-264">Örneğin çıktısında gösterildiği üzere bunların her ikisi de aynı sonucu üretir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-264">As the output from the example shows, they both produce the same result.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]  
  
 <span data-ttu-id="a7ec7-265">Birçok durumda, geri izleme bir normal ifade desenini giriş metnine eşlemek için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-265">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="a7ec7-266">Ancak aşırı geri izleme performansı ciddi şekilde azaltabilir ve uygulamanın yanıt vermediği izlenimine yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-266">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="a7ec7-267">Bu durum, özellikle, miktar belirleyiciler yuvalandığında ve metin dış alt ifadeyle eşleşen metin, dış alt ifadeyle eşleşen metnin bir alt kümesi olduğunda gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-267">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="a7ec7-268">Aşırı geri izlemeyi önlemeye ek olarak, aşırı geri izlemenin normal ifade performansını ciddi şekilde bozmayacağından emin olmak için zaman aşımı özelliğini de kullanmalısınız.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-268">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="a7ec7-269">Daha fazla bilgi için [zaman aşımı değerlerini kullanma](#Timeouts) bölümü.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-269">For more information, see the [Use Time-out Values](#Timeouts) section.</span></span>  
  
 <span data-ttu-id="a7ec7-270">Örneğin, normal ifade deseni `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` en az bir alfasayısal karakterden oluşan bir parça numarasını eşlemek içindir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-270">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="a7ec7-271">Bir ek karakter bir alfasayısal karakter, bir ayırma çizgisi, bir alt çizgi ya da bir nokta olabilir, ancak son karakter alfasayısal olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-271">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="a7ec7-272">Bir dolar işareti parça numarasını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-272">A dollar sign terminates the part number.</span></span> <span data-ttu-id="a7ec7-273">Bazı durumlarda, bu normal ifade deseni son derece düşük performans belirleyiciler olduğundan ve çünkü sergiler alt ifade `[0-9A-Z]` alt ifade bir alt kümesi `[-.\w]*`.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-273">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>  
  
 <span data-ttu-id="a7ec7-274">Bu durumlarda, yuvalanan miktar belirleyicileri kaldırarak ve dış alt ifadeyi sıfır genişliğinde bir ileriye dönük ya da geriye dönük onay ile değiştirerek normal ifade performansını en iyi hale getireceksiniz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-274">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="a7ec7-275">İleriye dönük ve geriye dönük onaylar tutturuculardır; bunlar giriş dizesindeki işaretçiyi kaydırmaz, bunun yerine belirtilen koşulun sağlanıp sağlanmadığını kontrol etmek için ileriye ya da geriye bakar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-275">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="a7ec7-276">Örneğin, parça numarası normal ifadesi şeklinde yeniden yazılabilir `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-276">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="a7ec7-277">Bu normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-277">This regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="a7ec7-278">Desen</span><span class="sxs-lookup"><span data-stu-id="a7ec7-278">Pattern</span></span>|<span data-ttu-id="a7ec7-279">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a7ec7-279">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="a7ec7-280">Giriş dizesinin başında eşleşmeye başla.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-280">Begin the match at the beginning of the input string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="a7ec7-281">Alfasayısal bir karakterle eşleştirin</span><span class="sxs-lookup"><span data-stu-id="a7ec7-281">Match an alphanumeric character.</span></span> <span data-ttu-id="a7ec7-282">Parça numarası en azından bu karakteri içermelidir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-282">The part number must consist of at least this character.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="a7ec7-283">Herhangi bir sözcük karakteri, kesme ya da noktanın sıfır ya da daha fazla oluşumunu eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-283">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|  
|`\$`|<span data-ttu-id="a7ec7-284">Bir dolar işareti eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-284">Match a dollar sign.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="a7ec7-285">Önceki karakterin alfa sayısal olduğundan emin olmak için sonlandıran dolar işaretinin önüne bakın.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-285">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|  
|`$`|<span data-ttu-id="a7ec7-286">Giriş dizesinin sonunda eşleşmeyi bitir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-286">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="a7ec7-287">Aşağıdaki örnek, bu normal ifadenin parça numaraları içeriyor olabilecek bir diziyi eşleştirmek için kullanımını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-287">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]  
  
 <span data-ttu-id="a7ec7-288">.NET içinde normal ifade dili, iç içe niceleyicileri çıkarmak için kullanabileceğiniz aşağıdaki dil öğelerini içerir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-288">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="a7ec7-289">Daha fazla bilgi için [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="a7ec7-289">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
|<span data-ttu-id="a7ec7-290">Dil öğesi</span><span class="sxs-lookup"><span data-stu-id="a7ec7-290">Language element</span></span>|<span data-ttu-id="a7ec7-291">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a7ec7-291">Description</span></span>|  
|----------------------|-----------------|  
|<span data-ttu-id="a7ec7-292">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="a7ec7-292">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="a7ec7-293">Sıfır genişlikli pozitif ileriye yönelik onay.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-293">Zero-width positive lookahead.</span></span> <span data-ttu-id="a7ec7-294">Belirlemek için geçerli konumun önüne bakın olmadığını `subexpression` giriş dizesi ile eşleştiğini.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-294">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|  
|<span data-ttu-id="a7ec7-295">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="a7ec7-295">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="a7ec7-296">Sıfır genişlikli negatif ileriye yönelik onay.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-296">Zero-width negative lookahead.</span></span> <span data-ttu-id="a7ec7-297">Belirlemek için geçerli konumun önüne bakın olmadığını `subexpression` giriş dizesi ile eşleşmiyor.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-297">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|  
|<span data-ttu-id="a7ec7-298">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="a7ec7-298">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="a7ec7-299">Sıfır genişlikli pozitif geriye yönelik onay.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-299">Zero-width positive lookbehind.</span></span> <span data-ttu-id="a7ec7-300">Belirlemek için geçerli konumun arkasına bakın olmadığını `subexpression` giriş dizesi ile eşleştiğini.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-300">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|  
|<span data-ttu-id="a7ec7-301">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="a7ec7-301">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="a7ec7-302">Sıfır genişlikli negatif geriye yönelik onay.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-302">Zero-width negative lookbehind.</span></span> <span data-ttu-id="a7ec7-303">Belirlemek için geçerli konumun arkasına bakın olmadığını `subexpression` giriş dizesi ile eşleşmiyor.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-303">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|  
  
 [<span data-ttu-id="a7ec7-304">Başa dön</span><span class="sxs-lookup"><span data-stu-id="a7ec7-304">Back to top</span></span>](#top)  
  
<a name="Timeouts"></a>   
## <a name="use-time-out-values"></a><span data-ttu-id="a7ec7-305">Zaman Aşımı Değerlerini Kullanma</span><span class="sxs-lookup"><span data-stu-id="a7ec7-305">Use Time-out Values</span></span>  
 <span data-ttu-id="a7ec7-306">Normal ifadeleriniz, normal ifade deseniyle neredeyse eşleşen girişleri işleme alıyorsa, sıkça aşırı geri izlemeye dayanıyor olabilir, bu da performansı önemli ölçüde etkiler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-306">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="a7ec7-307">Normal ifadenin yakın eşleme girişine karşı geri izlemesi ve testine ilişkin kullanımınızı dikkatle düşünmeye ek olarak, gerçekleşmesi halinde aşırı geri izleme etkisinin en aza indirilmesini sağlamak için mutlaka bir zaman aşımı değeri belirlemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-307">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>  
  
 <span data-ttu-id="a7ec7-308">Normal ifade zaman aşımı aralığı, normal ifade altyapısının zaman aşımına uğramadan önce tek bir eşleşen arayacağı süreyi tanımlar. Varsayılan zaman aşımı aralığı <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, normal ifade zaman aşımına olacağı anlamına gelir. Aşağıdaki şekilde bu değeri geçersiz kılabilir ve bir zaman aşımı aralığı tanımlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="a7ec7-308">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>  
  
-   <span data-ttu-id="a7ec7-309">Başlattığınızda bir zaman aşımı değeri sağlayarak bir <xref:System.Text.RegularExpressions.Regex> çağırarak <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Oluşturucusu.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-309">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="a7ec7-310">Yöntemi gibi bir statik desen çağırarak <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> veya <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, içeren bir `matchTimeout` parametresi.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-310">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>  
  
-   <span data-ttu-id="a7ec7-311">Çağrılarak oluşturulmuş derlenmiş normal ifadeler <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> türünde bir parametresi olan yapılandırıcının çağrılmasıyla yöntemi, <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-311">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>  
  
 <span data-ttu-id="a7ec7-312">Normal ifade yöntemi bir zaman aşımı aralığı belirlediyseniz ve bu aralığın sonunda bir eşleşme bulunamadı, oluşturur bir <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> özel durum.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-312">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="a7ec7-313">Özel durum işleyicinizde, eşlemeyi daha uzun bir zaman aralığı ile yeniden denemeyi, eşleme denemesinden vazgeçip bir eşleme olmadığını varsaymayı ya da eşleme denemesinden vazgeçip özel durum bilgisini gelecekteki analizler için kaydetmeyi seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-313">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>  
  
 <span data-ttu-id="a7ec7-314">Aşağıdaki örnekte tanımlayan bir `GetWordData` normal bir ifade ile bir zaman aşımı aralığı 350 milisaniye sayısını ve sözcük başına ortalama karakter sayısını bir metin belgesindeki sözcük hesaplamak için başlatan yöntem.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-314">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="a7ec7-315">Eşleme işlemi zaman aşımına uğrarsa, zaman aşımı aralığı 350 milisaniye artırılır ve <xref:System.Text.RegularExpressions.Regex> nesnesi yeniden oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-315">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="a7ec7-316">Yeni zaman aşımı aralığı 1 saniyeden uzunsa, yöntem yeniden çağırıcıya özel durum atar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-316">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]  
  
 [<span data-ttu-id="a7ec7-317">Başa dön</span><span class="sxs-lookup"><span data-stu-id="a7ec7-317">Back to top</span></span>](#top)  
  
<a name="Capture"></a>   
## <a name="capture-only-when-necessary"></a><span data-ttu-id="a7ec7-318">Yalnızca Gerekli Olduğunda Yakala</span><span class="sxs-lookup"><span data-stu-id="a7ec7-318">Capture Only When Necessary</span></span>  
 <span data-ttu-id="a7ec7-319">.NET içinde normal ifadeler bir normal ifade desenini bir veya daha fazla gruplamanıza olanak veren gruplama yapıları sayısını destekler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-319">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="a7ec7-320">.NET normal ifade dilindeki en sık kullanılan gruplama yapıları olan `(` *subexpression*`)`, numaralandırılmış bir tutma grubu tanımlayan ve `(?<` *adı* `>` *subexpression*`)`, adlandırılmış bir tutma grubu tanımlayan.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-320">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="a7ec7-321">Yapı birimlerini gruplamak geri başvuruları oluşturmak ve bir miktar niteleyicinin uygulandığı bir alt ifade tanımlamak için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-321">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>  
  
 <span data-ttu-id="a7ec7-322">Ancak bu dil öğelerinin kullanılmasının bir maliyeti vardır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-322">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="a7ec7-323">Bunlar neden <xref:System.Text.RegularExpressions.GroupCollection> tarafından döndürülen nesne <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> en son özelliğinin adlandırılmamış veya adlandırılmış ve tek bir gruplama kurgusu birden çok alt dizeleri giriş dizesinde yakalanan, bunlar da doldurmak<xref:System.Text.RegularExpressions.CaptureCollection>tarafından döndürülen nesne <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> özelliği birden çok belirli bir yakalama grubunun <xref:System.Text.RegularExpressions.Capture> nesneleri.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-323">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 <span data-ttu-id="a7ec7-324">Genelde oluşturma birimlerini gruplama, miktar belirleyicilerin yalnızca bunlara uygulanacağı şekilde bir normal ifadede kullanılır ve bu alt ifadeler tarafından yakalanan gruplar daha sonra kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-324">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="a7ec7-325">Örneğin, normal ifade `\b(\w+[;,]?\s?)+[.?!]` tamamını bir cümle yakalamak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-325">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="a7ec7-326">Aşağıdaki tabloda bu normal ifade deseni ve etkilerini dil öğelerini açıklar <xref:System.Text.RegularExpressions.Match> nesnenin <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> ve <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> koleksiyonları.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-326">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>  
  
|<span data-ttu-id="a7ec7-327">Desen</span><span class="sxs-lookup"><span data-stu-id="a7ec7-327">Pattern</span></span>|<span data-ttu-id="a7ec7-328">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a7ec7-328">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="a7ec7-329">Bir sözcük sınırında eşleşmeye başla.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-329">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="a7ec7-330">Bir veya daha fazla sözcük karakteri eşleştir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-330">Match one or more word characters.</span></span>|  
|`[;,]?`|<span data-ttu-id="a7ec7-331">Sıfır ya da bir virgül ya da noktalı virgülü eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-331">Match zero or one comma or semicolon.</span></span>|  
|`\s?`|<span data-ttu-id="a7ec7-332">Sıfır veya bir beyaz boşluk karakterini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-332">Match zero or one white-space character.</span></span>|  
|`(\w+[;,]?\s?)+`|<span data-ttu-id="a7ec7-333">Arkasından isteğe bağlı bir boşluk karakteri gelen isteğe bağlı bir virgül ya da noktalı virgül tarafından izlenen bir ya da daha fazla sözcük karakterinin bir ya da daha fazla oluşumunu eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-333">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="a7ec7-334">Bu, birkaç sözcük karakteri (yani sözcüğün) ve ardından isteğe bağlı bir noktalama işaretinin, normal ifade altyapısı cümlenin sonuna ulaşıncaya kadar tekrarlanması için gerekli olan ilk tutma grubunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-334">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|  
|`[.?!]`|<span data-ttu-id="a7ec7-335">Bir nokta, soru işareti ya da ünlem işareti eşleyin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-335">Match a period, question mark, or exclamation point.</span></span>|  
  
 <span data-ttu-id="a7ec7-336">Bir eşleşme bulunduğunda, her ikisi de aşağıdaki örnekte gösterildiği gibi <xref:System.Text.RegularExpressions.GroupCollection> ve <xref:System.Text.RegularExpressions.CaptureCollection> nesneleri gelen yakalamalarla doldurulur.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-336">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="a7ec7-337">Bu durumda, yakalama grubu `(\w+[;,]?\s?)` var. böylece `+` niceleyici uygulanabilir, her bir sözcüğün bir cümle eşleştirilecek normal ifade deseni sağlar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-337">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="a7ec7-338">Aksi halde bir cümledeki son sözcüğü eşleyebilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-338">Otherwise, it would match the last word in a sentence.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]  
  
 <span data-ttu-id="a7ec7-339">Alt ifadeleri yalnızca bunlara niceleyiciler uygulamak için kullanırken ve tutulan metinle ilgilenmediğinizde, grup tutmalarını devre dışı bırakmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-339">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="a7ec7-340">Örneğin, `(?:subexpression)` dil öğesi engeller geçerli olduğu grubun eşlenen alt dizeleri yakalamasını önler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-340">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="a7ec7-341">Aşağıdaki örnekte, önceki örnekteki normal ifade deseni olarak değiştirilir `\b(?:\w+[;,]?\s?)+[.?!]`.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-341">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="a7ec7-342">Çıktıda gösterildiği gibi normal ifade altyapısı doldurmasını önler <xref:System.Text.RegularExpressions.GroupCollection> ve <xref:System.Text.RegularExpressions.CaptureCollection> koleksiyonları.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-342">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
 [!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]  
  
 <span data-ttu-id="a7ec7-343">Tutmayı, şu yöntemlerden biriyle devre dışı bırakabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="a7ec7-343">You can disable captures in one of the following ways:</span></span>  
  
-   <span data-ttu-id="a7ec7-344">Kullanım `(?:subexpression)` dil öğesi.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-344">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="a7ec7-345">Bu öğe, geçerli olduğu gruptaki eşleşen alt dizelerin tutulmasını engeller.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-345">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="a7ec7-346">Herhangi bir yuvalanmış grupta alt dize yakalamalarını devre dışı bırakmaz.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-346">It does not disable substring captures in any nested groups.</span></span>  
  
-   <span data-ttu-id="a7ec7-347">Kullanım <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> seçeneği.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-347">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="a7ec7-348">Normal ifade deseninde tüm adlandırılmamış ya da örtük yakalamaları devre dışı bırakır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-348">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="a7ec7-349">Bu seçeneği kullandığınızda yalnızca tanımlı adlandırılmış gruplarla eşleşen alt dizeler `(?<name>subexpression)` dil öğesi tutulabilir.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-349">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="a7ec7-350"><xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> Bayrağı geçilebilir `options` parametresinin bir <xref:System.Text.RegularExpressions.Regex> sınıf oluşturucusu veya `options` parametresinin bir <xref:System.Text.RegularExpressions.Regex> statik eşleme yönteminin.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-350">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>  
  
-   <span data-ttu-id="a7ec7-351">Kullanım `n` seçeneğini `(?imnsx)` dil öğesi.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-351">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="a7ec7-352">Bu seçenek, tutulan tüm adlandırılmamış veya örtük öğeleri, öğenin normal ifade deseninde ortaya çıktığı noktadan başlayarak devre dışı bırakır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-352">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="a7ec7-353">Ya da kadar deseninin veya kadar yakalamaları devre dışı `(-n)` seçeneği adlandırılmamış veya örtük öğeleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-353">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="a7ec7-354">Daha fazla bilgi için [çeşitli yapıları](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="a7ec7-354">For more information, see [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="a7ec7-355">Kullanım `n` seçeneğini `(?imnsx:subexpression)` dil öğesi.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-355">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="a7ec7-356">Bu seçenek tüm adlandırılmamış veya örtük öğeleri devre dışı bırakır. `subexpression`.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-356">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="a7ec7-357">Yakalamalar adlandırılmamış ya da örtük yuvalı yakalama grupları tarafından devre dışı bırakılır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-357">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>  
  
 [<span data-ttu-id="a7ec7-358">Başa dön</span><span class="sxs-lookup"><span data-stu-id="a7ec7-358">Back to top</span></span>](#top)  
  
<a name="RelatedTopics"></a>   
## <a name="related-topics"></a><span data-ttu-id="a7ec7-359">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="a7ec7-359">Related Topics</span></span>  
  
|<span data-ttu-id="a7ec7-360">Başlık</span><span class="sxs-lookup"><span data-stu-id="a7ec7-360">Title</span></span>|<span data-ttu-id="a7ec7-361">Açıklama</span><span class="sxs-lookup"><span data-stu-id="a7ec7-361">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="a7ec7-362">Normal İfade Davranışının Ayrıntıları</span><span class="sxs-lookup"><span data-stu-id="a7ec7-362">Details of Regular Expression Behavior</span></span>](../../../docs/standard/base-types/details-of-regular-expression-behavior.md)|<span data-ttu-id="a7ec7-363">.NET normal ifade motorunun uygulanmasını inceler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-363">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="a7ec7-364">Konu normal ifadelerin esnekliği üzerine yoğunlaşmakta ve geliştiricinin normal ifade altyapısının verimli ve sorunsuz çalışmasını sağlamadaki sorumluluğunu açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-364">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|  
|[<span data-ttu-id="a7ec7-365">Geri Dönüş</span><span class="sxs-lookup"><span data-stu-id="a7ec7-365">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="a7ec7-366">Geri izlemenin ne olduğunu ve bunun normal ifade performansını nasıl etkilediği açıklar ve geri izlemeye alternatifler sağlayan dil öğelerini inceler.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-366">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|  
|[<span data-ttu-id="a7ec7-367">Normal İfade Dili - Hızlı Başvuru</span><span class="sxs-lookup"><span data-stu-id="a7ec7-367">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="a7ec7-368">.NET içinde normal ifade dilinin öğelerini açıklar ve her dil öğesi için ayrıntılı belgelere bağlantılar sağlar.</span><span class="sxs-lookup"><span data-stu-id="a7ec7-368">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|

---
title: PLINQ ve TPL için Özel Bölümleyiciler
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: d08be327d4c6bf6dd1add3c7ea40ed491619a9ca
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64625612"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="9777a-102">PLINQ ve TPL için Özel Bölümleyiciler</span><span class="sxs-lookup"><span data-stu-id="9777a-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="9777a-103">Bir işlem bir veri kaynağı üzerinde paralel hale getirmek için gerekli adımlar için biri *bölüm* birden çok iş parçacığı tarafından erişilebilen eşzamanlı olarak birden çok bölümlere kaynak.</span><span class="sxs-lookup"><span data-stu-id="9777a-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="9777a-104">PLINQ ve görev paralel kitaplığı (TPL), paralel sorgu yazdığınızda şeffaf bir şekilde çalışması varsayılan bölümleyicilerin sağlayın veya <xref:System.Threading.Tasks.Parallel.ForEach%2A> döngü.</span><span class="sxs-lookup"><span data-stu-id="9777a-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="9777a-105">Daha Gelişmiş senaryolar için kendi bölümleyici takabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9777a-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="9777a-106">Bölümleme türleri</span><span class="sxs-lookup"><span data-stu-id="9777a-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="9777a-107">Bir veri kaynağı bölümlemek için birçok yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="9777a-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="9777a-108">Kaynak birden fazla demetlerin fiziksel olarak ayrılması yerine işlem özgün kaynak dizisi en verimli yaklaşımları birden çok iş parçacığı işbirliği yapar.</span><span class="sxs-lookup"><span data-stu-id="9777a-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="9777a-109">Diziler ve diğer dizin kaynaklarını gibi <xref:System.Collections.IList> nerede uzunluğu bilinen önceden koleksiyonları *aralık bölümleme* bölümlemenin en basit türü.</span><span class="sxs-lookup"><span data-stu-id="9777a-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="9777a-110">Her iş parçacığı, benzersiz dizin, tarihleri arasında üzerine yazmaya veya diğer iş parçacığı tarafından üzerine yazılmasını olmadan kaynak çeşitli işleyebilmesi alır.</span><span class="sxs-lookup"><span data-stu-id="9777a-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="9777a-111">Yalnızca ek yükü de aralık bölümleme ilgili aralıkları oluşturmanın ilk çalışmadır; Ek eşitleme, daha sonra gereklidir.</span><span class="sxs-lookup"><span data-stu-id="9777a-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="9777a-112">Bu nedenle, iş yükü şekilde eşit bölünür sürece iyi bir performans sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="9777a-113">Aralık bölümleme bir dezavantajı, bir iş parçacığı erken tamamlanırsa işlerini son diğer iş parçacıklarını yardımcı olamaz, ' dir.</span><span class="sxs-lookup"><span data-stu-id="9777a-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="9777a-114">Bağlantılı liste veya uzunluğunu tanınmıyor diğer derlemeler için kullanabileceğiniz *öbek bölümleme*.</span><span class="sxs-lookup"><span data-stu-id="9777a-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="9777a-115">Öbek bölümleme, her iş parçacığı veya bir paralel döngüde veya bir sorgu görevde bazı bir öbek kaynak öğe sayısı tüketir, işler ve ek öğeleri almak için geri gelir.</span><span class="sxs-lookup"><span data-stu-id="9777a-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="9777a-116">Tüm öğeleri dağıtılır ve hiçbir Tekrarların bölümleyici sağlar.</span><span class="sxs-lookup"><span data-stu-id="9777a-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="9777a-117">Bir öbek herhangi bir boyutta olabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-117">A chunk may be any size.</span></span> <span data-ttu-id="9777a-118">Örneğin, örnekte gösterildiği bölümleyici [nasıl yapılır: Dinamik bölümleri uygulama](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) yalnızca bir öğe içermelidir öbekleri oluşturur.</span><span class="sxs-lookup"><span data-stu-id="9777a-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="9777a-119">Parçalar çok büyük olmayan sürece, iş parçacıkları öğelerin atama önceden belirlenemedi bölümleme bu tür Yük Dengeleme kendiliğinden olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="9777a-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="9777a-120">Ancak, bölümleyici eşitleme yükünü artırmak ve bu da iş parçacığı başka bir öbek almak için her durumda.</span><span class="sxs-lookup"><span data-stu-id="9777a-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="9777a-121">Bu gibi durumlarda tahakkuk eşitleme miktarını öbek boyutunu inversely orantılıdır.</span><span class="sxs-lookup"><span data-stu-id="9777a-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="9777a-122">Genel olarak, aralık bölümleme yalnızca temsilci yürütme süresini Orta için küçük olduğunda ve öğeleri çok sayıda kaynak vardır ve her bölüm toplam iş kabaca eşdeğerdir daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="9777a-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="9777a-123">Öbek bölümleme bu nedenle çoğu durumda genellikle daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="9777a-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="9777a-124">Az sayıda öğeleri veya temsilci için artık yürütme süresi ile kaynaklarında performansını öbek ve aralık bölümleme hakkında eşit ise.</span><span class="sxs-lookup"><span data-stu-id="9777a-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="9777a-125">TPL bölümleyiciler dinamik bir bölüm sayısı da destekler.</span><span class="sxs-lookup"><span data-stu-id="9777a-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="9777a-126">Bunlar oluşturabilirsiniz bölümleri üzerinde anında, örneğin başka bir deyişle, <xref:System.Threading.Tasks.Parallel.ForEach%2A> döngü yeni bir görev olarak çoğaltılır.</span><span class="sxs-lookup"><span data-stu-id="9777a-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="9777a-127">Bu özellik, döngü ile birlikte ölçeklendirmek bir bölümleyici sağlar.</span><span class="sxs-lookup"><span data-stu-id="9777a-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="9777a-128">Dinamik bölümleyiciler kendiliğinden Yük Dengeleme de olur.</span><span class="sxs-lookup"><span data-stu-id="9777a-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="9777a-129">Özel bir bölümleyici oluşturduğunuzda, gelen kullanılabilir olması için dinamik bölümlemeyi desteklemelidir bir <xref:System.Threading.Tasks.Parallel.ForEach%2A> döngü.</span><span class="sxs-lookup"><span data-stu-id="9777a-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="9777a-130">PLINQ için Bölümleyiciler yük dengelemeyi yapılandırma</span><span class="sxs-lookup"><span data-stu-id="9777a-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="9777a-131">Bazı aşırı yüklemeleri <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> yöntemi bir dizi için bir bölümleyici oluşturmanıza izin veren veya <xref:System.Collections.IList> kaynak ve iş parçacıkları arasında iş yükünü dengelemek denemelidir olup olmadığını belirtin.</span><span class="sxs-lookup"><span data-stu-id="9777a-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="9777a-132">Bölümleyici yük dengelemek için yapılandırıldığında, öbek bölümleme kullanılır ve bunların istendiği gibi öğeleri kapalı küçük öbekler halinde her bölüm için verilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="9777a-133">Bu yaklaşım, tüm bölümleri kadar tüm döngü işlemek için öğeleri veya sorgu tamamlanmış olduğundan emin olun yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="9777a-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="9777a-134">Ek bir aşırı bölümleme herhangi bir Yük Dengeleme sağlamak için kullanılan <xref:System.Collections.IEnumerable> kaynak.</span><span class="sxs-lookup"><span data-stu-id="9777a-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="9777a-135">Genel olarak, Yük Dengeleme öğeleri oldukça sık bölümleyici istek için bölümleri gerektirir.</span><span class="sxs-lookup"><span data-stu-id="9777a-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="9777a-136">Aksine, statik bölümleme gerçekleştiren bir bölümleyici öğeler için her bir bölümleyici tümünü tek seferde aralığı veya öbek bölümleme kullanarak atayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9777a-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="9777a-137">Bu, Yük Dengeleme çok daha az ek yük gerektirir, ancak diğerlerinden çok daha fazla iş bir iş parçacığı sonlanır, yürütmek için uzun sürebilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="9777a-138">IList ya da bir dizi geçirildiğinde varsayılan olarak PLINQ her zaman aralığı, Yük Dengeleme olmadan bölümleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="9777a-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="9777a-139">PLINQ için yük dengelemeyi etkinleştirmek için `Partitioner.Create` yöntemi, aşağıdaki örnekte gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="9777a-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="9777a-140">Yükleme kullanmak için belirli bir senaryoda Dengeleme denemeler yapın ve temsili yükler ve bilgisayar yapılandırmalarını altında tamamlamak için işlemleri ne kadar sürdüğünü ölçmek için olup olmadığını belirlemek için en iyi yolu.</span><span class="sxs-lookup"><span data-stu-id="9777a-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="9777a-141">Örneğin, statik bölümleme yalnızca birkaç çekirdeği olan bir çok çekirdekli bilgisayarda önemli hızlandırmayı sağlayabilir, ancak oldukça fazla çekirdeğe sahip bilgisayarlarda yavaşlamalara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="9777a-142">Aşağıdaki tabloda kullanılabilir aşırı listeler <xref:System.Collections.Concurrent.Partitioner.Create%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9777a-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="9777a-143">Bu bölümleyiciler yalnızca PLINQ ile kullanmak için sınırlı değildir veya <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="9777a-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="9777a-144">Tüm özel paralel yapısı ile de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="9777a-145">aşırı yükleme</span><span class="sxs-lookup"><span data-stu-id="9777a-145">Overload</span></span>|<span data-ttu-id="9777a-146">Kullanan Yük Dengeleme</span><span class="sxs-lookup"><span data-stu-id="9777a-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="9777a-147">Her zaman</span><span class="sxs-lookup"><span data-stu-id="9777a-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="9777a-148">Boole bağımsız değişkeni true belirtildiğinde</span><span class="sxs-lookup"><span data-stu-id="9777a-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="9777a-149">Boole bağımsız değişkeni true belirtildiğinde</span><span class="sxs-lookup"><span data-stu-id="9777a-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="9777a-150">hiçbir zaman</span><span class="sxs-lookup"><span data-stu-id="9777a-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="9777a-151">hiçbir zaman</span><span class="sxs-lookup"><span data-stu-id="9777a-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="9777a-152">hiçbir zaman</span><span class="sxs-lookup"><span data-stu-id="9777a-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="9777a-153">hiçbir zaman</span><span class="sxs-lookup"><span data-stu-id="9777a-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="9777a-154">Statik aralığı Bölümleyiciler Parallel.ForEach için yapılandırma</span><span class="sxs-lookup"><span data-stu-id="9777a-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="9777a-155">İçinde bir <xref:System.Threading.Tasks.Parallel.For%2A> döngü, döngü gövdesinin yöntemi temsilci olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="9777a-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="9777a-156">Bu temsilci çağırma maliyeti, bir sanal yöntem çağrısının aynı hakkındadır.</span><span class="sxs-lookup"><span data-stu-id="9777a-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="9777a-157">Bazı senaryolarda, paralel bir döngüden gövdesinin her döngü yinelemesinin üzerinde temsilci çağrısı maliyetini önemli hale kadar küçük olabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="9777a-158">Bu gibi durumlarda, aşağıdakilerden birini kullanabilirsiniz <xref:System.Collections.Concurrent.Partitioner.Create%2A> oluşturmak için aşırı yüklemeler bir <xref:System.Collections.Generic.IEnumerable%601> aralığı bölümlerin kaynak öğeleri üzerinde.</span><span class="sxs-lookup"><span data-stu-id="9777a-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="9777a-159">Ardından, bu aralıklar koleksiyonunu geçirebilirsiniz bir <xref:System.Threading.Tasks.Parallel.ForEach%2A> gövde oluşur normal yöntemi `for` döngü.</span><span class="sxs-lookup"><span data-stu-id="9777a-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="9777a-160">Bu yaklaşımın avantajı, temsilci çağırma yalnızca bir kez aralık başına yerine bir kez öğe başına ücret uygulanır emin olur.</span><span class="sxs-lookup"><span data-stu-id="9777a-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="9777a-161">Aşağıdaki örnek, temel düzeni gösterir.</span><span class="sxs-lookup"><span data-stu-id="9777a-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="9777a-162">Her iş parçacığı döngüsünde kendi alır <xref:System.Tuple%602> başlangıç ve bitiş belirtilen alt aralığındaki dizini değerleri içeriyor.</span><span class="sxs-lookup"><span data-stu-id="9777a-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="9777a-163">İç `for` döngü kullandığı `fromInclusive` ve `toExclusive` değerleri dizisi üzerinde döngü veya <xref:System.Collections.IList> doğrudan.</span><span class="sxs-lookup"><span data-stu-id="9777a-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="9777a-164">Aşağıdakilerden birini <xref:System.Collections.Concurrent.Partitioner.Create%2A> aşırı bölümler bölüm sayısı ve boyutu belirtmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="9777a-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="9777a-165">Bu aşırı yüklemesi, iş öğesi başına öğe başına tek bir sanal yöntem çağrısının performansı belirgin bir etkiye sahip kadar düşük olduğu senaryolarda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="9777a-166">Özel Bölümleyiciler</span><span class="sxs-lookup"><span data-stu-id="9777a-166">Custom Partitioners</span></span>  
 <span data-ttu-id="9777a-167">Bazı senaryolarda, faydalı veya hatta kendi bölümleyici uygulama için gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="9777a-168">Örneğin, bölümleyiciler bilginiz sınıfı iç yapısını tabanlı varsayılandan daha verimli bir şekilde bölüm bir özel koleksiyon sınıfı olabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="9777a-169">Veya bilginiz ne kadar kaynak koleksiyondaki farklı konumlardaki işlem öğelerine sürer, bağlı olan çeşitli boyutlardaki aralığı bölümleri oluşturmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9777a-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="9777a-170">Temel, özel bir bölümleyici oluşturma için öğesinden bir sınıf türetin <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> ve sanal yöntemler aşağıdaki tabloda açıklandığı şekilde geçersiz kılın.</span><span class="sxs-lookup"><span data-stu-id="9777a-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="9777a-171">Bu yöntem, ana iş parçacığı tarafından bir kez çağrılır ve bir IList(IEnumerator(TSource)) döndürür.</span><span class="sxs-lookup"><span data-stu-id="9777a-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="9777a-172">Her döngü veya sorgu iş parçacığı çağırabilirsiniz `GetEnumerator` almak için listede bir <xref:System.Collections.Generic.IEnumerator%601> farklı bir bölüme üzerinden.</span><span class="sxs-lookup"><span data-stu-id="9777a-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="9777a-173">Dönüş `true` uygularsanız <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, aksi takdirde, `false`.</span><span class="sxs-lookup"><span data-stu-id="9777a-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="9777a-174">Varsa <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> olduğu `true`, bu yöntem yerine isteğe bağlı olarak çağrılabilir <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="9777a-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="9777a-175">Ardından türetilmesi sonuçları sıralanabilir ya da bu öğeleri eklemek için dizini oluşturulmuş erişmesi <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> ve aşağıdaki tabloda açıklandığı gibi kendi sanal yöntemleri geçersiz kılın.</span><span class="sxs-lookup"><span data-stu-id="9777a-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="9777a-176">Bu yöntem, ana iş parçacığı tarafından bir kez çağrılır ve döndüren bir `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="9777a-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="9777a-177">Her döngü veya sorgu iş parçacığı çağırabilirsiniz `GetEnumerator` almak için listede bir <xref:System.Collections.Generic.IEnumerator%601> farklı bir bölüme üzerinden.</span><span class="sxs-lookup"><span data-stu-id="9777a-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="9777a-178">Dönüş `true` uygularsanız <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; Aksi takdirde false.</span><span class="sxs-lookup"><span data-stu-id="9777a-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="9777a-179">Genellikle, bu yalnızca çağıran <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="9777a-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="9777a-180">Varsa <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> olduğu `true`, bu yöntem yerine isteğe bağlı olarak çağrılabilir <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="9777a-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="9777a-181">Aşağıdaki tabloda hakkında ek ayrıntılar sağlar üç farklı Yük Dengeleme bölümleyiciler uygulama <xref:System.Collections.Concurrent.OrderablePartitioner%601> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="9777a-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="9777a-182">Metot/özellik</span><span class="sxs-lookup"><span data-stu-id="9777a-182">Method/Property</span></span>|<span data-ttu-id="9777a-183">IList / Array yük dengelemesi olmadan</span><span class="sxs-lookup"><span data-stu-id="9777a-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="9777a-184">IList / Array ile Yük Dengeleme</span><span class="sxs-lookup"><span data-stu-id="9777a-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="9777a-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="9777a-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="9777a-186">Aralık bölümleme kullanır</span><span class="sxs-lookup"><span data-stu-id="9777a-186">Uses range partitioning</span></span>|<span data-ttu-id="9777a-187">Kullanımları listeler için belirtilen bölüm sayısı için en iyi duruma getirilmiş öbek bölümleme</span><span class="sxs-lookup"><span data-stu-id="9777a-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="9777a-188">Kullanır, öbek statik bir bölüm sayısı oluşturarak bölümleme.</span><span class="sxs-lookup"><span data-stu-id="9777a-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="9777a-189">Desteklenmeyen oluşturur özel durumu</span><span class="sxs-lookup"><span data-stu-id="9777a-189">Throws not-supported exception</span></span>|<span data-ttu-id="9777a-190">Kullanımları listeler için en iyi duruma getirilmiş öbek bölümleme ve dinamik bölümleri</span><span class="sxs-lookup"><span data-stu-id="9777a-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="9777a-191">Kullanır, öbek dinamik bir bölüm sayısı oluşturarak bölümleme.</span><span class="sxs-lookup"><span data-stu-id="9777a-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="9777a-192">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-192">Returns `true`</span></span>|<span data-ttu-id="9777a-193">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-193">Returns `true`</span></span>|<span data-ttu-id="9777a-194">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="9777a-195">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-195">Returns `true`</span></span>|<span data-ttu-id="9777a-196">döndürür `false`</span><span class="sxs-lookup"><span data-stu-id="9777a-196">Returns `false`</span></span>|<span data-ttu-id="9777a-197">döndürür `false`</span><span class="sxs-lookup"><span data-stu-id="9777a-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="9777a-198">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-198">Returns `true`</span></span>|<span data-ttu-id="9777a-199">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-199">Returns `true`</span></span>|<span data-ttu-id="9777a-200">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="9777a-201">döndürür `false`</span><span class="sxs-lookup"><span data-stu-id="9777a-201">Returns `false`</span></span>|<span data-ttu-id="9777a-202">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-202">Returns `true`</span></span>|<span data-ttu-id="9777a-203">döndürür `true`</span><span class="sxs-lookup"><span data-stu-id="9777a-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="9777a-204">Dinamik bölümleri</span><span class="sxs-lookup"><span data-stu-id="9777a-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="9777a-205">Kullanılacak bölümleyici düşünüyorsanız bir <xref:System.Threading.Tasks.Parallel.ForEach%2A> yöntemi, sağlayabilmelidir bölümler dinamik bir sayısını döndürür.</span><span class="sxs-lookup"><span data-stu-id="9777a-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="9777a-206">Başka bir deyişle döngü yürütme sırasında herhangi bir zamanda bölümleyici bir yeni bölümü isteğe bağlı bir numaralandırıcı sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9777a-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="9777a-207">Temel olarak, yeni paralel görev döngüyü ekler her görev için yeni bir bölüm ister.</span><span class="sxs-lookup"><span data-stu-id="9777a-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="9777a-208">Veriler orderable gerekiyorsa, ardından öğesinden türetilen <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> böylece her bölümdeki her öğe benzersiz bir dizin atanır.</span><span class="sxs-lookup"><span data-stu-id="9777a-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="9777a-209">Daha fazla bilgi ve örnek için bkz [nasıl yapılır: Dinamik bölümleri uygulama](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="9777a-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="9777a-210">Sözleşme Bölümleyiciler</span><span class="sxs-lookup"><span data-stu-id="9777a-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="9777a-211">Özel bir bölümleyici uygulama PLINQ doğru etkileşimi sağlamak için aşağıdaki yönergeleri izleyin ve <xref:System.Threading.Tasks.Parallel.ForEach%2A> tpl'de:</span><span class="sxs-lookup"><span data-stu-id="9777a-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
- <span data-ttu-id="9777a-212">Varsa <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> adlı bağımsız değişkeni sıfır veya daha az `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="9777a-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="9777a-213">PLINQ ve TPL hiçbir zaman içinde geçer ancak bir `partitionCount` 0 eşittir, ancak yine de olasılığını karşı koruma sağlamak öneririz.</span><span class="sxs-lookup"><span data-stu-id="9777a-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
- <span data-ttu-id="9777a-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> ve <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> her zaman döndürmelidir `partitionsCount` bölüm sayısı.</span><span class="sxs-lookup"><span data-stu-id="9777a-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="9777a-215">Bölümleyici verileri çalıştırır ve istenen sayıda bölüm oluşturulamıyor, yöntem her kalan bir bölüm için boş bir numaralandırıcı döndürmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="9777a-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="9777a-216">Aksi takdirde, PLINQ ve TPL hem oluşturmaz bir <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="9777a-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="9777a-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, ve <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> hiçbir zaman döndürmelidir `null` (`Nothing` Visual Basic'te).</span><span class="sxs-lookup"><span data-stu-id="9777a-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="9777a-218">Eğer öyleyse, PLINQ / TPL oluşturur bir <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="9777a-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
- <span data-ttu-id="9777a-219">Bölümler döndüren yöntemler, her zaman tam olarak ve benzersiz bir şekilde veri kaynağı numaralandırabilirsiniz bölümler döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="9777a-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="9777a-220">Özel bölümleyici tasarımını tarafından gerekli kılınmadıkça hiçbir çoğaltma veri kaynağı veya atlanan öğeleri olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="9777a-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="9777a-221">Bu kural uyulmazsa, çıkış sırası karıştırılmış.</span><span class="sxs-lookup"><span data-stu-id="9777a-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
- <span data-ttu-id="9777a-222">Böylece çıkış sırasını değil karıştırılmış aşağıdaki Boole alıcıları her zaman doğru bir şekilde aşağıdaki değerleri döndürmesi gerekir:</span><span class="sxs-lookup"><span data-stu-id="9777a-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    - <span data-ttu-id="9777a-223">`KeysOrderedInEachPartition`: Her bölüm anahtar dizinlerini artan öğeleri döndürür.</span><span class="sxs-lookup"><span data-stu-id="9777a-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    - <span data-ttu-id="9777a-224">`KeysOrderedAcrossPartitions`: Bölüm anahtar çiftlerine getirilen tüm bölümler için *miyim* bölüm anahtar çiftlerine yüksektir *miyim*-1.</span><span class="sxs-lookup"><span data-stu-id="9777a-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    - <span data-ttu-id="9777a-225">`KeysNormalized`: Tüm anahtar dizinlerini tekdüze sıfırdan başlayarak, boşluk olmadan artmaktadır.</span><span class="sxs-lookup"><span data-stu-id="9777a-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
- <span data-ttu-id="9777a-226">Tüm dizinler benzersiz olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="9777a-226">All indices must be unique.</span></span> <span data-ttu-id="9777a-227">Yinelenen dizinleri olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="9777a-227">There may not be duplicate indices.</span></span> <span data-ttu-id="9777a-228">Bu kural uyulmazsa, çıkış sırası karıştırılmış.</span><span class="sxs-lookup"><span data-stu-id="9777a-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
- <span data-ttu-id="9777a-229">Tüm dizinler negatif olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="9777a-229">All indices must be nonnegative.</span></span> <span data-ttu-id="9777a-230">Bu kural uyulmazsa, PLINQ/TPL özel durumlar.</span><span class="sxs-lookup"><span data-stu-id="9777a-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9777a-231">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="9777a-231">See also</span></span>

- [<span data-ttu-id="9777a-232">Paralel Programlama</span><span class="sxs-lookup"><span data-stu-id="9777a-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="9777a-233">Nasıl yapılır: Dinamik bölümleri uygulama</span><span class="sxs-lookup"><span data-stu-id="9777a-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="9777a-234">Nasıl yapılır: Statik bölümleme için bir Bölümleyici uygulama</span><span class="sxs-lookup"><span data-stu-id="9777a-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)

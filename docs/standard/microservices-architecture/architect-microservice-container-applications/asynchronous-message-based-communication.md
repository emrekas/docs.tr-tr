---
title: Zaman uyumsuz ileti tabanlı iletişim
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmet mimarisi | Mikro hizmetler birbirlerinden beeing eşzamanlı sırasında da sonuçta bağımsız tutmak için en iyi yolu, çünkü zaman uyumsuz ileti tabanlı iletişim mikro hizmetler mimarisinde önemli bir kavramdır.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/20/2018
ms.openlocfilehash: 10e2a05e8fa33ecbf2aec2432c0cf51204fc35c1
ms.sourcegitcommit: 40364ded04fa6cdcb2b6beca7f68412e2e12f633
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/28/2019
ms.locfileid: "56969368"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="bf0ae-103">Zaman uyumsuz ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="bf0ae-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="bf0ae-104">Zaman uyumsuz Mesajlaşma ve olay odaklı iletişimi değişiklikleri birden çok mikro hizmetler ve bunların ilgili etki alanı modelleri arasında yayma, kritik öneme sahiptir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="bf0ae-105">Tartışma mikro hizmetler ve sınırlanmış Bağlamlar (İBH) daha önce belirtildiği gibi modelleri (kullanıcı, müşteri, ürün, hesap, vb.) farklı bir mikro hizmetler veya BCs farklı öğelere anlamına gelebilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="bf0ae-106">Bu, değişiklikler olduğunda, farklı modelleri arasında değişiklikleri mutabık kılınacak şekilde gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="bf0ae-107">Bir son tutarlılık ve zaman uyumsuz Mesajlaşma temel olay temelli iletişim çözümüdür.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="bf0ae-108">Mesajlaşma kullanırken, işlemleri mesaj alışverişleri tarafından zaman uyumsuz olarak iletişim kurar.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="bf0ae-109">Bir istemci bir komutu veya bir istek için bir hizmet bir ileti göndererek yapar.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="bf0ae-110">Hizmet yanıt vermesi durumunda farklı bir ileti istemciye geri gönderir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="bf0ae-111">Bir ileti tabanlı iletişim olduğundan, istemci yanıtı hemen alınan olmaz ve olabileceğini yanıt hiç varsayar.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="bf0ae-112">Bir ileti üst bilgisi (kimlik veya güvenlik bilgileri gibi meta veriler) ile bir gövde oluşur.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="bf0ae-113">İletileri, genellikle AMQP gibi zaman uyumsuz protokolleri üzerinden gönderilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="bf0ae-114">Bu tür bir mikro hizmetler topluluğundaki iletişimi için tercih edilen altyapı büyük aracıları ve SOA içinde kullanılan düzenleyicileri farklı basit ileti aracısıdır.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="bf0ae-115">Bir basit ileti Aracısı "yalnızca RabbitMQ veya Azure Service Bus gibi bulut ortamındaki bir ölçeklenebilir service bus gibi basit uygulamaları ile bir ileti aracısı olarak işlev gören genellikle dumb," altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="bf0ae-116">Bu senaryoda, çoğu "Akıllı" düşünce hala oluşturan ve iletileri kullanmaya uç noktaların yaşadığı-diğer bir deyişle, mikro hizmetler.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="bf0ae-117">İç hizmetleri arasında yalnızca zaman uyumsuz mesajlaşmayı kullanın ve zaman uyumlu iletişimini (HTTP gibi) istemci uygulamalardan yalnızca ön uç hizmetlerine (API ağ geçitleri ayrıca ilk düzeyi kullanmak için başka bir kural uygulayın, mümkün olduğunca denemelisiniz sağlamaktır mikro).</span><span class="sxs-lookup"><span data-stu-id="bf0ae-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="bf0ae-118">Zaman uyumsuz Mesajlaşma iletişim iki tür vardır: tek bir alıcı ileti tabanlı iletişim ve birden çok alıcıya ileti tabanlı iletişim.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="bf0ae-119">Aşağıdaki bölümler, bunlarla ilgili ayrıntıları sağlar.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="bf0ae-120">Tek bir alıcı ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="bf0ae-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="bf0ae-121">İleti tabanlı zaman uyumsuz iletişim ile tek bir alıcı, tam olarak bir kanaldan okuma ve ileti yalnızca bir kez işlenir tüketici için bir iletiyi teslim noktadan noktaya iletişim anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="bf0ae-122">Ancak, özel durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-122">However, there are special situations.</span></span> <span data-ttu-id="bf0ae-123">Örneğin, otomatik olarak hatalardan kurtarmak için çalışan bir bulut sisteminde aynı iletiyi birden çok kez gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="bf0ae-124">Ağ veya diğer hatalar nedeniyle istemci iletileri gönderme yeniden deneme yapabilmek varsa ve sunucunun belirli bir iletiyi yalnızca bir kez işlemek için bir kere etkili olacak şekilde bir işlemi uygulamak.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="bf0ae-125">Tek bir alıcı ileti tabanlı iletişim, özellikle de Şekil 4-Bu yaklaşım gösteren 18'de gösterildiği gibi başka bir zaman uyumsuz komutları bir mikro hizmet göndermek için uygundur.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="bf0ae-126">İleti tabanlı iletişim (ya da komutları veya olayları) gönderme başlattıktan sonra ileti tabanlı iletişim zaman uyumlu HTTP iletişimi ile karıştırma kaçınmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![Tek bir mikro hizmet zaman uyumsuz ileti alma](./media/image18.png)

<span data-ttu-id="bf0ae-128">**Şekil 4-18**.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-128">**Figure 4-18**.</span></span> <span data-ttu-id="bf0ae-129">Tek bir mikro hizmet zaman uyumsuz ileti alma</span><span class="sxs-lookup"><span data-stu-id="bf0ae-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="bf0ae-130">Komutlar istemci uygulamalarından geldiğinizde, bunlar HTTP zaman uyumlu komutları uygulanabilir olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="bf0ae-131">Daha yüksek ölçeklenebilirlik gerektiğinde veya zaten bir ileti tabanlı iş süreci içinde işiniz ileti tabanlı komutları kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-131">You should use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="bf0ae-132">Birden çok alıcıya ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="bf0ae-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="bf0ae-133">Daha esnek bir yaklaşım da iletişiminizin gönderenden ek abone mikro hizmetler veya dış uygulamalar için kullanılabilir olması bir yayımlama/abonelik mekanizması kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="bf0ae-134">Bu nedenle, izlemek için yardımcı [açık/kapalı ilkesine](https://en.wikipedia.org/wiki/Open/closed_principle) gönderen hizmetinde.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="bf0ae-135">Bu şekilde, gönderen hizmeti değiştirmek zorunda kalmadan gelecekte ek aboneleri eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="bf0ae-136">Bir yayımlama/abone olma iletişimi kullandığınızda, yayımlama olaylarına hiçbir abone için bir olay veri yolu arabirimi kullanıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="bf0ae-137">Olay tabanlı zaman uyumsuz iletişim</span><span class="sxs-lookup"><span data-stu-id="bf0ae-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="bf0ae-138">Zaman uyumsuz olay temelli iletişim kullanırken, bir mikro hizmet kendi etki alanı içinde bir şey ve başka bir mikro hizmet ve ürün kataloğu olan bir mikro hizmet, fiyat değişikliği gibi unutmayın gerektiğinde bir tümleştirme olayı yayımlar.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="bf0ae-139">Bunları bir zaman uyumsuz olarak alabilmesi için ek bir mikro hizmetler olaylara abone olun.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="bf0ae-140">Alıcılar, bu durum oluştuğunda daha fazla tümleştirme olayları yayımlanacak neden olabilir, kendi etki alanı varlıklarının güncelleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="bf0ae-141">Bu yayımlama/abone olma sistem, genellikle bir olay veri yolu uygulaması kullanılarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="bf0ae-142">Olay veri yolu, bir Özet ya da arabirimle abone olmak veya abonelikten olayları ve olayları yayımlamak için gerekli olan API olarak tasarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="bf0ae-143">Daha fazla uygulamaları tüm işlemler arası ve mesajlaşma Aracısı, bir ileti kuyruğu veya zaman uyumsuz iletişim ve bir yayımlama/abone olma modelini destekleyen bir service bus gibi temel veya olay veri yolu biri de olabilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="bf0ae-144">Bir sistem tümleştirme olayları tarafından yönetilen son tutarlılık kullanıyorsa, bu yaklaşım son kullanıcıya tamamen açık yapıldığını önerilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made completely clear to the end user.</span></span> <span data-ttu-id="bf0ae-145">Sistem SignalR veya istemci yoklama sistemlerden gibi tümleştirme olayları taklit eden bir yaklaşım kullanmamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="bf0ae-146">Son kullanıcı ve işletme sahibi açıkça sistemde nihai tutarlılık yaklaşımını benimseyin ve açık olduğu sürece, çoğu durumda bu yaklaşımla, herhangi bir sorun iş sahip olmadığını fark gerekir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="bf0ae-147">Bu, kullanıcıların bazı sonuçlarını hemen görmek beklenebilir ve bu uygulamanın son tutarlılık durum değil çünkü önemlidir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-147">This is important because users might expect to see some results immediately and this might not happen with eventual consistency.</span></span>

<span data-ttu-id="bf0ae-148">Daha önce belirtildiği gibi [Dağıtılmış veri yönetimi için sorunlar ve çözümler](distributed-data-management.md) bölümünde birden çok mikro hizmetler span iş görevlerini uygulamak için tümleştirme olayları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="bf0ae-149">Bu nedenle, bu hizmetler arasında nihai tutarlılığa sahip olacaksınız.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="bf0ae-150">Sonunda tutarlı bir işlem, dağıtılmış işlemlerin bir koleksiyonu yapılır.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="bf0ae-151">Her eylem ilgili mikro hizmet etki alanı varlığı güncelleştirir ve sonraki eylem içinde aynı uçtan uca iş görevi başlatan başka bir tümleştirme olay yayımlar.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="bf0ae-152">Önemli bir aynı olaya abone birden fazla mikro hizmetin iletişim kurmak isteyebilirsiniz noktadır.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="bf0ae-153">Yayımlama/abone olma kullanabilirsiniz. Bunu yapmak için Mesajlaşma iletişimi olay odaklı, Şekil 4-19'gösterildiği gibi temel.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="bf0ae-154">Bu yayımlama/abonelik mekanizması mikro hizmet mimarisi için özel değildir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="bf0ae-155">Benzer şekilde [sınırlanmış Bağlamlar](https://martinfowler.com/bliki/BoundedContext.html) içinde DDD iletişim veya şekilde veritabanına okuma yazma veritabanından güncelleştirmeleri yaymak [komut ve sorgu sorumluluğu ayrımı (CQRS)](https://martinfowler.com/bliki/CQRS.html)mimari deseni.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="bf0ae-156">Nihai tutarlılık, dağıtılmış sisteme birden çok veri kaynağında sanal makineye sahip olmaktır.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![Zaman uyumsuz olay temelli iletişiminde bir mikro hizmet olayları bir olay veri yoluna yayımlar ve birçok mikro hizmetler, bildirim alın ve işlem yapma abone üzerindeki.](./media/image19.png)

<span data-ttu-id="bf0ae-158">**Şekil 4-19**.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-158">**Figure 4-19**.</span></span> <span data-ttu-id="bf0ae-159">Zaman uyumsuz olay temelli ileti iletişimi</span><span class="sxs-lookup"><span data-stu-id="bf0ae-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="bf0ae-160">Uygulamanız hangi olay odaklı, ileti tabanlı iletişim için kullanılacak protokolü belirler.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-160">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="bf0ae-161">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) güvenilir kuyruğa alınan iletişim elde etmeye yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-161">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="bf0ae-162">Bir olay veri yolu kullandığınızda, sınıflarda ilgili bir uygulama gibi bir ileti Aracısı API'den kullanarak kod ile temel bir özet düzeyi (örneğin, bir olay veri yolu arabirimi) kullanmak isteyebilirsiniz [RabbitMQ](https://www.rabbitmq.com/) veya gibibirservicebus[Azure Service Bus konuları ile](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="bf0ae-162">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="bf0ae-163">Alternatif olarak, olay veri yolu ortaya çıkaran ve yayımlama/abonelik sistem NServiceBus, MassTransit veya Brighter gibi daha üst düzey bir hizmet veri yolu kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-163">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="bf0ae-164">Üretim sistemlerine yönelik teknolojileri Mesajlaşma hakkında bir Not</span><span class="sxs-lookup"><span data-stu-id="bf0ae-164">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="bf0ae-165">Mesajlaşma, soyut olay veri yolu uygulamak için kullanılabilen farklı düzeylerde teknolojilerdir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-165">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="bf0ae-166">Örneğin, diğer ürünler gibi NServiceBus, MassTransit ya da RabbitMQ ve Azure Service Bus üzerinde çalışabilirsiniz Brighter, daha düşük bir düzeyde RabbitMQ (bir Mesajlaşma Aracısı taşıma) ve Azure Service Bus gibi ürünleri durur.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-166">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="bf0ae-167">Seçtiğiniz uygulama düzeyinde ve kullanıma hazır ölçeklenebilirlik, uygulamanız için gereken kaç Zengin özellikleri bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-167">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="bf0ae-168">Hizmetine örnek yapıldığı gibi hemen bir kavram kanıtı olay veri yolu için geliştirme ortamınızı uygulamak için basit bir uygulama üzerinde bir Docker kapsayıcısı üzerinde çalışırken RabbitMQ yeterli olabilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-168">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="bf0ae-169">Ancak, görev açısından kritik ve ölçeklenebilirlik hyper gereken üretim sistemlerine Azure Service Bus değerlendirmek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-169">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="bf0ae-170">Yüksek düzeyde soyutlama ve dağıtılmış uygulamaların geliştirilmesini kolaylaştıran özellikler için NServiceBus MassTransit ve Brighter gibi diğer ticari ve açık kaynak hizmeti yollarına değerlendirmek öneririz.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-170">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="bf0ae-171">Elbette, kendi hizmet veri yolu özellikleri RabbitMQ ve Docker gibi alt düzey teknolojileri üzerine oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-171">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="bf0ae-172">Ancak bu tesisat iş özel Kurumsal uygulama için çok fazla maliyeti.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-172">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="bf0ae-173">Dayanıklı olay yoluna yayımlama</span><span class="sxs-lookup"><span data-stu-id="bf0ae-173">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="bf0ae-174">Atomik olarak özgün mikro hizmet durumunda dayanıklı kendi ilgili tümleştirme olay şekilde göre olay veri yolu içine yayımlanırken güncelleştirmek nasıl bir olay denetimli mimari birden fazla mikro hizmetler arasında uygularken zor olduğu işlem.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-174">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="bf0ae-175">Ek yaklaşımları de olabilir ancak bunu yapmanın birkaç yolu şunlardır:</span><span class="sxs-lookup"><span data-stu-id="bf0ae-175">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="bf0ae-176">MSMQ gibi bir işlem (DTC tabanlı) kuyruğu kullanarak.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-176">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="bf0ae-177">(Ancak, eski bir yaklaşım budur.)</span><span class="sxs-lookup"><span data-stu-id="bf0ae-177">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="bf0ae-178">Kullanarak [işlem oturum araştırma](https://www.scoop.it/t/sql-server-transaction-log-mining).</span><span class="sxs-lookup"><span data-stu-id="bf0ae-178">Using [transaction log mining](https://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

- <span data-ttu-id="bf0ae-179">Tam kullanarak [olay kaynağını belirleme](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) deseni.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-179">Using full [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="bf0ae-180">Kullanarak [giden deseni](http://gistlabs.com/2014/05/the-outbox/): işlemsel veritabanı tablo olarak olay oluşturmak ve yayımlamak bir olay oluşturan bileşen temeli olacak bir ileti sırası.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-180">Using the [Outbox pattern](http://gistlabs.com/2014/05/the-outbox/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="bf0ae-181">Zaman uyumsuz iletişim kullanırken dikkate alınması gereken ek konuları ileti Eşkuvvetlilik ve ileti yinelenen verileri kaldırma ' dir.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-181">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="bf0ae-182">Bu konulara bölümünde ele alınmıştır [(tümleştirme olayları) mikro hizmetler arasında olay tabanlı iletişim uygulama](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) bu kılavuzun sonraki.</span><span class="sxs-lookup"><span data-stu-id="bf0ae-182">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="bf0ae-183">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="bf0ae-183">Additional resources</span></span>

- <span data-ttu-id="bf0ae-184">**Mesajlaşma typu EventDriven** \\</span><span class="sxs-lookup"><span data-stu-id="bf0ae-184">**Event Driven Messaging** \\</span></span>
  [*http://soapatterns.org/design_patterns/event_driven_messaging*](http://soapatterns.org/design_patterns/event_driven_messaging)

- <span data-ttu-id="bf0ae-185">**Kanal yayımlama/abone olma** \\</span><span class="sxs-lookup"><span data-stu-id="bf0ae-185">**Publish/Subscribe Channel** \\</span></span>
  [*https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)

- <span data-ttu-id="bf0ae-186">**UDI Dahan. Açıklanan CQRS** \\</span><span class="sxs-lookup"><span data-stu-id="bf0ae-186">**Udi Dahan. Clarified CQRS** \\</span></span>
  [*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)

- <span data-ttu-id="bf0ae-187">**Komut ve sorgu sorumluluğu ayrımı (CQRS)** \\</span><span class="sxs-lookup"><span data-stu-id="bf0ae-187">**Command and Query Responsibility Segregation (CQRS)** \\</span></span>
  [*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)

- <span data-ttu-id="bf0ae-188">**Sınırlanmış Bağlamlar arasında iletişim kurma** \\</span><span class="sxs-lookup"><span data-stu-id="bf0ae-188">**Communicating Between Bounded Contexts** \\</span></span>
  [*https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)*](https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10))

- <span data-ttu-id="bf0ae-189">**Son tutarlılık** \\</span><span class="sxs-lookup"><span data-stu-id="bf0ae-189">**Eventual consistency** \\</span></span>
  [*https://en.wikipedia.org/wiki/Eventual_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)

- <span data-ttu-id="bf0ae-190">**Jimmy Bogard. Doğru dayanıklılığı yeniden düzenleme: Bağlantı değerlendirme** \\</span><span class="sxs-lookup"><span data-stu-id="bf0ae-190">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** \\</span></span>
  [*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)

>[!div class="step-by-step"]
><span data-ttu-id="bf0ae-191">[Önceki](communication-in-microservice-architecture.md)
>[İleri](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="bf0ae-191">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>

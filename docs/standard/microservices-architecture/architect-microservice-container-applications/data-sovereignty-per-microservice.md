---
title: Mikro hizmet başına veri hakimiyeti
description: Mikro hizmet başına veri hakimiyeti mikro kay noktası biridir. Her mikro hizmet kendi veritabanında hiçbir diğer paylaşım sahibi tek olması gerekir. Elbette bir mikro hizmet tüm örnekleri aynı yüksek kullanılabilirlik veritabanına bağlanın.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/20/2018
ms.openlocfilehash: 1b0b1fbb72f759eb337c0c1a9c465cc4088d8eff
ms.sourcegitcommit: 438919211260bb415fc8f96ca3eabc33cf2d681d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/16/2019
ms.locfileid: "59611243"
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="84600-105">Mikro hizmet başına veri hakimiyeti</span><span class="sxs-lookup"><span data-stu-id="84600-105">Data sovereignty per microservice</span></span>

<span data-ttu-id="84600-106">Mikro hizmet mimarisi için önemli bir kuralı, her bir mikro hizmet kendi etki alanı verileri ve mantıksal sahibi olduğunu ' dir.</span><span class="sxs-lookup"><span data-stu-id="84600-106">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="84600-107">Bu nedenle yalnızca tam bir uygulama, mantık ve veriler sahip olduğu gibi her bir mikro hizmet kendi mantığı ve verileri ile mikro hizmet başına bağımsız olarak dağıtılmasını otonom bir yaşam döngüsü altında sahip olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="84600-107">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="84600-108">Başka bir deyişle, etki alanının kavramsal model alt sistemler veya mikro hizmetler arasında farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="84600-108">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="84600-109">Kurumsal uygulamaları ve müşteri ilişkileri yönetimi (CRM) uygulamaları, işlem her çağrıda benzersiz Müşteri varlık öznitelikleri ve veri alt sistemleri ve müşteri destek alt sistemler satın yerde ve her farklı bir kullanan göz önünde bulundurun Sınırlanmış bağlam (BC).</span><span class="sxs-lookup"><span data-stu-id="84600-109">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="84600-110">Bu ilkeye benzer [etki alanı Odaklı Tasarım (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), burada her [içerik sınırlanmış](https://martinfowler.com/bliki/BoundedContext.html) veya otonom alt sistemi veya hizmet kendi etki alanı modeli (veri yanı sıra mantığı ve davranışı) sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="84600-110">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="84600-111">Her DDD içerik sınırlanmış bir iş mikro (bir veya birden fazla hizmet) ilişkilendirir.</span><span class="sxs-lookup"><span data-stu-id="84600-111">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="84600-112">İçerik sınırlanmış düzeniyle ilgili bu noktadan sonraki bölümde genişletilir.</span><span class="sxs-lookup"><span data-stu-id="84600-112">This point about the Bounded Context pattern is expanded in the next section.</span></span>

<span data-ttu-id="84600-113">Öte yandan, birçok uygulamada kullanılan geleneksel (tek parçalı veriler) yaklaşımı tek, merkezi bir veritabanındaki veya yalnızca birkaç veritabanlarına sahip olmaktır.</span><span class="sxs-lookup"><span data-stu-id="84600-113">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="84600-114">Genellikle tüm uygulama ve tüm kendi iç alt sistemleri için kullanılan normalleştirilmiş bir SQL veritabanı Şekil 4-7'de gösterildiği gibi budur.</span><span class="sxs-lookup"><span data-stu-id="84600-114">This is often a normalized SQL database that's used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![Geleneksel yaklaşımda genellikle katmanlı bir mimari olarak tüm hizmetler arasında paylaşılan tek bir veritabanı yok.](./media/image7.png)

<span data-ttu-id="84600-117">**Şekil 4-7**.</span><span class="sxs-lookup"><span data-stu-id="84600-117">**Figure 4-7**.</span></span> <span data-ttu-id="84600-118">Veri egemenliği karşılaştırması: tek parça veritabanı ile mikro hizmetler karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="84600-118">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="84600-119">Merkezi veritabanı yaklaşımı, başlangıçta basit arar ve her şeyi tutarlı hale getirmek için farklı alt sistemler varlık yeniden etkinleştirmek için gibi görünüyor.</span><span class="sxs-lookup"><span data-stu-id="84600-119">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="84600-120">Ancak, birçok farklı alt sistemleri, hizmet ve çoğu durumda öznitelikleri ve gerekli olmayan sütunları içeren büyük tablolar elde edersiniz gerçeğidir.</span><span class="sxs-lookup"><span data-stu-id="84600-120">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that aren't needed in most cases.</span></span> <span data-ttu-id="84600-121">Bu, aynı fiziksel harita kısa bir iz yürüyüşe ayırır, bir günlük uzun araba yolculuğu alma ve Coğrafya öğrenme kullanmaya çalışıyor gibi olur.</span><span class="sxs-lookup"><span data-stu-id="84600-121">It's like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="84600-122">Genellikle tek bir ilişkisel veritabanı ile tek parça bir uygulamayı iki önemli avantajı vardır: [ACID işlemlerini](https://en.wikipedia.org/wiki/ACID) ve SQL dili, tüm tabloları ve uygulamanız ile ilgili veriler arasında her iki çalışma.</span><span class="sxs-lookup"><span data-stu-id="84600-122">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="84600-123">Bu yaklaşım, kolayca birden fazla tablolardaki verileri birleştiren bir sorgu yazmak için bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="84600-123">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="84600-124">Ancak, bir mikro hizmet mimarisi için taşıdığınızda veri erişimi çok daha karmaşık hale gelir.</span><span class="sxs-lookup"><span data-stu-id="84600-124">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="84600-125">Ancak ACID işlemlerini olabilir veya bir mikro hizmet veya içerik sınırlanmış içinde kullanılması gereken olsa bile, her mikro hizmet tarafından sahip olunan veri, mikro hizmet için özeldir ve yalnızca kendi mikro hizmet API aracılığıyla erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="84600-125">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="84600-126">Veri kapsülleme, mikro Hizmetleri birbirine sıkı şekilde bağlı ve devredebileceği geliştirebilirsiniz sağlar.</span><span class="sxs-lookup"><span data-stu-id="84600-126">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="84600-127">Şema güncelleştirmeleri, birden fazla hizmeti aynı verileri erişiyorsanız, bu tüm hizmetler için Eşgüdümlü güncelleştirmeleri gerekir.</span><span class="sxs-lookup"><span data-stu-id="84600-127">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="84600-128">Bu mikro hizmet yaşam döngüsü otonomi çalışmamasına neden.</span><span class="sxs-lookup"><span data-stu-id="84600-128">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="84600-129">Ancak, Dağıtılmış veri yapıları üzerinde mikro hizmetler tek bir ACID işlemi yapamaz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="84600-129">But distributed data structures mean that you can't make a single ACID transaction across microservices.</span></span> <span data-ttu-id="84600-130">Bu sırayla bir iş sürecini birden fazla mikro hizmetin yayıldığında nihai tutarlılık kullanmalısınız anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="84600-130">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="84600-131">Bu bütünlük kısıtlamaları oluşturmak veya daha sonra açıklayacağız ayrı veritabanları arasında dağıtılmış işlemler kullanmak basit SQL birleşimleri, uygulamak çok daha zordur.</span><span class="sxs-lookup"><span data-stu-id="84600-131">This is much harder to implement than simple SQL joins, because you can't create integrity constraints or use distributed transactions between separate databases, as we'll explain later on.</span></span> <span data-ttu-id="84600-132">Benzer şekilde, diğer pek çok ilişkisel veritabanı özellikleri arasında birden fazla mikro hizmetin kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="84600-132">Similarly, many other relational database features aren't available across multiple microservices.</span></span>

<span data-ttu-id="84600-133">Daha da ileri giderek, farklı bir mikro hizmetler farklı kullandığı *tür* veritabanlarının.</span><span class="sxs-lookup"><span data-stu-id="84600-133">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="84600-134">Modern uygulamalar depolama ve işlem farklı türlerde veri ve ilişkisel bir veritabanı olmadığından her zaman en iyi seçenek.</span><span class="sxs-lookup"><span data-stu-id="84600-134">Modern applications store and process diverse kinds of data, and a relational database isn't always the best choice.</span></span> <span data-ttu-id="84600-135">Bazı için kullanım örnekleri, Azure Cosmosdb'ye veya MongoDB gibi bir NoSQL veritabanı daha kullanışlı bir veri modeline sahip olan ve daha iyi performans ve ölçeklenebilirlik SQL Server gibi bir SQL veritabanı veya Azure SQL veritabanı sağlar.</span><span class="sxs-lookup"><span data-stu-id="84600-135">For some use cases, a NoSQL database such as Azure CosmosDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="84600-136">Diğer durumlarda, bir ilişkisel veritabanı hala en iyi yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="84600-136">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="84600-137">Bu nedenle, mikro hizmet tabanlı uygulamaları bazen çağrılan bir karışımını SQL ve NoSQL veritabanları, sık kullandığınız [çok yönlü Kalıcılık](https://martinfowler.com/bliki/PolyglotPersistence.html) yaklaşım.</span><span class="sxs-lookup"><span data-stu-id="84600-137">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="84600-138">Veri depolama için bölümlenmiş, polyglot kalıcı bir mimari, pek çok faydası vardır.</span><span class="sxs-lookup"><span data-stu-id="84600-138">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="84600-139">Bunlar, gevşek bağlantılı Hizmetleri ve daha iyi performans, ölçeklenebilirlik, maliyetleri ve yönetilebilirlik içerir.</span><span class="sxs-lookup"><span data-stu-id="84600-139">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="84600-140">Ancak, bazı Dağıtılmış veri yönetimi sorunlarını açıklandığı şekilde ortaya çıkarabilir "[etki alanı modeli sınırlarını tanımlama](identify-microservice-domain-model-boundaries.md)" Bu bölümdeki.</span><span class="sxs-lookup"><span data-stu-id="84600-140">However, it can introduce some distributed data management challenges, as explained in "[Identifying domain-model boundaries](identify-microservice-domain-model-boundaries.md)" later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="84600-141">Mikro hizmet ve içerik sınırlanmış deseni arasındaki ilişki</span><span class="sxs-lookup"><span data-stu-id="84600-141">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="84600-142">Mikro hizmet kavramını türetildiği [sınırlanmış bağlam (BC) deseni](https://martinfowler.com/bliki/BoundedContext.html) içinde [etki alanı Odaklı Tasarım (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span><span class="sxs-lookup"><span data-stu-id="84600-142">The concept of microservice derives from the [Bounded Context (BC) pattern](https://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="84600-143">DDD, bunları birden çok BCs bölme ve sınırlarının hakkında açık büyük modelleri ile ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="84600-143">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="84600-144">Her BC kendi model ve veritabanı olmalıdır; benzer şekilde, her bir mikro hizmet kendi ilgili verilere sahip.</span><span class="sxs-lookup"><span data-stu-id="84600-144">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="84600-145">Ayrıca, her BC genellikle kendi bölümüne sahiptir [bulunabilen dil](https://martinfowler.com/bliki/UbiquitousLanguage.html) yazılım geliştiricileri ve etki alanı uzmanları arasındaki iletişimi yardımcı olmak için.</span><span class="sxs-lookup"><span data-stu-id="84600-145">In addition, each BC usually has its own [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="84600-146">Bulunabilen dilde Bu terimleri (ağırlıklı olarak etki alanı varlıklarının) farklı sınırlanmış bağlamda farklı adlara sahip olabilir, aynı kimliğe (varlık depodan okumak için kullanılan diğer bir deyişle, benzersiz Tanımlayıcı) bile farklı etki alanı varlıklarının paylaşın.</span><span class="sxs-lookup"><span data-stu-id="84600-146">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that's used to read the entity from storage).</span></span> <span data-ttu-id="84600-147">Örneğin, sipariş sınırlanmış bağlam içinde alıcı etki alanı varlığı ile kullanıcı profili sınırlanmış bir bağlamda kullanıcı etki alanı varlığı kimlik paylaşabilir.</span><span class="sxs-lookup"><span data-stu-id="84600-147">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="84600-148">Bir mikro hizmet gibi bir sınırlanmış bağlam nedenle gereklidir, ancak ayrıca dağıtılmış bir hizmet olduğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="84600-148">A microservice is therefore like a Bounded Context, but it also specifies that it's a distributed service.</span></span> <span data-ttu-id="84600-149">Sınırlanmış her bağlam için ayrı bir işlem olarak oluşturulmuştur ve HTTP/HTTPS gibi WebSockets, daha önce not ettiğiniz dağıtılmış protokolleri kullanması gerekir veya [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span><span class="sxs-lookup"><span data-stu-id="84600-149">It's built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="84600-150">İçerik sınırlanmış deseni ancak sınırlanmış bağlam, dağıtılmış bir hizmet olup olmadığını veya yalnızca mantıksal bir sınır (örneğin, bir genel alt) olup olmadığını bir dağıtım tek parçalı uygulama içinde belirtmiyor.</span><span class="sxs-lookup"><span data-stu-id="84600-150">The Bounded Context pattern, however, doesn't specify whether the Bounded Context is a distributed service or if it's simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="84600-151">Sınırlanmış her bağlam için bir hizmet tanımlama başlatmak için iyi bir yer olduğunu vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="84600-151">It's important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="84600-152">Ancak ona tasarımınızı sınırlamak zorunda değilsiniz.</span><span class="sxs-lookup"><span data-stu-id="84600-152">But you don't have to constrain your design to it.</span></span> <span data-ttu-id="84600-153">Bazen bir sınırlanmış bağlam tasarlamanız gerekir veya iş mikro hizmet birden fazla fiziksel hizmetlerden oluşan.</span><span class="sxs-lookup"><span data-stu-id="84600-153">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="84600-154">Ancak sonuç olarak, her ikisi de desenleri - içerik sınırlanmış ve mikro hizmet olan yakından ilgili.</span><span class="sxs-lookup"><span data-stu-id="84600-154">But ultimately, both patterns -Bounded Context and microservice- are closely related.</span></span>

<span data-ttu-id="84600-155">Mikro hizmetler, dağıtılmış mikro hizmetler biçiminde gerçek sınırları alarak DDD sağladığı avantajları.</span><span class="sxs-lookup"><span data-stu-id="84600-155">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="84600-156">Ancak kullanılmadığı mikro hizmetler arasında model gibi fikirleri ne de bir sınırlanmış bağlam içinde istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="84600-156">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="84600-157">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="84600-157">Additional resources</span></span>

- <span data-ttu-id="84600-158">**Chris Richardson. Desen: Hizmet başına veritabanı** \\</span><span class="sxs-lookup"><span data-stu-id="84600-158">**Chris Richardson. Pattern: Database per service** \\</span></span>
  <https://microservices.io/patterns/data/database-per-service.html>

- <span data-ttu-id="84600-159">**Martin Fowler. BoundedContext** \\</span><span class="sxs-lookup"><span data-stu-id="84600-159">**Martin Fowler. BoundedContext** \\</span></span>
  <https://martinfowler.com/bliki/BoundedContext.html>

- <span data-ttu-id="84600-160">**Martin Fowler. PolyglotPersistence** \\</span><span class="sxs-lookup"><span data-stu-id="84600-160">**Martin Fowler. PolyglotPersistence** \\</span></span>
  <https://martinfowler.com/bliki/PolyglotPersistence.html>

- <span data-ttu-id="84600-161">**Alberto Brandolini. Stratejik etki alanı Odaklı Tasarım bağlam eşleme ile** \\</span><span class="sxs-lookup"><span data-stu-id="84600-161">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping** \\</span></span>
  <https://www.infoq.com/articles/ddd-contextmapping>

>[!div class="step-by-step"]
><span data-ttu-id="84600-162">[Önceki](microservices-architecture.md)
>[İleri](logical-versus-physical-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="84600-162">[Previous](microservices-architecture.md)
[Next](logical-versus-physical-architecture.md)</span></span>

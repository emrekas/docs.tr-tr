---
title: DDD odaklı bir mikro hizmet tasarlama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmet mimarisi | DDD odaklı sıralama mikro hizmet ve uygulama katmanları tasarımını anlayın.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/08/2018
ms.openlocfilehash: 5c56e497ffb6466840d034458daaebf9fe0c8f03
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62020094"
---
# <a name="design-a-ddd-oriented-microservice"></a><span data-ttu-id="a99f6-103">DDD odaklı bir mikro hizmet tasarlama</span><span class="sxs-lookup"><span data-stu-id="a99f6-103">Design a DDD-oriented microservice</span></span>

<span data-ttu-id="a99f6-104">Etki alanı Odaklı Tasarım (DDD), kullanım örnekleri ile ilgili olarak iş gerçeğe dayalı modelleme sorunlarınızda.</span><span class="sxs-lookup"><span data-stu-id="a99f6-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="a99f6-105">Uygulamaları oluşturma, bağlamında DDD etki alanı adı sorunlar hakkında konuşuyor.</span><span class="sxs-lookup"><span data-stu-id="a99f6-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="a99f6-106">Sınırlanmış Bağlamlar olarak bağımsız sorunlu alanları açıklar (her sınırlanmış bağlam karşılık gelen bir mikro hizmet için) ve bu sorunları hakkında konuşmak için ortak bir dil vurgular.</span><span class="sxs-lookup"><span data-stu-id="a99f6-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="a99f6-107">Ayrıca birçok teknik kavramlar ve desenleri, etki alanı varlıklarla zengin modeller gibi önerir (hiçbir [anemic etki alanı modeli](https://martinfowler.com/bliki/AnemicDomainModel.html)), değeri nesneleri, toplamlar ve toplama kök (veya kök varlık) kuralları iç uygulama desteklemek için.</span><span class="sxs-lookup"><span data-stu-id="a99f6-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="a99f6-108">Bu bölüm, tasarım ve uygulama bu iç desenlerinin tanıtır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="a99f6-109">Bazen bu DDD teknik kuralları ve desenleri DDD yaklaşımları uygulamak için zorlu öğrenme süreçlerine sahip engellerini algılanır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="a99f6-110">Ancak, önemli değil desenleri kendilerini, ancak iş sorunlarına hizalanacağı şekilde kod düzenleme ve aynı iş terimlerini (bulunabilen dili) kullanarak bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="a99f6-111">Ayrıca, önemli iş kuralları ile karmaşık mikro hizmetler uyguluyorsanız DDD yaklaşımları uygulanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="a99f6-112">Bir CRUD hizmeti gibi basit sorumlulukları daha basit bir yaklaşım ile yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="a99f6-113">Sınırları nerede tasarlarken ve bir mikro hizmet tanımlama anahtar görevdir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="a99f6-114">DDD deseni etki alanındaki karmaşıklığı anlamanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="a99f6-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="a99f6-115">Etki alanı modeli için sınırlanmış her bağlam için belirleyin ve varlıkları, değer nesneleri ve, etki alanı model toplamalar tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="a99f6-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="a99f6-116">Derleme ve Bağlamınızı tanımlayan bir sınırları içinde yer alan bir etki alanı modeli daraltın.</span><span class="sxs-lookup"><span data-stu-id="a99f6-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="a99f6-117">Ve bir mikro hizmet biçiminde çok açık.</span><span class="sxs-lookup"><span data-stu-id="a99f6-117">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="a99f6-118">Son BC bir bazı durumlarda olsa da bu sınırlar içinde bileşenleri, mikro hizmetler, olan yukarı veya iş mikro hizmetler birçok fiziksel hizmetlerini oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="a99f6-119">DDD sınırları hakkında ve bu nedenle mikro hizmetler.</span><span class="sxs-lookup"><span data-stu-id="a99f6-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="a99f6-120">Mikro hizmet bağlam sınırlarını görece küçük tutun</span><span class="sxs-lookup"><span data-stu-id="a99f6-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="a99f6-121">Sınırlanmış Bağlamlar arasında sınırları yerleştirileceği yeri belirleme iki rakip hedefleri dengeler.</span><span class="sxs-lookup"><span data-stu-id="a99f6-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="a99f6-122">İlk olarak, ana sürücüsü olmamalıdır olsa da başlangıçta en küçük olası mikro hizmetler oluşturmak istiyorsunuz; Uyuma gereken şeyleri etrafında bir sınır oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="a99f6-123">İkinci olarak, mikro hizmetler arasında geveze iletişim engellemek istiyorsanız.</span><span class="sxs-lookup"><span data-stu-id="a99f6-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="a99f6-124">Bu hedefleri birbiriyle çelişebilir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-124">These goals can contradict one another.</span></span> <span data-ttu-id="a99f6-125">Yeni bir sınırlanmış bağlam ayırmak için her ek denemesi ile hızla büyüyen iletişim sınırları görene kadar olabildiğince çok küçük mikro hizmetler halinde sistemin parçalama bunları dengelemek.</span><span class="sxs-lookup"><span data-stu-id="a99f6-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="a99f6-126">Uyuma tek bir sınırlanmış bağlam içinde bir anahtardır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="a99f6-127">Benzer [uygunsuz samimiyet duyguları kod kokusu](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) sınıfları uygulanırken.</span><span class="sxs-lookup"><span data-stu-id="a99f6-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="a99f6-128">İki mikro hizmetler çok birbirleriyle işbirliği yapması gerekiyorsa, bunlar büyük olasılıkla aynı mikro hizmet olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="a99f6-129">Şu anda aramak için başka bir bağımsız çalışma sınırı yoludur.</span><span class="sxs-lookup"><span data-stu-id="a99f6-129">Another way to look at this is autonomy.</span></span> <span data-ttu-id="a99f6-130">Bir mikro hizmet doğrudan bir isteğe hizmet vermek için başka bir hizmetten yararlanın gerekir, gerçek anlamda otonom değil.</span><span class="sxs-lookup"><span data-stu-id="a99f6-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="a99f6-131">DDD mikro hizmet katmanları</span><span class="sxs-lookup"><span data-stu-id="a99f6-131">Layers in DDD microservices</span></span>

<span data-ttu-id="a99f6-132">Çoğu kurumsal uygulamalar önemli işletme ve teknik karmaşıklığı ile birden çok katman tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="a99f6-133">Katmanları olan mantıksal bir yapıt ve hizmeti dağıtımına ilişkili değildir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="a99f6-134">Geliştiricilerin kod karmaşıklığını yönetmenize yardımcı olmak için mevcut.</span><span class="sxs-lookup"><span data-stu-id="a99f6-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="a99f6-135">(Etki alanı model katmanında ve bir sunu katmanı, vb. gibi) farklı katmanlara hangi bu türler arasında çevirileri taahhütlerin farklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="a99f6-136">Örneğin, bir varlığın veritabanından yüklenemedi.</span><span class="sxs-lookup"><span data-stu-id="a99f6-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="a99f6-137">Ardından bu bilgileri veya diğer varlıklar, ek verileri dahil olmak üzere bilgi toplamını bölümü bir REST Web API'si aracılığıyla kullanıcı Arabirimi istemciye gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="a99f6-138">Burada etki alanı varlığı içinde etki alanı model katmanında yer alır ve bunu, gibi sunu katmanına ait değil. diğer alanlarına yayılır değil noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="a99f6-139">Ayrıca, her zaman geçerli varlıkları olması gerekir (bkz [etki alanı model katmanında doğrulamaları tasarlama](domain-model-layer-validations.md) bölümü) toplama kökleri (kök varlıklar) tarafından denetlenir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](domain-model-layer-validations.md) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="a99f6-140">UI düzeyinde bazı veriler hala geçerliliğinin doğrulanması çünkü bu nedenle, varlıklar istemci görünümlerine bağlanmalıdır değil.</span><span class="sxs-lookup"><span data-stu-id="a99f6-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="a99f6-141">ViewModel içindir budur.</span><span class="sxs-lookup"><span data-stu-id="a99f6-141">This is what the ViewModel is for.</span></span> <span data-ttu-id="a99f6-142">ViewModel, sunu katmanı ihtiyaçları için özel bir veri modelidir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="a99f6-143">Etki alanı varlıklarının ViewModel için doğrudan ait değil.</span><span class="sxs-lookup"><span data-stu-id="a99f6-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="a99f6-144">Bunun yerine, Viewmodel'lar ve etki alanı varlıklar arasında ve çevirme gerekir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="a99f6-145">Kuruluşlarda karmaşıklığı okuduğunuzda ve kuralları için ilgili emin toplama kökleri tarafından denetlenen bir etki alanı modeli için önemli olduğunda, varlıkları (toplama) grubu gerçekleştirilir tek giriş noktası veya ağ geçidi, toplama kök ile.</span><span class="sxs-lookup"><span data-stu-id="a99f6-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="a99f6-146">Şekil 7-5 katmanlı bir tasarım hizmetine uygulamada nasıl uygulandığını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-146">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![Bir DDD mikro hizmet üç katmanda sıralama ister.](./media/image6.png)

<span data-ttu-id="a99f6-149">**Şekil 7-5**.</span><span class="sxs-lookup"><span data-stu-id="a99f6-149">**Figure 7-5**.</span></span> <span data-ttu-id="a99f6-150">Sıralama mikro hizmetine DDD katmanları</span><span class="sxs-lookup"><span data-stu-id="a99f6-150">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="a99f6-151">Her katman yalnızca belirli diğer katmanlarla ile iletişim kurar. böylece sistemi tasarlamak istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="a99f6-151">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="a99f6-152">Kitaplıklar arasında hangi bağımlılıkların ayarlandığından NET bir şekilde tespit edebilirsiniz çünkü katmanları farklı sınıf kitaplıkları uygulanırsa zorlamak daha kolay olabilir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-152">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="a99f6-153">Örneğin, etki alanı model katmanında bir bağımlılık başka bir katmanda almamalıdır (düz eski CLR nesnelerini, etki alanı model sınıfları olmalıdır veya [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), sınıflar).</span><span class="sxs-lookup"><span data-stu-id="a99f6-153">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="a99f6-154">Şekil 7-6'da gösterildiği gibi **Ordering.Domain** Katmanı kitaplığı, yalnızca .NET Core kitaplıkları veya NuGet paketlerini, ancak tüm diğer özel bir kitaplık, verileri kitaplığı veya Kalıcılık kitaplığı gibi bağımlılıkları vardır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-154">As shown in Figure 7-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![Çözüm Gezgini görünümü Ordering.Domain bağımlılıklarının göstermeyi .NET Core kitaplıkları'nı yalnızca bağlıdır.](./media/image7.png)

<span data-ttu-id="a99f6-156">**Şekil 7-6**.</span><span class="sxs-lookup"><span data-stu-id="a99f6-156">**Figure 7-6**.</span></span> <span data-ttu-id="a99f6-157">Kitaplıkları Katmanlar arasındaki bağımlılıkları daha iyi Denetimi'ne izin ver olarak uygulanan katmanları</span><span class="sxs-lookup"><span data-stu-id="a99f6-157">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="a99f6-158">Etki alanı model katmanında</span><span class="sxs-lookup"><span data-stu-id="a99f6-158">The domain model layer</span></span>

<span data-ttu-id="a99f6-159">Eric Evans'ın mükemmel kitap [etki alanı Odaklı Tasarım](https://domainlanguage.com/ddd/) etki alanı model katmanında ve uygulama katmanı hakkında aşağıdaki söyler.</span><span class="sxs-lookup"><span data-stu-id="a99f6-159">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="a99f6-160">**Etki alanı Model katmanında**: İş kuralları ve iş durumu hakkındaki bilgileri, iş kavramlarını göstermek için sorumlu.</span><span class="sxs-lookup"><span data-stu-id="a99f6-160">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="a99f6-161">İş durumu yansıtır durumu denetlenir ve teknik ayrıntılarını depolamadan altyapıya izin verilmiş olsa da burada kullanılan.</span><span class="sxs-lookup"><span data-stu-id="a99f6-161">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="a99f6-162">Bu katman, Kurumsal Yazılım kalbidir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-162">This layer is the heart of business software.</span></span>

<span data-ttu-id="a99f6-163">Etki alanı model katmanında, iş yeri ifade edilir ' dir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-163">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="a99f6-164">. NET'te bir mikro hizmet etki alanı model katmanında uyguladığınızda, o katmanın verilerin yanı sıra davranışı (mantıksal yöntemleriyle) yakalama etki alanı varlıklarının ile bir sınıf kitaplığı olarak kodlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-164">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="a99f6-165">Aşağıdaki [Kalıcılık Ignorance](https://deviq.com/persistence-ignorance/) ve [altyapı Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) ilkeleri, bu katman veri kalıcılığı ayrıntıları tamamen yoksay gerekir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-165">Following the [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="a99f6-166">Bu süreklilik görevleri altyapı katmanı tarafından gerçekleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-166">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="a99f6-167">Bu nedenle, bu katmanda doğrudan bağımlılıkları önemli bir kuralı, etki alanı modeli varlık sınıfları olmalıdır, yani etkin altyapısında almamalıdır [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span><span class="sxs-lookup"><span data-stu-id="a99f6-167">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="a99f6-168">Etki alanı varlıklarının Entity Framework veya NHibernate gibi tüm veri erişim altyapı Framework (örneğin, bir taban sınıftan türetme) doğrudan hiçbir bağımlılık olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-168">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="a99f6-169">İdeal olarak, etki alanı varlıklarınızı türetmek veya gerekir tüm altyapı Framework'te tanımlanan herhangi bir tür.</span><span class="sxs-lookup"><span data-stu-id="a99f6-169">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="a99f6-170">Etki alanı model sınıflarınızı altyapıya bağlı değil, bu yaklaşım, Entity Framework Core gibi birçok modern ORM çerçeveleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="a99f6-170">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="a99f6-171">Ancak, POCO varlık sahip her zaman belirli bir NoSQL veritabanları ve aktörler ve Azure Service fabric'te güvenilir koleksiyonlar gibi çerçeveleri kullanarak mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-171">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="a99f6-172">Etki alanı modeliniz için Kalıcılık Ignorance ilkesini izlemek önemli olsa bile, Kalıcılık kaygıları sayılmalıdır değil.</span><span class="sxs-lookup"><span data-stu-id="a99f6-172">Even when it is important to follow the Persistence Ignorance principle for your Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="a99f6-173">Yine de fiziksel veri modeli ve varlığı nesne modeli eşlemelerini nasıl anlamak çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-173">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="a99f6-174">Aksi takdirde, mümkün olmayan tasarımı oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a99f6-174">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="a99f6-175">Ayrıca, bu, ilişkisel bir veritabanı için tasarlanmış bir model alabilir ve doğrudan taşımak için bir NoSQL veya belge yönelimli veritabanı anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="a99f6-175">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="a99f6-176">Bazı varlık modelleri modeline uyacak, ancak genellikle yok.</span><span class="sxs-lookup"><span data-stu-id="a99f6-176">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="a99f6-177">Yine de, varlık modeli, hem depolama teknolojisi ve teknolojisi ORM tabanlı uymalıdır kısıtlamaları da vardır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-177">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="a99f6-178">Uygulama katmanı</span><span class="sxs-lookup"><span data-stu-id="a99f6-178">The application layer</span></span>

<span data-ttu-id="a99f6-179">Taşıma için uygulama katmanı, biz yeniden alınıyor Eric Evans'ın kitap [etki alanı Odaklı Tasarım](https://domainlanguage.com/ddd/):</span><span class="sxs-lookup"><span data-stu-id="a99f6-179">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="a99f6-180">**Uygulama katmanı:** Yazılım yapmak için gereken ve sorunlarını çalışmaya ifadesel bir etki alanı nesnelerini yönlendirir işleri tanımlar.</span><span class="sxs-lookup"><span data-stu-id="a99f6-180">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="a99f6-181">Bu katman sorumlu olduğu iş anlamlı veya diğer sistemlere uygulama katmanları ile etkileşim için gerekli görevlerdir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-181">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="a99f6-182">Bu katman, ölçülü kaynak tutulur.</span><span class="sxs-lookup"><span data-stu-id="a99f6-182">This layer is kept thin.</span></span> <span data-ttu-id="a99f6-183">İş kuralları veya bilgi içermiyor, ancak yalnızca koordinatları görevleri ve temsilciler için etki alanı nesnelerini sonraki katmanında işbirliğini aşağı çalışır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-183">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="a99f6-184">İş durumu yansıtma durumu yok, ancak kullanıcı veya program için bir görev ilerlemesini gösteren bir durum olabilir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-184">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="a99f6-185">.NET mikro hizmet ait uygulama katmanında, genellikle bir ASP.NET Core Web API projesi kodlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-185">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="a99f6-186">Mikro hizmet'ın etkileşim, uzak ağ erişimi ve kullanıcı Arabirimi veya istemci uygulamalardan kullanılan dış Web API projesi uygular.</span><span class="sxs-lookup"><span data-stu-id="a99f6-186">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="a99f6-187">Mikro hizmet ve mikro hizmetler (tümleştirme olayları) arasında bile olay temelli iletişim tarafından kabul edilen komutlar kullanılarak bir CQRS yaklaşımı, sorguları içerir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-187">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="a99f6-188">Uygulama katmanı temsil eden ASP.NET Core Web API'si, iş kuralları veya etki alanı bilgilerini (özellikle etki alanı kuralları için işlemleri veya güncelleştirmeler); içermemelidir Bu etki alanı modeli sınıfı kitaplığı tarafından ait.</span><span class="sxs-lookup"><span data-stu-id="a99f6-188">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="a99f6-189">Uygulama katmanı yalnızca gereken koordinat görevleri ve gerekir değil basılı tutun veya herhangi bir etki alanı durumu (etki alanı modeli) tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="a99f6-189">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="a99f6-190">Bu, iş kuralları, bu etki alanı varlıklarının içinde verilerin nihai olarak güncelleştirir etki alanı model sınıflarına kendilerini (toplama kökler ve etki alanı varlıklarının) yürütülmesini atar.</span><span class="sxs-lookup"><span data-stu-id="a99f6-190">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="a99f6-191">Uygulama mantığı temel olarak, belirli bir ön uç üzerinde bağımlı tüm kullanım örnekleri burada uygulamanız olur.</span><span class="sxs-lookup"><span data-stu-id="a99f6-191">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="a99f6-192">Örneğin, bir Web API'si hizmeti için ilgili uygulama.</span><span class="sxs-lookup"><span data-stu-id="a99f6-192">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="a99f6-193">Etki alanı model katmanında, kendi okuduğunuzda, veri modeli ve ilgili iş kuralları etki alanı mantığı sunu ve uygulama katmanları tamamen bağımsız hedeftir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-193">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="a99f6-194">En önemlisi, etki alanı model katmanında doğrudan herhangi bir altyapı çerçeveyi bağımlı olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-194">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="a99f6-195">Altyapı katmanını</span><span class="sxs-lookup"><span data-stu-id="a99f6-195">The infrastructure layer</span></span>

<span data-ttu-id="a99f6-196">Veritabanları veya başka bir kalıcı depoya (bellekte) etki alanı varlıklarının başlangıçta tutulan verilerin kalıcı nasıl altyapı katmanıdır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-196">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="a99f6-197">Örnek, bir ilişkisel veritabanındaki verileri kalıcı hale getirmek için bir DBContext kullanın depo düzeni sınıfları uygulamak için Entity Framework Core kod kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="a99f6-197">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="a99f6-198">Daha önce bahsedilen uygun olarak [Kalıcılık Ignorance](https://deviq.com/persistence-ignorance/) ve [altyapı Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) ilkeleri, altyapı katmanını gerekir değil "zarar verme" etki alanı model katmanında.</span><span class="sxs-lookup"><span data-stu-id="a99f6-198">In accordance with the previously mentioned [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="a99f6-199">Etki alanı modeli varlık sınıfları belirsiz sabit bağımlılıkları çerçevelerini temel alarak değil (EF veya diğer herhangi bir çerçeveyi) verileri kalıcı hale getirmek için kullandığınız altyapıdan tutmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a99f6-199">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="a99f6-200">Etki alanı modeli katmanı sınıf kitaplığı yalnızca, etki alanı kodu yalnızca olması gerektiğini [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) varlık sınıfları yazılımınızı 'un uygulama ve altyapı teknolojiden tamamen ayrılmış.</span><span class="sxs-lookup"><span data-stu-id="a99f6-200">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="a99f6-201">Bu nedenle, katmanları veya sınıf kitaplıkları ve projeleri Sonuçta, etki alanı model katmanında (kitaplık) bağımlı tam tersi gerekmiyor, Şekil 7-7'de gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="a99f6-201">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</span></span>

![Etki alanı ve altyapı, bağımlılıkları DDD hizmetinde, uygulama katmanına bağlıdır ve altyapı etki alanına bağlıdır, ancak etki alanı herhangi bir katmanda bağımlı değildir.](./media/image8.png)

<span data-ttu-id="a99f6-203">**Şekil 7-7**.</span><span class="sxs-lookup"><span data-stu-id="a99f6-203">**Figure 7-7**.</span></span> <span data-ttu-id="a99f6-204">DDD Katmanlar arasındaki bağımlılıkları</span><span class="sxs-lookup"><span data-stu-id="a99f6-204">Dependencies between layers in DDD</span></span>

<span data-ttu-id="a99f6-205">Bu katman tasarım için her bir mikro hizmetin bağımsız olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a99f6-205">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="a99f6-206">Daha önce belirtildiği gibi en karmaşık mikro hizmetler uygulayabileceğiniz DDD deseni, veri odaklı basit uygulama çalışırken aşağıdaki mikro hizmetler (tek bir katmanda basit CRUD) daha basit bir şekilde.</span><span class="sxs-lookup"><span data-stu-id="a99f6-206">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="a99f6-207">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="a99f6-207">Additional resources</span></span>

- <span data-ttu-id="a99f6-208">**DevIQ. Kalıcılık Ignorance İlkesi** \\</span><span class="sxs-lookup"><span data-stu-id="a99f6-208">**DevIQ. Persistence Ignorance principle** \\</span></span>
  <https://deviq.com/persistence-ignorance/>

- <span data-ttu-id="a99f6-209">**Oren Eini. Altyapı Ignorance** \\</span><span class="sxs-lookup"><span data-stu-id="a99f6-209">**Oren Eini. Infrastructure Ignorance** \\</span></span>
  <https://ayende.com/blog/3137/infrastructure-ignorance>

- <span data-ttu-id="a99f6-210">**Angel Lopez. Etki alanı Odaklı Tasarım katmanlı mimaride** \\</span><span class="sxs-lookup"><span data-stu-id="a99f6-210">**Angel Lopez. Layered Architecture In Domain-Driven Design** \\</span></span>
  <https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/>

>[!div class="step-by-step"]
><span data-ttu-id="a99f6-211">[Önceki](cqrs-microservice-reads.md)
>[İleri](microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="a99f6-211">[Previous](cqrs-microservice-reads.md)
[Next](microservice-domain-model.md)</span></span>

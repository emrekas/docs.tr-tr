---
title: Etki alanı model katmanında doğrulamaları tasarlama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmet mimarisi | Etki alanı modeli doğrulamaları temel kavramlarını anlama.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/08/2018
ms.openlocfilehash: ae1252f4544f184a5f63ef02ba898da9b4373e17
ms.sourcegitcommit: 438919211260bb415fc8f96ca3eabc33cf2d681d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/16/2019
ms.locfileid: "59612712"
---
# <a name="design-validations-in-the-domain-model-layer"></a><span data-ttu-id="522d3-103">Etki alanı model katmanında doğrulamaları tasarlama</span><span class="sxs-lookup"><span data-stu-id="522d3-103">Design validations in the domain model layer</span></span>

<span data-ttu-id="522d3-104">DDD içinde doğrulama kuralları okuduğunuzda düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="522d3-104">In DDD, validation rules can be thought as invariants.</span></span> <span data-ttu-id="522d3-105">Ana toplama, toplam içindeki tüm varlıklar için durum değişikliklerini okuduğunuzda sağlamak için sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="522d3-105">The main responsibility of an aggregate is to enforce invariants across state changes for all the entities within that aggregate.</span></span>

<span data-ttu-id="522d3-106">Etki alanı varlıklar her zaman geçerli varlık olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="522d3-106">Domain entities should always be valid entities.</span></span> <span data-ttu-id="522d3-107">Okuduğunuzda her zaman true olması gereken bir nesne için belirli bir sayıda vardır.</span><span class="sxs-lookup"><span data-stu-id="522d3-107">There are a certain number of invariants for an object that should always be true.</span></span> <span data-ttu-id="522d3-108">Örneğin, bir sipariş öğesi nesne her zaman bir makale adı yanı sıra bir pozitif tamsayı olmalıdır ve Fiyat miktarı sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="522d3-108">For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price.</span></span> <span data-ttu-id="522d3-109">Bu nedenle, okuduğunuzda zorlama (özellikle, toplama kök) etki alanı varlıklarının sorumluluğundadır ve bir varlık nesnesine geçerli olmadan mevcut olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="522d3-109">Therefore, invariants enforcement is the responsibility of the domain entities (especially of the aggregate root) and an entity object should not be able to exist without being valid.</span></span> <span data-ttu-id="522d3-110">Sabit kuralları yalnızca sözleşmeleri ifade edilir ve özel durumlar veya bildirimleri, ihlal edildiğinde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="522d3-110">Invariant rules are simply expressed as contracts, and exceptions or notifications are raised when they are violated.</span></span>

<span data-ttu-id="522d3-111">Bunun ardındaki mantık nesneler içinde hiçbir zaman olmalıydı bir durumda olduğundan çok fazla hata meydana ' dir.</span><span class="sxs-lookup"><span data-stu-id="522d3-111">The reasoning behind this is that many bugs occur because objects are in a state they should never have been in.</span></span> <span data-ttu-id="522d3-112">Greg Young ' iyi bir açıklama aşağıda verilmektedir bir [Çevrimiçi tartışma](https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/):</span><span class="sxs-lookup"><span data-stu-id="522d3-112">The following is a good explanation from Greg Young in an [online discussion](https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/):</span></span>

<span data-ttu-id="522d3-113">Şimdi artık sahip olduğumuz bir UserProfile... nasıl biz adı null değil, hizmette basitleşir alan SendUserCreationEmailService önerilsin mi?</span><span class="sxs-lookup"><span data-stu-id="522d3-113">Let's propose we now have a SendUserCreationEmailService that takes a UserProfile ... how can we rationalize in that service that Name is not null?</span></span> <span data-ttu-id="522d3-114">Biz bunu yeniden kontrol edebilirim?</span><span class="sxs-lookup"><span data-stu-id="522d3-114">Do we check it again?</span></span> <span data-ttu-id="522d3-115">Veya daha büyük olasılıkla... denetleyip "için en iyi umuyoruz" yalnızca rahatsız değildir — birisi için göndermeden önce doğrulamak için rahatsız umuyoruz.</span><span class="sxs-lookup"><span data-stu-id="522d3-115">Or more likely ... you just don't bother to check and "hope for the best"—you hope that someone bothered to validate it before sending it to you.</span></span> <span data-ttu-id="522d3-116">Elbette, biz hata tetiklemelidir null bir ada sahip bir müşteri gönderebilirim durumunda yazma ilk testin TDD kullanma.</span><span class="sxs-lookup"><span data-stu-id="522d3-116">Of course, using TDD one of the first tests we should be writing is that if I send a customer with a null name that it should raise an error.</span></span> <span data-ttu-id="522d3-117">Ancak, bu tür testlerin tekrar tekrar yazma başlattıktan sonra biz fark... "biz adı olacak hiçbir zaman izin veriliyorsa bekleyin null tüm bu testleri sahibiz mıydı"</span><span class="sxs-lookup"><span data-stu-id="522d3-117">But once we start writing these kinds of tests over and over again we realize ... "wait if we never allowed name to become null we wouldn't have all of these tests"</span></span>

## <a name="implement-validations-in-the-domain-model-layer"></a><span data-ttu-id="522d3-118">Uygulama etki alanı model katmanında doğrulamaları</span><span class="sxs-lookup"><span data-stu-id="522d3-118">Implement validations in the domain model layer</span></span>

<span data-ttu-id="522d3-119">Doğrulama, etki alanı varlığı oluşturucular veya varlık güncelleştirebilirsiniz yöntemleri genellikle uygulanır.</span><span class="sxs-lookup"><span data-stu-id="522d3-119">Validations are usually implemented in domain entity constructors or in methods that can update the entity.</span></span> <span data-ttu-id="522d3-120">Doğrulamaları, doğrulanıyor veri ve doğrulama başarısız olursa, yükseltmeyi özel durumlar gibi uygulamak için birden çok yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="522d3-120">There are multiple ways to implement validations, such as verifying data and raising exceptions if the validation fails.</span></span> <span data-ttu-id="522d3-121">Ayrıca vardır doğrulamaların belirtimi deseni kullanma gibi daha gelişmiş düzenleri ve bu gerçekleştiği sırada her doğrulama için bir özel durum döndüren yerine hataları koleksiyonu döndürülecek bildirim düzeni.</span><span class="sxs-lookup"><span data-stu-id="522d3-121">There are also more advanced patterns such as using the Specification pattern for validations, and the Notification pattern to return a collection of errors instead of returning an exception for each validation as it occurs.</span></span>

### <a name="validate-conditions-and-throw-exceptions"></a><span data-ttu-id="522d3-122">Koşulları doğrulayın ve özel durumlar</span><span class="sxs-lookup"><span data-stu-id="522d3-122">Validate conditions and throw exceptions</span></span>

<span data-ttu-id="522d3-123">Aşağıdaki kod örneği, bir özel durum oluşturularak, bir etki alanı varlığı içinde doğrulama için en kolay yaklaşım gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="522d3-123">The following code example shows the simplest approach to validation in a domain entity by raising an exception.</span></span> <span data-ttu-id="522d3-124">Bu bölümün sonunda başvuruları tablodaki bağlantılar daha gelişmiş uygulamalar daha önce ele almıştık düzenlerini esas alarak görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="522d3-124">In the references table at the end of this section you can see links to more advanced implementations based on the patterns we have discussed previously.</span></span>

```csharp
public void SetAddress(Address address)
{
    _shippingAddress = address?? throw new ArgumentNullException(nameof(address));
}
```

<span data-ttu-id="522d3-125">Daha iyi bir örneği, iç durumu değişmedi ya da yöntem için tüm mutations oluştuğunu sağlama gereksinimi göstermek.</span><span class="sxs-lookup"><span data-stu-id="522d3-125">A better example would demonstrate the need to ensure that either the internal state did not change, or that all the mutations for a method occurred.</span></span> <span data-ttu-id="522d3-126">Örneğin, aşağıdaki uygulama nesnesi geçersiz bir durumda bırakın:</span><span class="sxs-lookup"><span data-stu-id="522d3-126">For example, the following implementation would leave the object in an invalid state:</span></span>

```csharp
public void SetAddress(string line1, string line2,
    string city, string state, int zip)
{
    _shippingAddress.line1 = line1 ?? throw new ...
    _shippingAddress.line2 = line2;
    _shippingAddress.city = city ?? throw new ...
    _shippingAddress.state = (IsValid(state) ? state : throw new …);
}
```

<span data-ttu-id="522d3-127">Durum değeri geçersizse, ilk adres satırı ve şehir zaten değiştirildi.</span><span class="sxs-lookup"><span data-stu-id="522d3-127">If the value of the state is invalid, the first address line and the city have already been changed.</span></span> <span data-ttu-id="522d3-128">Bu adres geçersiz hale getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="522d3-128">That might make the address invalid.</span></span>

<span data-ttu-id="522d3-129">Benzer bir yaklaşım oluşturulduktan sonra varlık geçerli olduğundan emin olmak için bir özel durum oluşturma varlığın oluşturucuda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="522d3-129">A similar approach can be used in the entity’s constructor, raising an exception to make sure that the entity is valid once it is created.</span></span>

### <a name="use-validation-attributes-in-the-model-based-on-data-annotations"></a><span data-ttu-id="522d3-130">Veri ek açıklamalarını dayalı modeli doğrulama öznitelikleri kullanma</span><span class="sxs-lookup"><span data-stu-id="522d3-130">Use validation attributes in the model based on data annotations</span></span>

<span data-ttu-id="522d3-131">Veri ek açıklamaları, ister gerekli veya MaxLength öznitelikleri kullanılabilir EF Core veritabanı alanı özelliklerini yapılandırmak için ayrıntılı olarak açıklandığı gibi [Tablo eşleme](infrastructure-persistence-layer-implemenation-entity-framework-core.md#table-mapping) bölümünde, ancak [varlık için artık çalıştıkları EF Core doğrulama](https://github.com/aspnet/EntityFrameworkCore/issues/3680) (diğerinden mu <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> yöntemi), bunlar bu yana EF yaptığınız gibi .NET Framework 4.x.</span><span class="sxs-lookup"><span data-stu-id="522d3-131">Data annotations, like the Required or MaxLength attributes, can be used to configure EF Core database field properties, as explained in detail in the [Table mapping](infrastructure-persistence-layer-implemenation-entity-framework-core.md#table-mapping) section, but [they no longer work for entity validation in EF Core](https://github.com/aspnet/EntityFrameworkCore/issues/3680) (neither does the <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> method), as they have done since EF 4.x in .NET Framework.</span></span>

<span data-ttu-id="522d3-132">Veri ek açıklamaları ve <xref:System.ComponentModel.DataAnnotations.IValidatableObject> arabirimi hala kullanılabilir modeli, önce denetleyicinin eylemleri çağırma zamanki, bağlama sırasında model doğrulama için ancak, model ViewModel veya DTO olacak şekilde tasarlanmıştır ve bir MVC veya API önemli bir etki alanı modeli sorun.</span><span class="sxs-lookup"><span data-stu-id="522d3-132">Data annotations and the <xref:System.ComponentModel.DataAnnotations.IValidatableObject> interface can still be used for model validation during model binding, prior to the controller’s actions invocation as usual, but that model is meant to be a ViewModel or DTO and that’s an MVC or API concern not a domain model concern.</span></span>

<span data-ttu-id="522d3-133">Temizle kavramsal fark yapılan veri ek açıklamaları kullanmaya devam edebilirsiniz ve `IValidatableObject` varlık sınıfında eylemlerinizi önerilmez bir varlık sınıfı nesne parametresi alırsanız doğrulama.</span><span class="sxs-lookup"><span data-stu-id="522d3-133">Having made the conceptual difference clear, you can still use data annotations and `IValidatableObject` in the entity class for validation, if your actions receive an entity class object parameter, which is not recommended.</span></span> <span data-ttu-id="522d3-134">Bu durumda, doğrulama, model bağlama, eylem çağırmadan önce bağlı gerçekleşir ve sonuç denetlemek için denetleyicinin ModelState.IsValid özelliğini kontrol edebilirsiniz ancak daha sonra tekrar önce varlık nesnesinde kalıcı değil denetleyicideki olur DbContext, olarak Bitti beri EF 4.x.</span><span class="sxs-lookup"><span data-stu-id="522d3-134">In that case, validation will occur upon model binding, just before invoking the action and you can check the controller’s ModelState.IsValid property to check the result, but then again, it happens in the controller, not before persisting the entity object in the DbContext, as it had done since EF 4.x.</span></span>

<span data-ttu-id="522d3-135">Veri ek açıklamalarını kullanma varlık sınıfında özel doğrulama yine de uygulayabilir ve `IValidatableObject.Validate` DbContext'ın SaveChanges yöntemini geçersiz kılma yöntemi,.</span><span class="sxs-lookup"><span data-stu-id="522d3-135">You can still implement custom validation in the entity class using data annotations and the `IValidatableObject.Validate` method, by overriding the DbContext’s SaveChanges method.</span></span>

<span data-ttu-id="522d3-136">Doğrulamak için bir örnek uygulamada gördüğünüz `IValidatableObject` varlıklarda [github'da bu açıklamayı](https://github.com/aspnet/EntityFrameworkCore/issues/3680#issuecomment-155502539).</span><span class="sxs-lookup"><span data-stu-id="522d3-136">You can see a sample implementation for validating `IValidatableObject` entities in [this comment on GitHub](https://github.com/aspnet/EntityFrameworkCore/issues/3680#issuecomment-155502539).</span></span> <span data-ttu-id="522d3-137">Bu örnek bir öznitelik tabanlı doğrulamaları işe yaramaz, ancak aynı geçersiz kılma seçeneğinde yansıma kullanarak uygulamak kolay olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="522d3-137">That sample doesn’t do attribute-based validations, but they should be easy to implement using reflection in the same override.</span></span>

<span data-ttu-id="522d3-138">Ancak, bir DDD açısından bakıldığında, etki alanı modeli en iyi, varlığın davranış yöntemlerini veya doğrulama kuralları uygulamak ve bildirim belirtim desenleri uygulayarak özel durumların kullanımını yalın tutulur.</span><span class="sxs-lookup"><span data-stu-id="522d3-138">However, from a DDD point of view, the domain model is best kept lean with the use of exceptions in your entity’s behavior methods, or by implementing the Specification and Notification patterns to enforce validation rules.</span></span>

<span data-ttu-id="522d3-139">Bu giriş, izin vermek için kullanıcı Arabirimi katman içinde model doğrulama kabul eder (yerine etki alanı varlıklarının) ViewModel sınıfları uygulama katmanında veri ek açıklamalarını kullanma anlamlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="522d3-139">It can make sense to use data annotations at the application layer in ViewModel classes (instead of domain entities) that will accept input, to allow for model validation within the UI layer.</span></span> <span data-ttu-id="522d3-140">Ancak, bu etki alanı modeli içinde doğrulama dışlama adresindeki yapılmalıdır değil.</span><span class="sxs-lookup"><span data-stu-id="522d3-140">However, this should not be done at the exclusion of validation within the domain model.</span></span>

### <a name="validate-entities-by-implementing-the-specification-pattern-and-the-notification-pattern"></a><span data-ttu-id="522d3-141">Varlıkları belirtimi desen ve bildirim deseni uygulayarak doğrula</span><span class="sxs-lookup"><span data-stu-id="522d3-141">Validate entities by implementing the Specification pattern and the Notification pattern</span></span>

<span data-ttu-id="522d3-142">Son olarak, etki alanı modeli içinde doğrulamaları uygulama bir daha ayrıntılı bildirim düzeni ile birlikte belirtimi desenini uygulama tarafından daha sonra listelenen ek kaynaklardan bazıları açıklandığı gibi yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="522d3-142">Finally, a more elaborate approach to implementing validations in the domain model is by implementing the Specification pattern in conjunction with the Notification pattern, as explained in some of the additional resources listed later.</span></span>

<span data-ttu-id="522d3-143">Ayrıca bu modelleri yalnızca biri kullanabileceğiniz bahseden değer olduğu — Örneğin, Denetim ifadeleri ile el ile doğrulama, ancak bildirim desenini kullanarak, yığın ve doğrulama hatalarının listesini döndürmek için.</span><span class="sxs-lookup"><span data-stu-id="522d3-143">It is worth mentioning that you can also use just one of those patterns—for example, validating manually with control statements, but using the Notification pattern to stack and return a list of validation errors.</span></span>

### <a name="use-deferred-validation-in-the-domain"></a><span data-ttu-id="522d3-144">Ertelenmiş doğrulama etki alanında kullanma</span><span class="sxs-lookup"><span data-stu-id="522d3-144">Use deferred validation in the domain</span></span>

<span data-ttu-id="522d3-145">Etki alanındaki ertelenmiş doğrulamaları uğraşmanız çeşitli yaklaşımlar vardır.</span><span class="sxs-lookup"><span data-stu-id="522d3-145">There are various approaches to deal with deferred validations in the domain.</span></span> <span data-ttu-id="522d3-146">Kendi kitaptaki [Implementing Domain-Driven tasarım](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vaughn Vernon bu bölümdeki doğrulamasını açıklar.</span><span class="sxs-lookup"><span data-stu-id="522d3-146">In his book [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vaughn Vernon discusses these in the section on validation.</span></span>

### <a name="two-step-validation"></a><span data-ttu-id="522d3-147">İki aşamalı doğrulama</span><span class="sxs-lookup"><span data-stu-id="522d3-147">Two-step validation</span></span>

<span data-ttu-id="522d3-148">Ayrıca, iki aşamalı doğrulama göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="522d3-148">Also consider two-step validation.</span></span> <span data-ttu-id="522d3-149">Alan düzeyindeki doğrulama komut veri aktarımı nesneleri (Dto) ve etki alanı düzeyinde doğrulama varlıklarınızı içinde kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="522d3-149">Use field-level validation on your command Data Transfer Objects (DTOs) and domain-level validation inside your entities.</span></span> <span data-ttu-id="522d3-150">Sonuç nesnesi yerine özel durumlar doğrulama hatalarla uğraşmak daha kolay hale getirmek için döndürerek bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="522d3-150">You can do this by returning a result object instead exceptions in order to make it easier to deal with the validation errors.</span></span>

<span data-ttu-id="522d3-151">Alan doğrulama ile veri ek açıklamaları kullanarak, örneğin, doğrulama tanımı yinelenen değil.</span><span class="sxs-lookup"><span data-stu-id="522d3-151">Using field validation with data annotations, for example, you do not duplicate the validation definition.</span></span> <span data-ttu-id="522d3-152">Yürütme hem sunucu tarafı ve istemci tarafı Dto'lar söz konusu olduğunda yine de olabilir (komutlar ve Viewmodel'lar, örneği için).</span><span class="sxs-lookup"><span data-stu-id="522d3-152">The execution, though, can be both server-side and client-side in the case of DTOs (commands and ViewModels, for instance).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="522d3-153">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="522d3-153">Additional resources</span></span>

- <span data-ttu-id="522d3-154">**Rachel Appel. ASP.NET Core MVC model doğrulama giriş** \\</span><span class="sxs-lookup"><span data-stu-id="522d3-154">**Rachel Appel. Introduction to model validation in ASP.NET Core MVC** \\</span></span>
  <https://docs.microsoft.com/aspnet/core/mvc/models/validation>

- <span data-ttu-id="522d3-155">**Rick Anderson. Doğrulama ekleme** \\</span><span class="sxs-lookup"><span data-stu-id="522d3-155">**Rick Anderson. Adding validation** \\</span></span>
  <https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation>

- <span data-ttu-id="522d3-156">**Martin Fowler. Doğrulamaları bildirimiyle özel durumları atma değiştirme** \\</span><span class="sxs-lookup"><span data-stu-id="522d3-156">**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations** \\</span></span>
  <https://martinfowler.com/articles/replaceThrowWithNotification.html>

- <span data-ttu-id="522d3-157">**Belirtimi ve bildirim desenleri** \\</span><span class="sxs-lookup"><span data-stu-id="522d3-157">**Specification and Notification Patterns** \\</span></span>
  <https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns>

- <span data-ttu-id="522d3-158">**Levası Gorodinski. Etki alanı Odaklı Tasarım (DDD) doğrulama** \\</span><span class="sxs-lookup"><span data-stu-id="522d3-158">**Lev Gorodinski. Validation in Domain-Driven Design (DDD)** \\</span></span>
  <http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/>

- <span data-ttu-id="522d3-159">**Colin Jack. Etki alanı Model doğrulama** \\</span><span class="sxs-lookup"><span data-stu-id="522d3-159">**Colin Jack. Domain Model Validation** \\</span></span>
  <https://colinjack.blogspot.com/2008/03/domain-model-validation.html>

- <span data-ttu-id="522d3-160">**Jimmy Bogard. DDD dünyasında doğrulama** \\</span><span class="sxs-lookup"><span data-stu-id="522d3-160">**Jimmy Bogard. Validation in a DDD world** \\</span></span>
  <https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/>

> [!div class="step-by-step"]
> <span data-ttu-id="522d3-161">[Önceki](enumeration-classes-over-enum-types.md)
> [İleri](client-side-validation.md)</span><span class="sxs-lookup"><span data-stu-id="522d3-161">[Previous](enumeration-classes-over-enum-types.md)
[Next](client-side-validation.md)</span></span>

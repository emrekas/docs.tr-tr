---
title: Bir mikro hizmete CQRS ve DDD desenlerini uygulama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmet mimarisi | CQRS ve DDD desenlerini arasındaki genel ilişki anlayın.
ms.date: 10/08/2018
ms.openlocfilehash: 36bffce37176aed6c7d9daea7f2995952b58e895
ms.sourcegitcommit: ffd7dd79468a81bbb0d6449f6d65513e050c04c4
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/21/2019
ms.locfileid: "65959379"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="94e2e-103">Bir mikro hizmet Basitleştirilmiş CQRS ve DDD desenlerini uygulama</span><span class="sxs-lookup"><span data-stu-id="94e2e-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="94e2e-104">CQRS için veri okuma ve yazma modelleri ayıran bir mimari modelidir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="94e2e-105">İlgili dönem [komut sorgu ayırma (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) ilk olarak nitelemiştir Bertrand Meyer tarafından tanımlanan *nesne yönelimli yazılım yapısına*.</span><span class="sxs-lookup"><span data-stu-id="94e2e-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="94e2e-106">Sistem işlemleri keskin ayrılmış iki alt kategorilere ayırabilirsiniz temel olur:</span><span class="sxs-lookup"><span data-stu-id="94e2e-106">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

- <span data-ttu-id="94e2e-107">Sorgular.</span><span class="sxs-lookup"><span data-stu-id="94e2e-107">Queries.</span></span> <span data-ttu-id="94e2e-108">Bu bir sonuç döndürür ve sistemin durumunu değiştirmeyin ve yan etkileri ücretsizdir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="94e2e-109">Komutları.</span><span class="sxs-lookup"><span data-stu-id="94e2e-109">Commands.</span></span> <span data-ttu-id="94e2e-110">Bu bir sistem durumunu değiştirin.</span><span class="sxs-lookup"><span data-stu-id="94e2e-110">These change the state of a system.</span></span>

<span data-ttu-id="94e2e-111">CQS olan basit bir kavram — aynı nesneye yöntemlerinde hakkındadır sorguları veya komutları oluşturuluyor.</span><span class="sxs-lookup"><span data-stu-id="94e2e-111">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="94e2e-112">Her bir yöntemin durumunu döndürür veya durumu, ancak ikisini birden değiştirdiği.</span><span class="sxs-lookup"><span data-stu-id="94e2e-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="94e2e-113">Hatta tek depo düzeni nesne CQS ile uyumlu.</span><span class="sxs-lookup"><span data-stu-id="94e2e-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="94e2e-114">Temel bir ilke CQS CQRS için kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="94e2e-115">[Komut ve sorgu sorumluluğu ayrımı (CQRS)](https://martinfowler.com/bliki/CQRS.html) Greg Young tarafından sunulan ve UDI Dahan ve başkaları tarafından kesinlikle yükseltildi.</span><span class="sxs-lookup"><span data-stu-id="94e2e-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="94e2e-116">Daha ayrıntılı rağmen CQS ilkesine temel alır.</span><span class="sxs-lookup"><span data-stu-id="94e2e-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="94e2e-117">Komutlar ve olayları ve isteğe bağlı olarak zaman uyumsuz iletiler alan bir deseni kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="94e2e-118">Çoğu durumda okuma (sorgular) için yazma işlemleri (güncelleştirmeler) için farklı bir fiziksel veritabanı sahip gibi daha gelişmiş senaryoları CQRS ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="94e2e-119">Ayrıca, daha fazla sistem gereksinimleri bir CQRS sistem uygulayabilir [olay kaynağını belirleme (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) güncelleştirmeleri veritabanınız için bu nedenle yalnızca depoladığınız olayları geçerli durumu verilerini depolamak yerine etki alanı modeli içinde.</span><span class="sxs-lookup"><span data-stu-id="94e2e-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="94e2e-120">Ancak, bu kılavuzda kullanılan yaklaşım değildir; sorguları komutlardan yalnızca ayırma oluşan basit CQRS yaklaşımı kullanıyoruz.</span><span class="sxs-lookup"><span data-stu-id="94e2e-120">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="94e2e-121">CQRS ayrımı yönüyle bir katmandaki sorgu işlemleri ve başka bir katmanda komutları gruplandırma tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="94e2e-121">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="94e2e-122">Her katmanın kendi veri modelinin (Not dediğimiz modeli, farklı bir veritabanı gerekmez) ve kendi birleşim desenleri ve teknolojiler kullanılarak oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="94e2e-122">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="94e2e-123">Daha da önemlisi, iki katman aynı katmandaki veya (mikro hizmet sıralama) örnekte olduğu gibi bu kılavuzda kullanılan mikro içinde olabilir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-123">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="94e2e-124">Veya en iyi duruma getirilmiş edilebilmeleri ve ayrı olarak başka bir etkilemeden ölçeği böylece bunlar farklı mikro hizmetler ve işlemlerde uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-124">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="94e2e-125">CQRS, diğer bağlamlarda var olduğu bir okuma/yazma işlemi için iki nesne olması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-125">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="94e2e-126">İçin daha gelişmiş CQRS belgelerinde hakkında bilgi edinebilirsiniz normalleştirilmişlikten çıkarılmış okuma veritabanının neden vardır.</span><span class="sxs-lookup"><span data-stu-id="94e2e-126">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="94e2e-127">Ancak burada, bu yaklaşımı hedef DDD deseni toplamalar gibi kısıtlamalardan sorgularla sınırlama yerine sorgularda daha fazla esnekliğe sahip olduğu kullanıyoruz değil.</span><span class="sxs-lookup"><span data-stu-id="94e2e-127">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="94e2e-128">Bu tür bir hizmeti hizmetine başvuru uygulamadaki sıralama mikro hizmet örneğidir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-128">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="94e2e-129">Bu hizmet, Basitleştirilmiş bir CQRS yaklaşımı tabanlı bir mikro hizmet uygular.</span><span class="sxs-lookup"><span data-stu-id="94e2e-129">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="94e2e-130">Tek bir veri kaynağı veya veritabanı, ancak iki mantıksal modellerini artı DDD deseni işlem etki alanı için Şekil 7-2'de gösterildiği gibi kullanır.</span><span class="sxs-lookup"><span data-stu-id="94e2e-130">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![Mantıksal sıralama mikro hizmet olabilir veya aynı Docker'da barındırma sipariş veritabanı içerir.](./media/image2.png)

<span data-ttu-id="94e2e-133">**Şekil 7-2**.</span><span class="sxs-lookup"><span data-stu-id="94e2e-133">**Figure 7-2**.</span></span> <span data-ttu-id="94e2e-134">CQRS ve DDD tabanlı mikro hizmet Basitleştirilmiş</span><span class="sxs-lookup"><span data-stu-id="94e2e-134">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="94e2e-135">Uygulama katmanı Web API'si olabilir.</span><span class="sxs-lookup"><span data-stu-id="94e2e-135">The application layer can be the Web API itself.</span></span> <span data-ttu-id="94e2e-136">Önemli tasarım burada mikro hizmet sorguları ve Viewmodel'lar (özellikle istemci uygulamaları için oluşturulan veri modelleri) bölündü komutlarını, etki alanı modeli ve CQRS modelinin aşağıdaki işlemleri yönüdür.</span><span class="sxs-lookup"><span data-stu-id="94e2e-136">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="94e2e-137">Bu yaklaşım sorguları sınırlamaları ve kısıtlamalar sonraki bölümlerde açıklandığı gibi işlemleri ve güncelleştirmeler için anlamlı yalnızca DDD deseni geldiğini bağımsız olarak korur.</span><span class="sxs-lookup"><span data-stu-id="94e2e-137">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="94e2e-138">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="94e2e-138">Additional resources</span></span>

- <span data-ttu-id="94e2e-139">**Greg Young. Bir olay kaynağı sistem sürümü oluşturma** (ücretsiz çevrimiçi e-kitabı okuyun) \\</span><span class="sxs-lookup"><span data-stu-id="94e2e-139">**Greg Young. Versioning in an Event Sourced System** (Free to read online e-book) \\</span></span>
   <https://leanpub.com/esversioning/read>

>[!div class="step-by-step"]
><span data-ttu-id="94e2e-140">[Önceki](index.md)
>[İleri](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="94e2e-140">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>

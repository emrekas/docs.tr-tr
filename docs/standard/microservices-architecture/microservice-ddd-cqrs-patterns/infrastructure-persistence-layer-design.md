---
title: Altyapı kalıcılık katmanını tasarlama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmet mimarisi | Depo düzeni altyapı Kalıcılık katmanını tasarımında keşfedin.
ms.date: 10/08/2018
ms.openlocfilehash: 76f545403a1b595ce7a541a96d212b9406d89c10
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/15/2019
ms.locfileid: "65644573"
---
# <a name="design-the-infrastructure-persistence-layer"></a><span data-ttu-id="15908-103">Altyapı Kalıcılık katmanını tasarlama</span><span class="sxs-lookup"><span data-stu-id="15908-103">Design the infrastructure persistence layer</span></span>

<span data-ttu-id="15908-104">Veri kalıcılığı bileşenleri (diğer bir deyişle, bir mikro hizmet ait veritabanı) bir mikro hizmet sınırları içinde tutulan verilere erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="15908-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="15908-105">Depoları gibi bileşenlerin gerçek uygulama içerdikleri ve [iş birimi](https://martinfowler.com/eaaCatalog/unitOfWork.html) sınıflar, özel Entity Framework (EF) gibi <xref:Microsoft.EntityFrameworkCore.DbContext> nesneleri.</span><span class="sxs-lookup"><span data-stu-id="15908-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span> <span data-ttu-id="15908-106">EF DbContext hem depoya hem de iş birimi desenleri uygular.</span><span class="sxs-lookup"><span data-stu-id="15908-106">EF DbContext implements both, the Repository and the Unit of Work patterns.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="15908-107">Depo düzeni</span><span class="sxs-lookup"><span data-stu-id="15908-107">The Repository pattern</span></span>

<span data-ttu-id="15908-108">Depoları, sınıfları veya veri kaynaklarına erişmek için gerekli mantığı kapsülleyen bileşenler olabilir.</span><span class="sxs-lookup"><span data-stu-id="15908-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="15908-109">Bunlar daha iyi sürdürülebilirliği sağlamak ve altyapı veya etki alanı modeli katmandan veritabanlarına erişmek için kullanılan teknoloji ayırma ortak veri erişimi işlevleri, tek bir merkezden yönetin.</span><span class="sxs-lookup"><span data-stu-id="15908-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="15908-110">Bir nesne-ilişkisel Eşleyici (ORM) Entity Framework gibi kullanmanız durumunda uygulanması gereken kod, LINQ ve güçlü yazım, yazım sayesinde basitleştirilir.</span><span class="sxs-lookup"><span data-stu-id="15908-110">If you use an Object-Relational Mapper (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="15908-111">Bu erişim tesisat veri kalıcılığı mantığı yerine veri çubuğunda odaklanmanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="15908-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="15908-112">Depo düzeni, bir veri kaynağı ile çalışmanın iyi belgelendirilmiş bir yoludur.</span><span class="sxs-lookup"><span data-stu-id="15908-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="15908-113">Kitaptaki [Kurumsal uygulama mimarisi desenleri](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler bir depo gibi açıklar:</span><span class="sxs-lookup"><span data-stu-id="15908-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="15908-114">Bir depo, bir etki alanı bir nesne bellekte benzer şekilde davranan bir aracı veri eşleme ve etki alanı modeli Katmanlar arasındaki görevleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="15908-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="15908-115">İstemci nesneleri bildirimli olarak sorgular oluşturabilir ve bunların yanıtlarını bulmak için de gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="15908-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="15908-116">Kavramsal olarak, bir depo sağlayarak Kalıcılık katman için daha yakın bir şekilde bunlar üzerinde gerçekleştirilen işlemleri ve veritabanı içinde depolanan nesneleri kümesini yalıtır.</span><span class="sxs-lookup"><span data-stu-id="15908-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="15908-117">Depoları, ayrıca, amacı, açıkça ve tek yönlü iş etki alanı ve veri ayırma arasındaki bağımlılığı ayırma veya eşleme, destekler.</span><span class="sxs-lookup"><span data-stu-id="15908-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="15908-118">Bir havuz başına toplam tanımlama</span><span class="sxs-lookup"><span data-stu-id="15908-118">Define one repository per aggregate</span></span>

<span data-ttu-id="15908-119">Her toplama ya da toplama kökü için bir depo sınıfına oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="15908-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="15908-120">Etki alanı Odaklı Tasarım (DDD) modellerini bir mikro hizmet içinde veritabanını güncellemek için kullanmalısınız yalnızca kanalı depoları olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="15908-120">In a microservice based on Domain-Driven Design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="15908-121">Toplam 's okuduğunuzda ve işlemsel tutarlılık denetimlerini toplama kök ile bire bir ilişki sahip oldukları budur.</span><span class="sxs-lookup"><span data-stu-id="15908-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="15908-122">Diğer ile veritabanını sorgulamak uygundur kanallar (bir CQRS yaklaşımı yapabilirsiniz gibi), çünkü sorguları veritabanının durumu değişmez.</span><span class="sxs-lookup"><span data-stu-id="15908-122">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="15908-123">Ancak, işlem alanı (diğer bir deyişle, güncelleştirmeleri) her zaman depolar ve toplama kökleri tarafından denetlenebilir.</span><span class="sxs-lookup"><span data-stu-id="15908-123">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="15908-124">Temel olarak, bir depo şeklinde etki alanı varlıklarının veritabanından gelen bellekteki verileri doldurmak sağlar.</span><span class="sxs-lookup"><span data-stu-id="15908-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="15908-125">Varlıkları bellekte eklendiğinde bunlar değiştirilebilir ve ardından aracılığıyla işlemleri veritabanına kalıcı.</span><span class="sxs-lookup"><span data-stu-id="15908-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="15908-126">CQS/CQRS mimari deseni ifade kullanıyorsanız, daha önce belirtildiği gibi ilk sorgu yan sorguları dışında Dapper kullanarak basit SQL deyimleri tarafından gerçekleştirilen etki alanı modeli tarafından gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="15908-126">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="15908-127">Bu yaklaşım depoları daha esnek olduğundan, sorgu ve tüm tabloları birleştirme gerekir ve bu sorguları kurallarıyla toplamlardan sınırlı olmayan çok daha fazla olur.</span><span class="sxs-lookup"><span data-stu-id="15908-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="15908-128">Bu verileri, sunu katmanı veya istemci uygulamaya gider.</span><span class="sxs-lookup"><span data-stu-id="15908-128">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="15908-129">Kullanıcı değişiklikleri yaparsa, güncelleştirilecek veriler istemci uygulaması veya sunu katmanı uygulama katmanına (örneğin, bir Web API'si hizmeti) gelir.</span><span class="sxs-lookup"><span data-stu-id="15908-129">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="15908-130">Komut işleyici bir komutunu aldığında, veritabanından güncelleştirmek istediğiniz veri almak için depoları kullanın.</span><span class="sxs-lookup"><span data-stu-id="15908-130">When you receive a command in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="15908-131">Bellekte komutlara geçirilen verileri ile güncelleştirmeniz ve sonra ekleyin veya bir işlem aracılığıyla veritabanındaki verilerle (etki alanı varlıklarının) güncelleştirin.</span><span class="sxs-lookup"><span data-stu-id="15908-131">You update it in memory with the data passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="15908-132">Bir depo için her bir toplama kökünde yalnızca tanımlamalıdır Şekil 7-17'de gösterildiği gibi yeniden vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="15908-132">It's important to emphasize again that you should only define one repository for each aggregate root, as shown in Figure 7-17.</span></span> <span data-ttu-id="15908-133">Toplama içindeki tüm nesneler arasında işlem tutarlılığını korumak için toplama köküne hedefe ulaşmak için hiçbir zaman her tablo için bir depo veritabanında oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="15908-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![Etki alanı ve altyapı Katmanlar arasındaki ilişkileri: Alıcı toplama üzerinde IBuyerRepository bağlıdır ve sipariş toplama IOrderRepository arabirimlere bağlıdır, bu arabirimler de var. uygulanan UnitOfWork üzerinde bağlı karşılık gelen depolara göre altyapı katmanında uygulanır, Veri katmanı tablolarında erişir.](./media/image18.png)

<span data-ttu-id="15908-135">**Şekil 7-17**.</span><span class="sxs-lookup"><span data-stu-id="15908-135">**Figure 7-17**.</span></span> <span data-ttu-id="15908-136">Depoları, toplamlar ve veritabanı tabloları arasındaki ilişki</span><span class="sxs-lookup"><span data-stu-id="15908-136">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforce-one-aggregate-root-per-repository"></a><span data-ttu-id="15908-137">Havuz başına bir toplama kök zorla</span><span class="sxs-lookup"><span data-stu-id="15908-137">Enforce one aggregate root per repository</span></span>

<span data-ttu-id="15908-138">Yalnızca toplama kökleri depoları olmalıdır kuralı zorlayan depo tasarımınızı şekilde uygulamak yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="15908-138">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="15908-139">Çalıştığını sahip olduklarından emin olmak için varlık türü kısıtlar bir genel veya taban depo türü oluşturabilirsiniz `IAggregateRoot` arabirim işaretçisi.</span><span class="sxs-lookup"><span data-stu-id="15908-139">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="15908-140">Bu nedenle, altyapı katmanında uygulanan her bir depo sınıfına aşağıdaki kodda gösterildiği gibi kendi sözleşme veya arabirim uygular:</span><span class="sxs-lookup"><span data-stu-id="15908-140">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="15908-141">Her depoyu arabirimi genel IRepository arabirim uygular:</span><span class="sxs-lookup"><span data-stu-id="15908-141">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="15908-142">Ancak, daha iyi bir yolu kuralı uygulamak için aşağıdaki kod her depo için tek bir toplamada ilişkilidir genel depo türü uygulamaktır.</span><span class="sxs-lookup"><span data-stu-id="15908-142">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="15908-143">Bu şekilde, belirli bir toplama hedeflemek için bir depo kullanmakta olduğunuz açıktır.</span><span class="sxs-lookup"><span data-stu-id="15908-143">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="15908-144">Kolayca yapılabilir genel uygulayarak `IRepository` aşağıdaki kodda gösterildiği gibi temel arabirim:</span><span class="sxs-lookup"><span data-stu-id="15908-144">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="15908-145">Depo düzeni uygulama mantığınızın test etmek kolaylaştırır</span><span class="sxs-lookup"><span data-stu-id="15908-145">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="15908-146">Depo düzeni kolayca birim testleriyle uygulamanızı test etmek sağlar.</span><span class="sxs-lookup"><span data-stu-id="15908-146">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="15908-147">Depo soyutlama bu hedefe ulaşmak kolaylaştırmak için birim testleri yalnızca kod, altyapıya değil, test etmenizi unutmayın.</span><span class="sxs-lookup"><span data-stu-id="15908-147">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="15908-148">Bir önceki bölümde belirtildiği gibi tanımlamak ve gibi Web API'si mikro hizmet uygulama katmanı doğrudan altyapı katmana bağlı olmayan şekilde deposu arabirimleri etki alanı model katmanında burada uyguladık yerleştirmeniz önerilir Gerçek depoyu sınıflar.</span><span class="sxs-lookup"><span data-stu-id="15908-148">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="15908-149">Bunun yapılması ve Web apı'nizin denetleyicileri bağımlılık ekleme kullanılarak veritabanından veri yerine sahte veriler döndürmek sahte depoları uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="15908-149">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="15908-150">Ayrılmış bu yaklaşım, veritabanı bağlantısını gerek kalmadan uygulamanızın mantığına odaklanan birim testleri oluşturma ve çalıştırma olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="15908-150">This decoupled approach allows you to create and run unit tests that focus the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="15908-151">Veritabanlarına bağlantı başarısız olabilir ve daha da önemlisi, testleri yüzlerce bir veritabanına yönelik olarak çalışan iki nedenden dolayı bozuk.</span><span class="sxs-lookup"><span data-stu-id="15908-151">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="15908-152">İlk olarak, uygulamanın çok sayıda testler nedeniyle uzun sürebilir.</span><span class="sxs-lookup"><span data-stu-id="15908-152">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="15908-153">İkinci olarak, veritabanı kayıtlarını bir değiştirme ve böylece bunlar tutarlı olmayabilir, testlerin sonuçları etkiler.</span><span class="sxs-lookup"><span data-stu-id="15908-153">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="15908-154">Veritabanına karşı test etme, birim testi ancak bir tümleştirme testini değildir.</span><span class="sxs-lookup"><span data-stu-id="15908-154">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="15908-155">Birçok birim testleri hızlı çalışıyor olması gerekir, ancak veritabanına göre daha az tümleştirme testleri.</span><span class="sxs-lookup"><span data-stu-id="15908-155">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="15908-156">Görev ayrımı nettir birim testleri için açısından, etki alanı varlıklarının bellekte mantığınızı çalışır.</span><span class="sxs-lookup"><span data-stu-id="15908-156">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="15908-157">Bu depo sınıfına Bu teslim ettiğini varsayar.</span><span class="sxs-lookup"><span data-stu-id="15908-157">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="15908-158">Etki alanı varlıklarının mantığınızı değiştirir sonra depo sınıfını bunları doğru bir şekilde depolar varsayar.</span><span class="sxs-lookup"><span data-stu-id="15908-158">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="15908-159">Burada önemli olan nokta, etki alanı modeliniz ve kendi etki alanı mantığı karşı birim testleri oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="15908-159">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="15908-160">Toplama kökleri DDD, ana tutarlılık sınırlarıdır.</span><span class="sxs-lookup"><span data-stu-id="15908-160">Aggregate roots are the main consistency boundaries in DDD.</span></span>

<span data-ttu-id="15908-161">Bu işlev yinelenen yoksa, değişiklik İzleyici kullanarak depo ve iş birimi desenleri DbContext uygulamasına EF Core'nın hizmetine içinde uygulanan depoları kullanır.</span><span class="sxs-lookup"><span data-stu-id="15908-161">The repositories implemented in eShopOnContainers rely on EF Core’s DbContext implementation of the Repository and Unit of Work patterns using its change tracker, so they don’t duplicate this functionality.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="15908-162">Depo düzeni ve eski veri erişim sınıfı (DAL sınıfı) deseni arasındaki fark</span><span class="sxs-lookup"><span data-stu-id="15908-162">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="15908-163">Veri erişim nesnesi doğrudan depolama karşı veri erişimi ve Kalıcılık işlemleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="15908-163">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="15908-164">İş nesnesi birimi bellekte gerçekleştirmek istediğiniz işlemleri verileri bir depo işaretler (EF kullanırken olduğu gibi <xref:Microsoft.EntityFrameworkCore.DbContext> sınıfı), ancak bu güncelleştirmeleri hemen veritabanına gerçekleştirilen değildir.</span><span class="sxs-lookup"><span data-stu-id="15908-164">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately to the database.</span></span>

<span data-ttu-id="15908-165">Bir iş birimi, birden çok ekleme içeren tek bir işlem olarak güncelleştirme veya silme işlemleri ifade edilir.</span><span class="sxs-lookup"><span data-stu-id="15908-165">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="15908-166">Basit bir deyişle, bir Web sitesinde bir kayıt gibi belirli bir kullanıcı eylemi için tüm ekleme, güncelleştirme ve silme işlemleri tek bir işlemde işlenme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="15908-166">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete operations are handled in a single transaction.</span></span> <span data-ttu-id="15908-167">Bu, birden çok veritabanı işlemleri chattier bir şekilde işleme değerinden daha verimli olur.</span><span class="sxs-lookup"><span data-stu-id="15908-167">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="15908-168">Bu uygulama katmanına kodunuzdan komutları kullanılırken bu birden çok Kalıcılık işlemleri daha sonra tek bir eylem içinde gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="15908-168">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="15908-169">Asıl veritabanı depolama alanı için bellek içi değişikliklerini uygulama hakkında karar genellikle dayanır [iş birimi deseni](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="15908-169">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="15908-170">EF, iş birimi deseni olarak uygulanan <xref:Microsoft.EntityFrameworkCore.DbContext>.</span><span class="sxs-lookup"><span data-stu-id="15908-170">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="15908-171">Çoğu durumda, bu desen veya depolama işlemleri uygulamanın yolu sağlayarak uygulama performansını artırıp tutarsızlıklar olasılığını azaltmak.</span><span class="sxs-lookup"><span data-stu-id="15908-171">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="15908-172">Hedeflenen tüm işlemler bir işlemin bir parçası olarak kaydedilmiş olduğundan veritabanı tablolarında engelleme işlem de azaltır.</span><span class="sxs-lookup"><span data-stu-id="15908-172">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="15908-173">Bu, birçok yalıtılmış işlemleri veritabanına karşı yürütme kıyasla daha verimli olur.</span><span class="sxs-lookup"><span data-stu-id="15908-173">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="15908-174">Bu nedenle, seçili ORM, birçok küçük ve ayrı işlem yürütmeleri aksine, aynı işlem içinde birkaç güncelleştirme eylemleri gruplandırarak veritabanına karşı yürütme iyileştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="15908-174">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="15908-175">Depoları zorunlu olmamalıdır</span><span class="sxs-lookup"><span data-stu-id="15908-175">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="15908-176">Özel depoları daha önce bahsedilen nedenlerle yararlıdır ve hizmetine sıralama mikro hizmet yaklaşımı olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="15908-176">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="15908-177">Ancak, bir DDD tasarım uygulayın ve hatta genel .NET geliştirme için temel bir desen değildir.</span><span class="sxs-lookup"><span data-stu-id="15908-177">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="15908-178">Örneğin, Jimmy bu kılavuz için doğrudan geri bildirim sağlanırken Bogard aşağıdaki söylenebilir:</span><span class="sxs-lookup"><span data-stu-id="15908-178">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="15908-179">Bu, büyük olasılıkla büyük bildirimimi olacaktır.</span><span class="sxs-lookup"><span data-stu-id="15908-179">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="15908-180">Çoğunlukla, temel alınan kalıcılığı mekanizmasının önemli ayrıntıları gizlemek için gerçekten bir sporseverseniz, depolarının değilim.</span><span class="sxs-lookup"><span data-stu-id="15908-180">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="15908-181">Cihazın neden MediatR için komutlar için çok ederim.</span><span class="sxs-lookup"><span data-stu-id="15908-181">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="15908-182">Ben Kalıcılık katman tam gücünden yararlanın ve bu etki alanı davranışını my toplama kökleri anında iletme.</span><span class="sxs-lookup"><span data-stu-id="15908-182">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="15908-183">Genellikle my depoları sahte istemiyorum – miyim tümleştirme gereken gerçek bir şey ile test.</span><span class="sxs-lookup"><span data-stu-id="15908-183">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="15908-184">CQRS devam ediyoruz gerçekten depoları gereksinimini artık yoktu, geliyordu.</span><span class="sxs-lookup"><span data-stu-id="15908-184">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="15908-185">Depoları yararlı olabilir, ancak bunlar toplama düzeni ve zengin bir etki alanı modeli şekilde DDD tasarımınız için kritik değildir.</span><span class="sxs-lookup"><span data-stu-id="15908-185">Repositories might be useful, but they are not critical for your DDD design, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="15908-186">Bu nedenle, depo deseni kullanıp, uygun şekilde.</span><span class="sxs-lookup"><span data-stu-id="15908-186">Therefore, use the Repository pattern or not, as you see fit.</span></span> <span data-ttu-id="15908-187">Yine de, bu durumda, deponun tüm mikro hizmet ele alınmaktadır ancak EF Core kullandığınızda depo düzeni kullanmaya başlayacağınız veya içerik sınırlanmış.</span><span class="sxs-lookup"><span data-stu-id="15908-187">Anyway, you’ll be using the repository pattern whenever you use EF Core although, in this case, the repository covers the whole microservice or bounded context.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="15908-188">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="15908-188">Additional resources</span></span>

### <a name="repository-pattern"></a><span data-ttu-id="15908-189">Depo düzeni</span><span class="sxs-lookup"><span data-stu-id="15908-189">Repository pattern</span></span>

- <span data-ttu-id="15908-190">**Depo düzeni** \\</span><span class="sxs-lookup"><span data-stu-id="15908-190">**The Repository pattern** \\</span></span>
  <https://deviq.com/repository-pattern/>

- <span data-ttu-id="15908-191">**Edward Hieatt ve Rob bana. Depo deseni.**</span><span class="sxs-lookup"><span data-stu-id="15908-191">**Edward Hieatt and Rob Mee. Repository pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/repository.html>

- <span data-ttu-id="15908-192">**Depo düzeni** \\</span><span class="sxs-lookup"><span data-stu-id="15908-192">**The Repository pattern** \\</span></span>
  <https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)>

- <span data-ttu-id="15908-193">**Eric Evans. Etki alanı Odaklı Tasarım: Kuruluşlarda karmaşık yazılım kalbidir.**</span><span class="sxs-lookup"><span data-stu-id="15908-193">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="15908-194">(Kitap; depo düzeni hakkında ayrıntılı bilgi içerir) \\</span><span class="sxs-lookup"><span data-stu-id="15908-194">(Book; includes a discussion of the Repository pattern) \\</span></span>
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="15908-195">Çalışma deseni birimi</span><span class="sxs-lookup"><span data-stu-id="15908-195">Unit of Work pattern</span></span>

- <span data-ttu-id="15908-196">**Martin Fowler. Çalışma deseni birimidir.**</span><span class="sxs-lookup"><span data-stu-id="15908-196">**Martin Fowler. Unit of Work pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/unitOfWork.html>

- <span data-ttu-id="15908-197">**Bir ASP.NET MVC uygulamasındaki depo ve iş birimi desenleri uygulama** \\</span><span class="sxs-lookup"><span data-stu-id="15908-197">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application** \\</span></span>
  <https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application>

>[!div class="step-by-step"]
><span data-ttu-id="15908-198">[Önceki](domain-events-design-implementation.md)
>[İleri](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="15908-198">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>

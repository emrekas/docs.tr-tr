---
title: Mimari ilkeleri
description: ASP.NET Core ve Azure ile modern Web uygulamaları tasarlama | Mimari ilkeleri
author: ardalis
ms.author: wiwagn
ms.date: 02/16/2019
ms.openlocfilehash: 74ff7196ce17807b98a975687a524041f15a7f5b
ms.sourcegitcommit: 7f616512044ab7795e32806578e8dc0c6a0e038f
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/10/2019
ms.locfileid: "67775892"
---
# <a name="architectural-principles"></a><span data-ttu-id="ca341-103">Mimari ilkeleri</span><span class="sxs-lookup"><span data-stu-id="ca341-103">Architectural principles</span></span>

> <span data-ttu-id="ca341-104">"Oluşturucular binalar oluşturulduysa şekilde programcılar programları yazdığı ve sonra gelen boyunca ilk woodpecker civilization yok etmek."</span><span class="sxs-lookup"><span data-stu-id="ca341-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="ca341-105">_\- Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="ca341-105">_\- Gerald Weinberg_</span></span>

<span data-ttu-id="ca341-106">Mimari ve yazılım çözümlerini unutmayın yaşatılabilirlik tasarımımız gerekir.</span><span class="sxs-lookup"><span data-stu-id="ca341-106">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="ca341-107">Bu bölümde açıklanan ilkeleri temiz ve sürdürülebilir uygulamalarda neden olabilecek mimari kararları doğru yol yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="ca341-107">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="ca341-108">Genellikle, bu ilkeler, uygulamanızın diğer kısımlarına sıkı şekilde bağlı değildir, ancak bunun yerine açık arabirim ile iletişim kurmak ayrı bileşenler dışında uygulamalar oluşturmak veya Mesajlaşma sistemleri doğru size yol gösterir.</span><span class="sxs-lookup"><span data-stu-id="ca341-108">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="ca341-109">Ortak tasarım ilkeleri</span><span class="sxs-lookup"><span data-stu-id="ca341-109">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="ca341-110">Görev ayrımı nettir</span><span class="sxs-lookup"><span data-stu-id="ca341-110">Separation of concerns</span></span>

<span data-ttu-id="ca341-111">Geliştirirken bir yol gösterici ilkesidir **ayrımı, ile ilgili sorunlar**.</span><span class="sxs-lookup"><span data-stu-id="ca341-111">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="ca341-112">Bu ilke, yazılım ayrılmalıdır gerçekleştirdiği iş türlerine göre onaylar.</span><span class="sxs-lookup"><span data-stu-id="ca341-112">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="ca341-113">Örneğin, kullanıcıya görüntülenecek önemli öğeleri tanımlamak için mantığı içeren ve hangi gibi öğeleri daha belirgin hale getirmek için belirli bir şekilde biçimlendiren bir uygulamayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="ca341-113">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="ca341-114">Biçimlendirmek için hangi öğe seçmek için sorumlu davranışı, davranış öğeleri biçimlendirme bunlar yalnızca tesadüfen birbirleriyle ilişkili ayrı endişeleriniz olduğu için sorumlu ayrı tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-114">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="ca341-115">Bu mimari, uygulama altyapısı ve kullanıcı arabirimi mantığının çekirdek iş davranışı ayırarak Bu ilkeyi izlemek için mantıksal olarak oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="ca341-115">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="ca341-116">İdeal olarak, iş kuralları ve mantıksal uygulamanın diğer projelerde bağlı olmamalıdır ayrı bir proje içinde bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-116">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="ca341-117">Bu iş modeli kolay olduğundan emin olun yardımcı olur. test ve alt düzey uygulama ayrıntıları sıkıca olmadan geliştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ca341-117">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="ca341-118">Görev ayrımı nettir bir anahtar kullanımı arkasındaki uygulama mimarileri katmanlarında, noktadır.</span><span class="sxs-lookup"><span data-stu-id="ca341-118">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="ca341-119">Kapsülleme</span><span class="sxs-lookup"><span data-stu-id="ca341-119">Encapsulation</span></span>

<span data-ttu-id="ca341-120">Bir uygulamanın farklı kısımlarını kullanması gereken **kapsülleme** bunları uygulamanın diğer kısımlarından sorunlardan uzak tutmak için.</span><span class="sxs-lookup"><span data-stu-id="ca341-120">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="ca341-121">Uygulama bileşenleri ve Katmanlar dış sözleşmeleri ihlal değil sürece kendi ortak çalışanlar bozmadan kendi iç uygulama ayarlayabilmeniz için olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-121">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="ca341-122">Kapsülleme kullanımını nesneleri ve paketleri aynı arabirimi korunur sürece diğer uygulamaları ile değiştirilebilir beri gevşek eşleştirme ve modülerlik uygulama tasarımlarında elde etmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="ca341-122">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="ca341-123">Sınıflarda, kapsülleme dışında sınıfın iç durumu erişimi kısıtlayarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="ca341-123">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="ca341-124">Nesne durumunu işlemek bir dış aktör isterse, bunu bir iyi tanımlanmış işlevi (veya özellik ayarlayıcısı), doğrudan erişim nesnenin özel durumu yerine bunu.</span><span class="sxs-lookup"><span data-stu-id="ca341-124">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="ca341-125">Benzer şekilde, uygulama bileşenlerini ve uygulamaların kendileri için kendi ortak çalışanlarla durumlarına doğrudan değiştirilmesine izin verme yerine kullanmak iyi tanımlanmış arabirimlere sunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-125">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="ca341-126">Bu uygulamanın ortak sözleşmeleri korunur sürece bunu yapmak, ortak çalışanlar, bu nedenle kesintiye uğrar endişelenmeden zamanla gelişmesinin iç tasarım serbest bırakır.</span><span class="sxs-lookup"><span data-stu-id="ca341-126">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="ca341-127">Bağımlılık tersine çevirme</span><span class="sxs-lookup"><span data-stu-id="ca341-127">Dependency inversion</span></span>

<span data-ttu-id="ca341-128">Uygulama Bağımlılık yönünü soyutlama, uygulama ayrıntıları yönü olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ca341-128">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="ca341-129">Çoğu uygulama, derleme zamanı bağımlılık çalışma zamanı yürütme yönde aktığını şekilde yazılır.</span><span class="sxs-lookup"><span data-stu-id="ca341-129">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="ca341-130">Bu, doğrudan bir bağımlılık grafiği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="ca341-130">This produces a direct dependency graph.</span></span> <span data-ttu-id="ca341-131">Diğer bir deyişle, C modülü ve ardından derleme zamanı A, bir işlev çağıran modülü bir çağrıları işlevi B, modüldeki bir C, Şekil 4-1'de gösterildiği gibi bağlıdır B bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-131">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="ca341-132">**Şekil 4-1.**</span><span class="sxs-lookup"><span data-stu-id="ca341-132">**Figure 4-1.**</span></span> <span data-ttu-id="ca341-133">Doğrudan bir bağımlılık grafiği.</span><span class="sxs-lookup"><span data-stu-id="ca341-133">Direct dependency graph.</span></span>

<span data-ttu-id="ca341-134">Bağımlılık tersine çevirme ilkesinin uygulanması için çalışma zamanında, B çağrısına çözmelerine B uygulayan bir Özet yöntemleri çağırmak bir ancak bir arabirimde bağımlı b tarafından bir derleme zamanında denetlenen (Bu nedenle, *ters çevirme* Tipik derleme zamanı bağımlılık).</span><span class="sxs-lookup"><span data-stu-id="ca341-134">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="ca341-135">Çalışma zamanında, program yürütmenin akışını değişmeden kalır, ancak bu arabirimin farklı uygulamalarını kolayca uygulamalarınıza, arabirimleri kullanıma sunulması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="ca341-135">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="ca341-136">**Şekil 4-2.**</span><span class="sxs-lookup"><span data-stu-id="ca341-136">**Figure 4-2.**</span></span> <span data-ttu-id="ca341-137">Ters bağımlılık grafiği.</span><span class="sxs-lookup"><span data-stu-id="ca341-137">Inverted dependency graph.</span></span>

<span data-ttu-id="ca341-138">**Bağımlılık tersine çevirme** bağlıdır ve geçici olarak başka bir şekilde yerine daha yüksek düzey soyutlamalar uygulamak için uygulama ayrıntılarını yazılabilir olduğundan zamanı gevşek bağlanmış, uygulamaları oluşturmak, önemli bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-138">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="ca341-139">Sonuçta elde edilen sonuç olarak daha fazla test edilebilir, modüler ve sürdürülebilir uygulamalardır.</span><span class="sxs-lookup"><span data-stu-id="ca341-139">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="ca341-140">Uygulaması *bağımlılık ekleme* bağımlılık tersine çevirme ilkesi uygulayarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="ca341-140">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="ca341-141">Özel bağımlılıklar</span><span class="sxs-lookup"><span data-stu-id="ca341-141">Explicit dependencies</span></span>

<span data-ttu-id="ca341-142">**Açıkça düzgün çalışması için ihtiyaç duydukları tüm birlikte çalışan nesnelerin yöntemleri ve sınıfları istemeniz gerekir.**</span><span class="sxs-lookup"><span data-stu-id="ca341-142">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="ca341-143">Sınıf oluşturucuları, geçerli bir durumda olması ve düzgün şekilde çalışabilmesi için gereksinim duydukları şeyleri tanımlamak sınıflar için bir fırsattır.</span><span class="sxs-lookup"><span data-stu-id="ca341-143">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="ca341-144">Sınıflar, kullanılabilir oluşturulur ve çağrılır, ancak, yalnızca çalışır düzgün belirli genel ya da altyapı bileşenlerini bulunmuyorsa tanımlarsanız, bu sınıflar gönderildiğini *yapan dürüst olmayan* istemcileri ile.</span><span class="sxs-lookup"><span data-stu-id="ca341-144">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="ca341-145">Yalnızca belirtilen noktalar (muhtemelen hiçbir şey sınıf parametresiz bir oluşturucu yalnızca kullanıyorsa), ancak ardından nesne kapatır çalışma zamanında gereken istemci gerçekten başka bir şey ihtiyaç duyduklarından Oluşturucu anlaşması söylüyor.</span><span class="sxs-lookup"><span data-stu-id="ca341-145">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a parameterless constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="ca341-146">Özel bağımlılıklar ilkesi uygulayarak, sınıflar ve yöntemler çalışabilmesi için gereksinim duydukları şeyleri hakkında istemcileri ile dürüst yükleniyor.</span><span class="sxs-lookup"><span data-stu-id="ca341-146">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="ca341-147">Bu, kendi kendine daha fazla tanım kodunuzu sağlar ve kullanıcılara, sağladıkları yöntemi biçiminde gerekli olduğu sürece bu güven için gelir beri kodlamanızı daha kullanıcı dostu sözleşmeleri veya Oluşturucu parametresi, üzerinde çalıştığınız nesneleri farklı mı davranacak doğru çalışma zamanında.</span><span class="sxs-lookup"><span data-stu-id="ca341-147">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="ca341-148">Tek sorumluluk</span><span class="sxs-lookup"><span data-stu-id="ca341-148">Single responsibility</span></span>

<span data-ttu-id="ca341-149">Tek sorumluluk ilkesini nesne yönelimli tasarım için geçerlidir, ancak ayrımı için benzer bir mimari prensibi olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="ca341-149">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="ca341-150">Bu nesneler yalnızca bir sorumluluk olmalıdır ve değiştirmek için yalnızca bir neden olması gerektiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="ca341-150">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="ca341-151">Özellikle, nesneyi değiştirmek tek bir sorumluluğunu gerçekleştirir şekilde güncelleştirilmelidir durumdur.</span><span class="sxs-lookup"><span data-stu-id="ca341-151">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="ca341-152">Bu ilke aşağıdaki daha üretmeye yardımcı zamanı gevşek bağlanmış ve modüler sistemleri, pek çok yeni davranış beri yeni sınıflar olarak yerine varolan sınıflara ek sorumluluk ekleyerek uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="ca341-152">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="ca341-153">Yeni sınıflar ekleyerek her zaman mevcut sınıfları bu yana hiçbir kodunun değiştirilmesi daha güvenlidir, ancak yeni sınıflarında bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-153">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="ca341-154">Tek parçalı bir uygulamada uygulama katmanlarında size yüksek bir düzeyde tek sorumluluk ilke uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ca341-154">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="ca341-155">Sunu sorumluluk UI projede kalmalıdır, sorumluluk veri erişirken bir altyapı projesi içinde tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-155">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="ca341-156">İş mantığını burada kolayca sınanabilir ve bağımsız olarak diğer sorumluluklarını geliştirebilirsiniz uygulama core projesinde tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-156">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="ca341-157">Bu ilkeyi uygulama mimarisi için uygulanan ve mantıksal bitim geçen, mikro hizmetler alın.</span><span class="sxs-lookup"><span data-stu-id="ca341-157">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="ca341-158">Belirli bir mikro hizmet tek bir sorumluluğa sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-158">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="ca341-159">Bir sistemi davranışını genişletmeniz gerekiyorsa, ek bir mikro hizmetler ekleyerek yerine var olan bir sorumluluğu ekleme yapmak genellikle daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="ca341-159">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="ca341-160">Mikro hizmet mimarisi hakkında daha fazla bilgi edinin</span><span class="sxs-lookup"><span data-stu-id="ca341-160">Learn more about microservices architecture</span></span>](https://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="ca341-161">Kendiniz (KURU) yineleme</span><span class="sxs-lookup"><span data-stu-id="ca341-161">Don't repeat yourself (DRY)</span></span>

<span data-ttu-id="ca341-162">Uygulama, bu hata sık kullanılan bir kaynak olarak belirli bir kavram birden çok yerde ilgili davranışını belirtme kaçınmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="ca341-162">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="ca341-163">Belirli bir noktada bu davranışı ve olasılığını değiştirme gereksinimleri değişikliği gerektirecek davranışı en az bir örneğini güncelleştirilmesi başarısız olur sistemin tutarsız davranışa neden.</span><span class="sxs-lookup"><span data-stu-id="ca341-163">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="ca341-164">Mantıksal çoğaltmak yerine bir programlama yapısı içinde kapsüller.</span><span class="sxs-lookup"><span data-stu-id="ca341-164">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="ca341-165">Bu tek yetkilisi bu davranışı oluşturmak ve bu davranışı kullanım yeni yapısı gerektiren bir uygulama, diğer herhangi bir bölümünü sahip olun.</span><span class="sxs-lookup"><span data-stu-id="ca341-165">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="ca341-166">Yalnızca tesadüfen yinelenen davranışı birbirine bağlayan kaçının.</span><span class="sxs-lookup"><span data-stu-id="ca341-166">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="ca341-167">Yalnızca iki farklı sabitleri hem aynı değere sahip olduğundan, kavramsal olarak bunlar için farklı şeyler başvuruyorsanız gibi yalnızca bir sabit olmalıdır anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="ca341-167">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="ca341-168">Kalıcılık ignorance</span><span class="sxs-lookup"><span data-stu-id="ca341-168">Persistence ignorance</span></span>

<span data-ttu-id="ca341-169">**Kalıcılık ignorance** kalıcı gereken, ancak kodu Kalıcılık teknoloji seçimi tarafından etkilenmemesini türleri (PI) ifade eder.</span><span class="sxs-lookup"><span data-stu-id="ca341-169">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="ca341-170">Belirli bir taban sınıftan devralın ya da belirli bir arabirim uygulamak gerekmez çünkü. NET'te böyle türleri bazen için düz eski CLR nesneleri (POCOs) denir.</span><span class="sxs-lookup"><span data-stu-id="ca341-170">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="ca341-171">Uygulamaya daha fazla esneklik sunan birden çok yolla kalıcı aynı iş modeli izin verdiğinden, Kalıcılık ignorance değerlidir.</span><span class="sxs-lookup"><span data-stu-id="ca341-171">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="ca341-172">Kalıcılık seçenekler, başka bir veritabanı teknolojisine zaman içinde değişebilir veya başka biçimlerde Kalıcılık ne olursa olsun uygulama kullanmaya ek olarak gerekli olabilir (örneğin, bir Redis önbelleği veya ek olarak Azure DocumentDb kullanarak bir ilişkisel veritabanı).</span><span class="sxs-lookup"><span data-stu-id="ca341-172">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="ca341-173">Bu ilke ihlallerini bazı örnekleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="ca341-173">Some examples of violations of this principle include:</span></span>

- <span data-ttu-id="ca341-174">Gerekli bir temel sınıf.</span><span class="sxs-lookup"><span data-stu-id="ca341-174">A required base class.</span></span>

- <span data-ttu-id="ca341-175">Bir gerekli arabirim uygulaması.</span><span class="sxs-lookup"><span data-stu-id="ca341-175">A required interface implementation.</span></span>

- <span data-ttu-id="ca341-176">Sınıflar (etkin kayıt düzeni gibi) kaydetmek için kendileri sorumludur.</span><span class="sxs-lookup"><span data-stu-id="ca341-176">Classes responsible for saving themselves (such as the Active Record pattern).</span></span>

- <span data-ttu-id="ca341-177">Parametresiz oluşturucu gereklidir.</span><span class="sxs-lookup"><span data-stu-id="ca341-177">Required parameterless constructor.</span></span>

- <span data-ttu-id="ca341-178">Sanal anahtar sözcük gerektiren özellikleri.</span><span class="sxs-lookup"><span data-stu-id="ca341-178">Properties requiring virtual keyword.</span></span>

- <span data-ttu-id="ca341-179">Kalıcı özel özniteliklerini gereklidir.</span><span class="sxs-lookup"><span data-stu-id="ca341-179">Persistence-specific required attributes.</span></span>

<span data-ttu-id="ca341-180">Sınıfları yukarıdaki özellikleri veya davranışlardan birini olma gereksinimini kalıcı için türleri ve gelecekte yeni veri erişim stratejilerini benimseyen daha zor hale getirme, Kalıcılık teknoloji seçimi arasında eşleştirme yapmaktan ekler.</span><span class="sxs-lookup"><span data-stu-id="ca341-180">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="ca341-181">Sınırlanmış bağlamlar</span><span class="sxs-lookup"><span data-stu-id="ca341-181">Bounded contexts</span></span>

<span data-ttu-id="ca341-182">**Sınırlanmış Bağlamlar** merkezi bir etki alanı Odaklı Tasarım deseninde olan.</span><span class="sxs-lookup"><span data-stu-id="ca341-182">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="ca341-183">Bunlar, ayrı kavramsal modüllerine bozucu tarafından kuruluşlarda karmaşıklık büyük uygulamalar veya kuruluşların bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="ca341-183">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="ca341-184">Kavramsal modüllerin sonra diğer bağlamlarda ayrılmış bir bağlamı temsil eder (Bu nedenle, sınırlanmış) ve bağımsız olarak geliştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ca341-184">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="ca341-185">Sınırlanmış her bağlam ideal içindeki kavramları kendi adları seçebilirsiniz olmalıdır ve özel erişim kendi deposuna sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ca341-185">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="ca341-186">En azından web uygulamalarının bir veritabanını başka uygulamalarla paylaşma yerine kendi iş modeli için kendi sürdürme deposundan ile kendi sınırlanmış bağlam olması için çaba göstermelisiniz.</span><span class="sxs-lookup"><span data-stu-id="ca341-186">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="ca341-187">Sınırlanmış Bağlamlar arasında iletişimi sağlayan iş mantığı için paylaşılan bir veritabanı üzerinden değil, programlama arabirimleri aracılığıyla gerçekleşir ve gerçekleşmesi değişikliklere yanıt olarak gerçekleştirilecek olayları yerleştirin.</span><span class="sxs-lookup"><span data-stu-id="ca341-187">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="ca341-188">Ayrıca, kendi ayrı bir sınırlanmış Bağlamlar ideal olarak uygulanan mikro hizmetlere bağlamları harita yakından sınırlanmış.</span><span class="sxs-lookup"><span data-stu-id="ca341-188">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ca341-189">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="ca341-189">Additional resources</span></span>

* [<span data-ttu-id="ca341-190">JAVA tasarım desenleri: İlkeleri</span><span class="sxs-lookup"><span data-stu-id="ca341-190">JAVA Design Patterns: Principles</span></span>](https://java-design-patterns.com/principles/)
* [<span data-ttu-id="ca341-191">Sınırlanmış bağlam</span><span class="sxs-lookup"><span data-stu-id="ca341-191">Bounded Context</span></span>](https://martinfowler.com/bliki/BoundedContext.html)

>[!div class="step-by-step"]
><span data-ttu-id="ca341-192">[Önceki](choose-between-traditional-web-and-single-page-apps.md)
>[İleri](common-web-application-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="ca341-192">[Previous](choose-between-traditional-web-and-single-page-apps.md)
[Next](common-web-application-architectures.md)</span></span>

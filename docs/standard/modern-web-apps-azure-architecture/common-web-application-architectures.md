---
title: Ortak web uygulaması mimarileri
description: ASP.NET Core ve Azure ile modern Web uygulamaları tasarlama | Ortak web uygulaması mimarileri keşfedin
author: ardalis
ms.author: wiwagn
ms.date: 01/30/2019
ms.openlocfilehash: 22cb673f09faf7b0eabcfa5b3f6700d33242d84b
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/08/2019
ms.locfileid: "59122700"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="13fec-103">Ortak web uygulaması mimarileri</span><span class="sxs-lookup"><span data-stu-id="13fec-103">Common web application architectures</span></span>

> <span data-ttu-id="13fec-104">"İyi olabileceğini düşünüyorsanız mimarisi pahalıdır, hatalı mimarisi deneyin."</span><span class="sxs-lookup"><span data-stu-id="13fec-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> _<span data-ttu-id="13fec-105">-Brian alt ve Joseph Yoder</span><span class="sxs-lookup"><span data-stu-id="13fec-105">- Brian Foote and Joseph Yoder</span></span>_

<span data-ttu-id="13fec-106">Çoğu geleneksel .NET uygulamaları, bir yürütülebilir dosyası ya da tek bir IIS appdomain içinde çalışan tek bir web uygulaması için karşılık gelen bir tek birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="13fec-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="13fec-107">Bu en basit dağıtım modelidir ve çoğu iç ve daha küçük genel uygulama çok iyi işlevi görür.</span><span class="sxs-lookup"><span data-stu-id="13fec-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="13fec-108">Ancak, bile bu tekli ünite dağıtımının göz önünde bulundurulduğunda, en Önemsiz olmayan bir iş kolu uygulamaları birkaç katmanlara bazı mantıksal ayrılığı yararlanın.</span><span class="sxs-lookup"><span data-stu-id="13fec-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="13fec-109">Tek parça bir uygulamayı nedir?</span><span class="sxs-lookup"><span data-stu-id="13fec-109">What is a monolithic application?</span></span>

<span data-ttu-id="13fec-110">Tek parça bir uygulamayı, davranışı bakımından tamamen kendi içinde yer alan, biridir.</span><span class="sxs-lookup"><span data-stu-id="13fec-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="13fec-111">Kendi işlemleri sırasında diğer hizmetleri ya da veri depoları ile etkileşimde bulunabilir, ancak davranışını setinin kendi işlemi içinde çalıştırılan ve tüm uygulama genellikle tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="13fec-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="13fec-112">Genellikle bu tür bir uygulama, yatay olarak genişletmek gerekiyorsa, tüm uygulama birden fazla sunucu veya sanal makineler arasında çoğaltılır.</span><span class="sxs-lookup"><span data-stu-id="13fec-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="13fec-113">Hepsi bir arada uygulamalar</span><span class="sxs-lookup"><span data-stu-id="13fec-113">All-in-one applications</span></span>

<span data-ttu-id="13fec-114">Projelerin bir uygulama mimarisi için olası en küçük sayı biridir.</span><span class="sxs-lookup"><span data-stu-id="13fec-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="13fec-115">Bu mimaride, uygulamanın tamamını mantıksal tek bir projede yer alan, tek bir bütünleştirilmiş kod derlenir ve tek bir birim olarak dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="13fec-116">Yeni bir ASP.NET Core proje Visual Studio'da ya da komut satırından oluşturmadığımız basit bir "hepsi bir arada özellikli" tek başlar.</span><span class="sxs-lookup"><span data-stu-id="13fec-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="13fec-117">Tüm sunu, iş ve veri erişim mantığı da dahil olmak üzere uygulama davranışını içerir.</span><span class="sxs-lookup"><span data-stu-id="13fec-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="13fec-118">Şekil 5-1 tek proje uygulamanın dosya yapısı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="13fec-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![](./media/image5-1.png)

**<span data-ttu-id="13fec-119">Şekil 5-1.</span><span class="sxs-lookup"><span data-stu-id="13fec-119">Figure 5-1.</span></span>** <span data-ttu-id="13fec-120">Tek proje ASP.NET Core uygulaması.</span><span class="sxs-lookup"><span data-stu-id="13fec-120">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="13fec-121">Tek bir projede bir senaryoda, görev ayrımı nettir klasörleri kullanılarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-121">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="13fec-122">Varsayılan şablonu, veri ve hizmetler için ayrı klasörlerini modelleri, görünümleri ve denetleyicileri MVC düzeni sorumluluklarını yanı sıra, ek klasörleri içerir.</span><span class="sxs-lookup"><span data-stu-id="13fec-122">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="13fec-123">Bu düzenleme sunu Ayrıntılar görünümleri klasörüne mümkün olduğunca sınırlı ve veri erişim uygulama ayrıntılarını sınıfları veri klasöründe tutulan sınırlı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-123">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="13fec-124">İş mantığı Hizmetleri ve modeller klasörü içindeki sınıflarda yer almalıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-124">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="13fec-125">Basit olsa da, tek proje tek parça çözüm bazı dezavantajlara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="13fec-125">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="13fec-126">Proje boyutu ve karmaşıklığı arttıkça, dosya ve klasörlerin sayısı da büyümeye devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="13fec-126">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="13fec-127">Kullanıcı Arabirimi (UI) ile ilgili sorunları giderme (modelleri, görünümleri, denetleyicileri) alfabetik olarak gruplandırılmış değil, birden çok klasörlerinde yer alır.</span><span class="sxs-lookup"><span data-stu-id="13fec-127">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="13fec-128">Bu sorunu daha zayıf için filtreler veya ModelBinders, gibi ek kullanıcı Arabirimi düzeyinde yapılar kendi klasörlerine eklenen alır.</span><span class="sxs-lookup"><span data-stu-id="13fec-128">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="13fec-129">İş mantığı, model ve hizmet klasörler arasında dağılmış ve hangi klasörleri sınıflarda hangi bazılarında bağımlı NET bir belirti yoktur.</span><span class="sxs-lookup"><span data-stu-id="13fec-129">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="13fec-130">İçin proje düzeyinde kuruluş bu eksikliği sık müşteri adayları [spaghetti kod](https://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="13fec-130">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="13fec-131">Bu sorunları gidermeye yönelik uygulamalar genellikle birden çok proje çözümü, burada her proje olarak kabul edilir belirli bir bulunması halinde evrim Geçiren _katman_ uygulama.</span><span class="sxs-lookup"><span data-stu-id="13fec-131">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="13fec-132">Katmanları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="13fec-132">What are layers?</span></span>

<span data-ttu-id="13fec-133">Uygulamaların karmaşıklığı arttıkça, bu karmaşıklık yönetmek için bir uygulamanın kendi sorumluluklarını veya endişeniz varsa göre bölüneceği yoludur.</span><span class="sxs-lookup"><span data-stu-id="13fec-133">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="13fec-134">Bu sorunları asıl ayrımı izler ve böylece geliştiriciler, burada bazı işlevlere uygulanan kolayca bulabilirsiniz düzenlenmiş büyüyen bir kod temeli korunmasına yardımcı olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-134">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="13fec-135">Katmanlı bir mimari, çok sayıda avantaj yalnızca kod kuruluş dışına yine de sunar.</span><span class="sxs-lookup"><span data-stu-id="13fec-135">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="13fec-136">Kod katmanlara düzenleyerek, düşük düzey ortak işlevselliği uygulama genelinde yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-136">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="13fec-137">Bu yeniden yazılması gerekiyor daha az kod anlamına geldiğinden ve aşağıdaki tek bir uygulama üzerinde standart hale getirmek uygulama izin yararlıdır [kendiniz (KURU) yineleme](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) ilkesi.</span><span class="sxs-lookup"><span data-stu-id="13fec-137">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="13fec-138">Katmanlı bir mimari ile uygulamaları katman diğer katmanlarla kurabilir kısıtlamaları zorunlu kılabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-138">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="13fec-139">Kapsülleme sağlamak için yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="13fec-139">This helps to achieve encapsulation.</span></span> <span data-ttu-id="13fec-140">Bir katmanı değiştirilmiş ya da yerine onunla çalışan katmanları etkilenmiş.</span><span class="sxs-lookup"><span data-stu-id="13fec-140">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="13fec-141">Hangi sınırlayarak, böylece uygulamanın tamamı tek bir değişiklik etkilemez diğer katmanları değişikliklerinin etkisini azaltılabilir katmanları bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-141">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="13fec-142">Katmanları (ve saklama) işlevselliği uygulamadaki değiştirmek çok daha kolay olun.</span><span class="sxs-lookup"><span data-stu-id="13fec-142">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="13fec-143">Örneğin, bir uygulama başlangıçta kendi SQL Server veritabanı için Kalıcılık kullanabilirsiniz, ancak daha sonra bir bulut tabanlı süreklilik stratejisi ya da bir web API'si arkasında kullanmayı seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-143">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="13fec-144">Uygulama düzgün şekilde Kalıcılık uygulanması mantıksal katman içinde kapsüllenmiş, bu SQL Server belirli katman aynı genel arabirimi uygulayan yeni bir tane tarafından değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-144">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="13fec-145">Gelecekteki gereksinimlerdeki değişikliklere yanıt uygulamalarında kullanıma takas olası ek olarak, uygulama katmanları Ayrıca, test amaçlı uygulamalarını takas etmek kolaylaştırabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-145">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="13fec-146">Gerçek veri katmanı veya uygulama UI yerleşiminde karşı çalışan testler yazmak zorunda kalmak yerine bu Katmanlar test zaman isteklerine bilinen yanıtlar sağlayan sahte uygulamaları ile değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-146">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="13fec-147">Bu genellikle testleri yazmak çok daha kolay ve testleri uygulamanın gerçek altyapı karşı çalışmaya kıyasla çalıştırmak için çok daha hızlı hale getirir.</span><span class="sxs-lookup"><span data-stu-id="13fec-147">This typically makes tests much easier to write and much faster to run when compared to running tests against the application's real infrastructure.</span></span>

<span data-ttu-id="13fec-148">Mantıksal katman kuruluşun kurumsal yazılım uygulamaları kod iyileştirmeye yönelik yaygın bir tekniktir ve kod katmanlara düzenlenebilir birkaç yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="13fec-148">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="13fec-149">_Katmanlar_ uygulama içinde mantıksal ayrılığı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="13fec-149">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="13fec-150">Uygulama mantığı fiziksel sunucuları veya işlemler ayırmak için dağıtılmış, durumunda, bu ayrı bir fiziksel dağıtım hedefleri olarak adlandırılır _katmanları_.</span><span class="sxs-lookup"><span data-stu-id="13fec-150">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="13fec-151">Bu, olası ve tek bir katmana dağıtılır bir N katmanlı uygulama için çok yaygın olur.</span><span class="sxs-lookup"><span data-stu-id="13fec-151">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="13fec-152">Geleneksel "N-katmanı" mimarisi uygulama</span><span class="sxs-lookup"><span data-stu-id="13fec-152">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="13fec-153">Şekil 5-2'de en yaygın uygulama mantığı organizasyonunu katmanlara gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="13fec-153">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![](./media/image5-2.png)

**<span data-ttu-id="13fec-154">Şekil 5-2.</span><span class="sxs-lookup"><span data-stu-id="13fec-154">Figure 5-2.</span></span>** <span data-ttu-id="13fec-155">Normal uygulama katmanları.</span><span class="sxs-lookup"><span data-stu-id="13fec-155">Typical application layers.</span></span>

<span data-ttu-id="13fec-156">Bu katmanlar sık kullanıcı Arabirimi kısaltılır BLL (iş mantığı katmanı) ve DAL (veri erişim katmanı).</span><span class="sxs-lookup"><span data-stu-id="13fec-156">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="13fec-157">Bu mimariyi kullanarak, kullanıcılar yalnızca BLL ile etkileşime giren UI yerleşiminde isteklerini olun.</span><span class="sxs-lookup"><span data-stu-id="13fec-157">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="13fec-158">BLL, buna karşılık, veri erişim istekleri için DAL çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-158">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="13fec-159">UI yerleşiminde herhangi bir DAL ile doğrudan isteklerde olmaması gerekir ya da doğrudan arasında başka yollarla kalıcılığı ile etkileşim.</span><span class="sxs-lookup"><span data-stu-id="13fec-159">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="13fec-160">Benzer şekilde, BLL yalnızca kalıcılığı ile bir DAL giderek etkileşim.</span><span class="sxs-lookup"><span data-stu-id="13fec-160">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="13fec-161">Bu şekilde, her katmanın kendi iyi bilinen bir sorumluluğu vardır.</span><span class="sxs-lookup"><span data-stu-id="13fec-161">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="13fec-162">Bu geleneksel katmanlama yaklaşımın bir dezavantajı derleme zamanı bağımlılıklarını üstten alta çalışmasıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-162">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="13fec-163">Diğer bir deyişle UI yerleşiminde DAL üzerinde bağlıdır BLL bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-163">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="13fec-164">Bu, genellikle en önemli mantıksal uygulamada tutar, BLL veri erişimi uygulama ayrıntıları (ve genellikle veritabanı varlığı) bağlı olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="13fec-164">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="13fec-165">İş mantığı bu tür bir mimari test genellikle test veritabanı gerektiren, zordur.</span><span class="sxs-lookup"><span data-stu-id="13fec-165">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="13fec-166">Sonraki bölümde göreceğiniz gibi bağımlılık tersine çevirme ilkesini bu sorunu gidermek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-166">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="13fec-167">Şekil 5-3 uygulama sorumluluğu (veya katman) üç projelere bozucu bir örnek çözüm gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="13fec-167">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![](./media/image5-3.png)

**<span data-ttu-id="13fec-168">Şekil 5-3.</span><span class="sxs-lookup"><span data-stu-id="13fec-168">Figure 5-3.</span></span>** <span data-ttu-id="13fec-169">Basit monolitik bir uygulamayla üç projeleri.</span><span class="sxs-lookup"><span data-stu-id="13fec-169">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="13fec-170">Bu uygulama, kuruluş amacıyla birkaç proje kullansa da, yine de tek bir birim olarak dağıtılır ve istemcileri ile tek bir web uygulaması kullanacaksınız.</span><span class="sxs-lookup"><span data-stu-id="13fec-170">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="13fec-171">Bu, çok basit dağıtım işlemi için sağlar.</span><span class="sxs-lookup"><span data-stu-id="13fec-171">This allows for very simple deployment process.</span></span> <span data-ttu-id="13fec-172">Şekil 5-4'te gösterildiği böyle bir uygulamayı nasıl olabileceği barındırılan Azure kullanarak.</span><span class="sxs-lookup"><span data-stu-id="13fec-172">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![](./media/image5-4.png)

**<span data-ttu-id="13fec-173">Şekil 5-4.</span><span class="sxs-lookup"><span data-stu-id="13fec-173">Figure 5-4.</span></span>** <span data-ttu-id="13fec-174">Azure Web uygulamasının basit dağıtım</span><span class="sxs-lookup"><span data-stu-id="13fec-174">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="13fec-175">Uygulamanın büyümesi gerektiğinde gibi daha karmaşık ve güçlü dağıtım çözümleri gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-175">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="13fec-176">Şekil 5-5 ek özelliklerini destekler. daha karmaşık bir dağıtım planı örneği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="13fec-176">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

**<span data-ttu-id="13fec-177">Şekil 5-5.</span><span class="sxs-lookup"><span data-stu-id="13fec-177">Figure 5-5.</span></span>** <span data-ttu-id="13fec-178">Bir Azure App Service'te bir web uygulaması dağıtma</span><span class="sxs-lookup"><span data-stu-id="13fec-178">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="13fec-179">Dahili olarak, bu projenin kuruluşunuzun birden çok proje sorumluluğa tabanlı uygulama Bakımı artırır.</span><span class="sxs-lookup"><span data-stu-id="13fec-179">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="13fec-180">Bu birimi artırmaya veya genişletmeye bulut tabanlı isteğe bağlı ölçeklenebilirlik avantajlarından yararlanmak için ölçeklendirilebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-180">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="13fec-181">Büyütme, uygulamanızı barındıran sunucuların ek CPU, bellek, disk alanı veya diğer kaynaklar ekleme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="13fec-181">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="13fec-182">Bunlar, fiziksel sunucuları, sanal makineler ve kapsayıcılar olup olmadığını ölçek genişletme bu sunucular ek örneklerini eklemek anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="13fec-182">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="13fec-183">Uygulamanızı birden çok örneğine barındırıldığında, bir yük dengeleyici tek tek uygulama örneklerine istekleri atamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="13fec-183">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="13fec-184">Azure'da bir web uygulaması ölçeklendirme için en kolay yaklaşım, uygulamanın App Service planında el ile ölçeklendirme yapılandırmaktır.</span><span class="sxs-lookup"><span data-stu-id="13fec-184">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="13fec-185">Şekil 5-6 kaç tane örnek bir uygulama hizmet veren yapılandırmak için uygun Azure Pano ekranı gösterilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-185">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

**<span data-ttu-id="13fec-186">Şekil 5-6.</span><span class="sxs-lookup"><span data-stu-id="13fec-186">Figure 5-6.</span></span>** <span data-ttu-id="13fec-187">App Service, Azure'da ölçeklendirme planı.</span><span class="sxs-lookup"><span data-stu-id="13fec-187">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="13fec-188">Temiz mimarisi</span><span class="sxs-lookup"><span data-stu-id="13fec-188">Clean architecture</span></span>

<span data-ttu-id="13fec-189">Bağımlılık tersine çevirme ilkesini ve bunun yanı sıra etki alanı Odaklı Tasarım (DDD) İlkeleri izleyin uygulamaları benzer bir mimariye geldiğinde eğilimindedir.</span><span class="sxs-lookup"><span data-stu-id="13fec-189">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="13fec-190">Bu mimari, yıllar içinde birçok adlarıyla geçti.</span><span class="sxs-lookup"><span data-stu-id="13fec-190">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="13fec-191">Adlarını Altıgen mimarisi, bağlantı noktaları-ve-bağdaştırıcıları tarafından izlenen biriydi.</span><span class="sxs-lookup"><span data-stu-id="13fec-191">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="13fec-192">Daha yakın bir tarihte bu olarak alıntı olarak [çoklu kare mimarisi](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) veya [temiz mimarisi](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="13fec-192">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="13fec-193">İkinci Ad, temiz mimarisi bu mimaride bu e-kitap adı olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="13fec-193">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="13fec-194">Temiz bir mimari filtrelenmeyen seçeceğine DDD ilkeleri kullanılarak oluşturulan uygulamalar uygulanabilir terimi DDD kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="13fec-194">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="13fec-195">Eski söz konusu olduğunda bu birleşimi için "DDD mimarisine temiz" başvurulabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-195">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="13fec-196">Temiz mimarisi, iş mantığı ve uygulama modeli uygulama merkezinde koyar.</span><span class="sxs-lookup"><span data-stu-id="13fec-196">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="13fec-197">Veri erişim veya diğer altyapıyla ilgili endişelerini bağımlı iş mantığına sahip olmak yerine bu bağımlılık ters: uygulama Çekirdeğinde altyapı ve uygulama ayrıntılarına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-197">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="13fec-198">Bu, altyapı katman içinde tanımlanan tür tarafından uygulanan uygulama core'da soyutlama veya arabirimleri tanımlayarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="13fec-198">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="13fec-199">Bu mimari görselleştirmenin en yaygın yolu, bir dizi için bir çoklu kare benzer Eşmerkezli daire kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="13fec-199">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="13fec-200">Şekil 5-7, bu tür bir mimari temsili bir örnek göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="13fec-200">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

**<span data-ttu-id="13fec-201">Şekil 5-7.</span><span class="sxs-lookup"><span data-stu-id="13fec-201">Figure 5-7.</span></span>** <span data-ttu-id="13fec-202">Mimari temizleme; Çoklu kare görüntüle</span><span class="sxs-lookup"><span data-stu-id="13fec-202">Clean Architecture; onion view</span></span>

<span data-ttu-id="13fec-203">Bu diyagramda, bağımlılıkları en içteki daire doğru akış.</span><span class="sxs-lookup"><span data-stu-id="13fec-203">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="13fec-204">Uygulama çekirdeği konumundan bu diyagramının çekirdek adını alır.</span><span class="sxs-lookup"><span data-stu-id="13fec-204">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="13fec-205">Ve diyagram üzerinde uygulama çekirdeği diğer uygulama katmanları hiçbir bağımlılığı olduğunu görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-205">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="13fec-206">Uygulama varlıkları ve arabirimler çok Merkezi'nde var.</span><span class="sxs-lookup"><span data-stu-id="13fec-206">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="13fec-207">Yalnızca dışında ancak uygulama çekirdeği aşamasında, genellikle iç daire içinde tanımlanan arabirimleri uygulayan etki alanı Hizmetleri değildir.</span><span class="sxs-lookup"><span data-stu-id="13fec-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="13fec-208">Uygulama çekirdek dışında hem kullanıcı Arabirimi ve altyapı katmanlarının uygulama çekirdeği, ancak başka bir (zorunlu) bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-208">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="13fec-209">Şekil 5-8 bağımlılık UI ve diğer katmanlar arasında daha iyi yansıtmaktadır daha geleneksel bir yatay katman diyagramı gösterir.</span><span class="sxs-lookup"><span data-stu-id="13fec-209">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

**<span data-ttu-id="13fec-210">Şekil 5-8.</span><span class="sxs-lookup"><span data-stu-id="13fec-210">Figure 5-8.</span></span>** <span data-ttu-id="13fec-211">Mimari temizleme; Yatay katman görüntüle</span><span class="sxs-lookup"><span data-stu-id="13fec-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="13fec-212">Yalnızca çalışma zamanı bağımlılık kesikli oku temsil ederken, düz bir ok derleme zamanı bağımlılıklarını temsil ettiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="13fec-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="13fec-213">Temiz yapı ile UI yerleşiminde uygulama çekirdek derleme zamanında tanımlanan arabirimleri ile çalışır ve ideal olarak altyapı katmanda tanımlanan uygulama türleri hakkında bilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="13fec-213">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="13fec-214">Mevcut ve bağımlılık ekleme aracılığıyla uygulama temel arabirimler kadar kablolu erişebilmeleri çalışma zamanında, ancak bu uygulama türleri yürütmek, uygulama için gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="13fec-214">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="13fec-215">Şekil 5-9, bu önerileri oluşturulduğunda bir ASP.NET Core uygulama mimarisi daha ayrıntılı bir görünümünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="13fec-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASP.NET Core mimarisi](./media/image5-9.png)

**<span data-ttu-id="13fec-217">Şekil 5-9.</span><span class="sxs-lookup"><span data-stu-id="13fec-217">Figure 5-9.</span></span>** <span data-ttu-id="13fec-218">ASP.NET Core mimarisi diyagramı aşağıdaki temiz mimarisi.</span><span class="sxs-lookup"><span data-stu-id="13fec-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="13fec-219">Uygulama çekirdeği altyapısında almadığından Bu katman için otomatik birim testleri yazmak çok daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="13fec-219">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="13fec-220">Şekil 5-10-5-11 testleri bu mimariye nasıl getireceğinizi gösterir.</span><span class="sxs-lookup"><span data-stu-id="13fec-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

**<span data-ttu-id="13fec-222">Şekil 5-10.</span><span class="sxs-lookup"><span data-stu-id="13fec-222">Figure 5-10.</span></span>** <span data-ttu-id="13fec-223">Uygulama çekirdeği yalıtım modunda test birimi.</span><span class="sxs-lookup"><span data-stu-id="13fec-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

**<span data-ttu-id="13fec-225">Şekil 5-11.</span><span class="sxs-lookup"><span data-stu-id="13fec-225">Figure 5-11.</span></span>** <span data-ttu-id="13fec-226">Harici bağımlılıkları olan altyapı uygulamaları sınama tümleştirme.</span><span class="sxs-lookup"><span data-stu-id="13fec-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="13fec-227">UI yerleşiminde, altyapı projede tanımlanan türler üzerinde herhangi bir doğrudan bağımlılığı olmadığı benzer şekilde test edilmesini kolaylaştırmak için ya da uygulamaları veya uygulama gereksinimlerini değiştirme yanıt değiştirilecek çok kolaydır.</span><span class="sxs-lookup"><span data-stu-id="13fec-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="13fec-228">ASP.NET Core'nın yerleşik kullanımını ve bağımlılık ekleme için destek yapısı Önemsiz olmayan tek yapılı uygulamaları için en uygun şekilde bu mimari sağlar.</span><span class="sxs-lookup"><span data-stu-id="13fec-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="13fec-229">Tek yapılı uygulamalar için uygulama çekirdeği, altyapı ve UI projeleri tümünü tek bir uygulama çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="13fec-229">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="13fec-230">Çalışma zamanı uygulama mimarisi, Şekil 5-12'gibi bir şey görünebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Core mimarisi 2](./media/image5-12.png)

**<span data-ttu-id="13fec-232">Şekil 5-12.</span><span class="sxs-lookup"><span data-stu-id="13fec-232">Figure 5-12.</span></span>** <span data-ttu-id="13fec-233">Örnek ASP.NET Core uygulamanın çalışma zamanı mimari.</span><span class="sxs-lookup"><span data-stu-id="13fec-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="13fec-234">Kodu temiz mimarisinde düzenleme</span><span class="sxs-lookup"><span data-stu-id="13fec-234">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="13fec-235">Bir temiz mimarisi çözümde her proje Temizle sorumlulukları vardır.</span><span class="sxs-lookup"><span data-stu-id="13fec-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="13fec-236">Bu nedenle, her projede belirli türlerine ait ve bu tür uygun projedeki karşılık gelen klasörlere sık bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-236">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="13fec-237">Uygulama çekirdeği varlıklar, hizmetler ve arabirimler içerir iş modeli tutar.</span><span class="sxs-lookup"><span data-stu-id="13fec-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="13fec-238">Bu arabirimler soyutlama altyapısını kullanarak veri erişimi, dosya sistemi erişimini, ağ çağrıları, vb. gibi gerçekleştirilecek işlemleri içerir. Bazen Hizmetleri veya bu katmanda tanımlanan arabirimleri kullanıcı Arabirimi veya altyapı üzerinde hiçbir bağımlılık sahip olmayan varlık türleriyle çalışmak gerekir.</span><span class="sxs-lookup"><span data-stu-id="13fec-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="13fec-239">Bu basit veri aktarımı nesneleri (Dto) tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

### <a name="application-core-types"></a><span data-ttu-id="13fec-240">Uygulama temel türleri</span><span class="sxs-lookup"><span data-stu-id="13fec-240">Application Core types</span></span>

- <span data-ttu-id="13fec-241">Varlıkları (kalıcı iş modeli sınıflar)</span><span class="sxs-lookup"><span data-stu-id="13fec-241">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="13fec-242">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="13fec-242">Interfaces</span></span>
- <span data-ttu-id="13fec-243">Hizmetler</span><span class="sxs-lookup"><span data-stu-id="13fec-243">Services</span></span>
- <span data-ttu-id="13fec-244">Dto'lar</span><span class="sxs-lookup"><span data-stu-id="13fec-244">DTOs</span></span>

<span data-ttu-id="13fec-245">Altyapı proje, genellikle veri erişimi uygulamaları içerir.</span><span class="sxs-lookup"><span data-stu-id="13fec-245">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="13fec-246">Tipik bir ASP.NET Core web uygulamasında bu uygulamalardan herhangi EF Core, Entity Framework (EF) DbContext dahil `Migration` tanımlanan nesneleri ve veri erişim uygulama sınıfları.</span><span class="sxs-lookup"><span data-stu-id="13fec-246">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="13fec-247">Veri erişim uygulama kodu soyutlamak için en yaygın kullanımının yoludur [deposu tasarım deseni](https://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="13fec-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="13fec-248">Veri erişimi uygulamaları yanı sıra altyapısı projesi altyapıyla ilgili endişelerini ile etkileşmesi gereken hizmetleri, uygulamaları içermelidir.</span><span class="sxs-lookup"><span data-stu-id="13fec-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="13fec-249">Bu hizmetler, arabirimler uygulama çekirdek tanımlanan uygulamalıdır ve altyapı uygulama Core projesine bir başvuru şekilde sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

### <a name="infrastructure-types"></a><span data-ttu-id="13fec-250">Altyapı türleri</span><span class="sxs-lookup"><span data-stu-id="13fec-250">Infrastructure types</span></span>

- <span data-ttu-id="13fec-251">EF Core türleri (`DbContext`, `Migration`)</span><span class="sxs-lookup"><span data-stu-id="13fec-251">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="13fec-252">Veri erişim uygulama türleri (depo)</span><span class="sxs-lookup"><span data-stu-id="13fec-252">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="13fec-253">Özel altyapı Hizmetleri (örneğin, `FileLogger` veya `SmtpNotifier`)</span><span class="sxs-lookup"><span data-stu-id="13fec-253">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

<span data-ttu-id="13fec-254">Bir ASP.NET Core MVC uygulamasındaki kullanıcı arabirimi katmanı, uygulama için giriş noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-254">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="13fec-255">Bu proje uygulama çekirdeği projeye başvurması ve türlerinden altyapısı kesinlikle uygulama çekirdek tanımlanan arabirimleri aracılığıyla etkileşim.</span><span class="sxs-lookup"><span data-stu-id="13fec-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="13fec-256">Hiçbir doğrudan örneğinin veya statik çağrıları altyapı katman türleri için kullanıcı Arabirimi katmanında izin verilmelidir.</span><span class="sxs-lookup"><span data-stu-id="13fec-256">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

### <a name="ui-layer-types"></a><span data-ttu-id="13fec-257">UI katman türleri</span><span class="sxs-lookup"><span data-stu-id="13fec-257">UI layer types</span></span>

- <span data-ttu-id="13fec-258">Denetleyiciler</span><span class="sxs-lookup"><span data-stu-id="13fec-258">Controllers</span></span>
- <span data-ttu-id="13fec-259">FilTReleri</span><span class="sxs-lookup"><span data-stu-id="13fec-259">Filters</span></span>
- <span data-ttu-id="13fec-260">Görünümler</span><span class="sxs-lookup"><span data-stu-id="13fec-260">Views</span></span>
- <span data-ttu-id="13fec-261">Viewmodel'lar</span><span class="sxs-lookup"><span data-stu-id="13fec-261">ViewModels</span></span>
- <span data-ttu-id="13fec-262">Başlangıç</span><span class="sxs-lookup"><span data-stu-id="13fec-262">Startup</span></span>

<span data-ttu-id="13fec-263">Başlangıç sınıfı için uygulamayı yapılandırma ve teknik uygulama türleri'kurmak için çalışma zamanında düzgün çalışması bağımlılık ekleme sağlayan arabirimler için sorumludur.</span><span class="sxs-lookup"><span data-stu-id="13fec-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="13fec-264">Bağımlılık ekleme UI proje Startup.cs dosyasındaki Createservicereplicalisteners() wire için proje altyapısı projesi başvuru gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="13fec-265">Bu bağımlılık, en kolay özel DI kapsayıcı kullanılarak kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="13fec-266">Bu örnek amaçları için en kolay yaklaşım, altyapı projesine başvuruda bulunmak kullanıcı Arabirimi proje izin vermektir.</span><span class="sxs-lookup"><span data-stu-id="13fec-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="13fec-267">Tek yapılı uygulamalar ve kapsayıcılar</span><span class="sxs-lookup"><span data-stu-id="13fec-267">Monolithic applications and containers</span></span>

<span data-ttu-id="13fec-268">Tek ve tek parça dağıtım tabanlı Web uygulaması veya hizmeti oluşturma ve kapsayıcı olarak dağıtın.</span><span class="sxs-lookup"><span data-stu-id="13fec-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="13fec-269">Uygulama içinde bu tek parçalı ancak düzenlenmiş şekilde birkaç kitaplıklar, bileşenler veya katmanları olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-269">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="13fec-270">Harici olarak, bir tek tek işlem, tek bir web uygulaması veya tek bir hizmet gibi kapsayıcıdır.</span><span class="sxs-lookup"><span data-stu-id="13fec-270">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="13fec-271">Bu model yönetmek için uygulamayı temsil etmek için tek bir kapsayıcı dağıtırsınız.</span><span class="sxs-lookup"><span data-stu-id="13fec-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="13fec-272">Ölçeklendirmek için önde gelen bir yük dengeleyici ile ek kopya eklemeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="13fec-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="13fec-273">Basitlik, tek bir dağıtım bir çoklu kapsayıcı veya VM yönetmesini gelir.</span><span class="sxs-lookup"><span data-stu-id="13fec-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="13fec-274">Şekil 5-13'te gösterildiği gibi birden çok bileşenleri/kitaplıkları veya her bir kapsayıcı içindeki iç Katmanlar içerebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="13fec-275">Ancak, kapsayıcı İlkesi'ni aşağıdaki _"kapsayıcı bir şeyi yapar ve bunu tek bir işlemde yapar_", tek parçalı deseni bir çakışma olabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-275">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="13fec-276">Bu yaklaşımın bir dezavantajı, / uygulama büyürken, ölçeklendirme gerektiren gelir.</span><span class="sxs-lookup"><span data-stu-id="13fec-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="13fec-277">Uygulamanın tamamı ölçeklenen, gerçekten bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="13fec-277">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="13fec-278">Ancak, çoğu durumda, ölçeklendirme, diğer bileşenleri çalışırken gerektiren sıkıştırma noktaları daha az kullanılan uygulamanın bazı bölümlerini uygulanır.</span><span class="sxs-lookup"><span data-stu-id="13fec-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="13fec-279">Tipik bir e-ticaret örneği kullanarak, büyük olasılıkla ölçeklendirmek gerekenler ürün bilgileri bileşendir.</span><span class="sxs-lookup"><span data-stu-id="13fec-279">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="13fec-280">Pek çok daha fazla müşteriye satın çok ürünlerin göz atın.</span><span class="sxs-lookup"><span data-stu-id="13fec-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="13fec-281">Daha fazla müşteriye kendi Sepeti ödeme işlem hattını kullanma daha kullanın.</span><span class="sxs-lookup"><span data-stu-id="13fec-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="13fec-282">Daha az müşteriler, yorum eklemek veya satın alma geçmişlerini görüntüleyin.</span><span class="sxs-lookup"><span data-stu-id="13fec-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="13fec-283">Ve büyük olasılıkla yalnızca birkaç çalışanlar, içerik ve pazarlama kampanyaları yönetmek için gereken tek bir bölgede sahipsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="13fec-284">Tek yapılı tasarım ölçeğini genişleterek tüm kodu birden çok kez dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="13fec-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="13fec-285">"Her şey Ölçeklendir" sorun ek olarak, tüm uygulama ve tam yeniden dağıtma işlemi tüm örneklerin tam çözülüp tek bir bileşen değişiklikler gerektirir.</span><span class="sxs-lookup"><span data-stu-id="13fec-285">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="13fec-286">Tek parçalı bir yaklaşım için ortaktır ve bu mimari yaklaşım ile pek çok kuruluş geliştiriyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="13fec-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="13fec-287">Başkalarının ulaştığını anlayabilmesini olsa çok iyi yeterli sonuçları yaşıyorsunuz demektir.</span><span class="sxs-lookup"><span data-stu-id="13fec-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="13fec-288">Çoğu uygulamalarını bu modelde, araçları ve altyapısı, hizmet odaklı mimarilerin (SOA) oluşturmak çok zor ve uygulama büyüdü kadar gereken görmediniz tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="13fec-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="13fec-289">Tek parçalı bir yaklaşım sınırlarını aldığınızı bulursanız, uygulamanın kapsayıcıları ve mikro Hizmetleri daha iyi yararlanmasını sağlamak için bozucu sonraki mantıksal adım olabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-289">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="13fec-290">Microsoft azure'da tek yapılı uygulamaları dağıtma, her örneği için özel VM'ler kullanarak gerçekleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="13fec-291">Kullanarak [Azure sanal makine ölçek kümeleri](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), sanal makineleri kolayca ölçeklendirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-291">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="13fec-292">[Azure uygulama hizmetleri](https://azure.microsoft.com/services/app-service/) tek yapılı uygulamaları çalıştırabilir ve Vm'leri yönetmek zorunda kalmadan örneklerini kolayca ölçeklendirin.</span><span class="sxs-lookup"><span data-stu-id="13fec-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="13fec-293">Azure uygulama hizmetleri, dağıtımını basitleştirme amacıyla da Docker kapsayıcıları tek örneğini çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="13fec-294">Docker kullanarak Docker konağı olarak tek bir VM dağıtma ve birden çok örneği çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="13fec-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="13fec-295">Azure, Şekil 5-14'te gösterildiği gibi kullanarak ölçeklendirme yönetebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="13fec-296">Çeşitli konaklarına dağıtım geleneksel dağıtım teknikleri ile yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="13fec-297">Docker ana bilgisayarları gibi komutlarla yönetilebilir **docker run** sürekli teslim (CD) işlem hatları gibi el ile veya Otomasyon aracılığıyla gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="13fec-298">Bir kapsayıcı dağıtılan tek parçalı uygulama</span><span class="sxs-lookup"><span data-stu-id="13fec-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="13fec-299">Tek parçalı uygulama dağıtımlarını yönetmek için kapsayıcılar'ı kullanmanın avantajları vardır.</span><span class="sxs-lookup"><span data-stu-id="13fec-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="13fec-300">Kapsayıcı örnekleri ölçeklendirme, çok daha hızlı ve ek sanal makineleri dağıtma kolaydır.</span><span class="sxs-lookup"><span data-stu-id="13fec-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="13fec-301">Bile sanal makine ölçek VM ölçek kümeleri kullanırken, örnek için zaman ayırın.</span><span class="sxs-lookup"><span data-stu-id="13fec-301">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="13fec-302">Uygulama örnekleri olarak dağıtıldığında, uygulama yapılandırmasını VM bir parçası olarak yönetilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="13fec-303">Docker görüntülerini çok daha hızlı olduğundan, güncelleştirmeleri dağıtmak ve etkili ağ.</span><span class="sxs-lookup"><span data-stu-id="13fec-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="13fec-304">Docker görüntülerini genellikle piyasaya çıkarma hızlandırma saniyeler içinde başlayın.</span><span class="sxs-lookup"><span data-stu-id="13fec-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="13fec-305">Bir Docker örneğini bozmadan verme olarak kadar kolay bir `docker stop` komutu, genellikle kısa bir saniye içinde tamamlanıyor.</span><span class="sxs-lookup"><span data-stu-id="13fec-305">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="13fec-306">Kapsayıcıları tasarım gereği kendiliğinden sabittir gibi güncelleştirme betikleri bazı belirli bir yapılandırma veya dosya sol için diskte hesabı Unut ancak, hiçbir zaman bozuk VM'ler hakkında endişelenmenize gerek.</span><span class="sxs-lookup"><span data-stu-id="13fec-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="13fec-307">Docker kapsayıcıları tek parça daha basit web uygulamaları dağıtımını için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-307">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="13fec-308">Bu artırır sürekli tümleştirme ve sürekli dağıtım işlem hatları ve üretim için dağıtım başarı elde etmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="13fec-308">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="13fec-309">Daha fazla "neden üretimde çalışmaz makineme çalışır?"</span><span class="sxs-lookup"><span data-stu-id="13fec-309">No more “It works in my machine, why does it not work in production?”</span></span>

<span data-ttu-id="13fec-310">Bir mikro hizmet tabanlı mimariye pek çok faydası vardır, ancak bu avantajlar bulunan artan karmaşıklık bedeli.</span><span class="sxs-lookup"><span data-stu-id="13fec-310">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="13fec-311">Daha iyi bir seçenek tek bir kapsayıcı veya yalnızca birkaç kapsayıcıları çalışan bir tek parçalı dağıtım uygulaması, bu nedenle bazı durumlarda, maliyetler, ağır basıyor.</span><span class="sxs-lookup"><span data-stu-id="13fec-311">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="13fec-312">Tek parça bir uygulamayı kolayca iyi ayrılmış mikro hizmetler halinde decomposable olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-312">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="13fec-313">Mikro hizmetler karşı daha dayanıklı bir uygulama sağlamak için birbirinden çalışması gerekir.</span><span class="sxs-lookup"><span data-stu-id="13fec-313">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="13fec-314">Uygulamanın bağımsız özellik dilimleri teslim edilemiyor, bu ayırma karmaşıklık yalnızca ekler.</span><span class="sxs-lookup"><span data-stu-id="13fec-314">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="13fec-315">Bir uygulama, özelliklerin bağımsız olarak ölçeklendirme henüz gerekmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-315">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="13fec-316">Görece basit, tüm örnek kopyalama işleminde birçok uygulama, tek bir örnekten fazlasına ölçeklendirilemez gerektiğinde bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-316">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="13fec-317">Basit ve ekonomik ölçeklendirme uygulamasının tam örneği olduğunda, ayrık Hizmetleri uygulamasına ayırmak için ek iş minimal avantajı sağlar.</span><span class="sxs-lookup"><span data-stu-id="13fec-317">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="13fec-318">Erken geliştirme bir uygulamanın, sizin dair NET bir fikir doğal işlevsel sınırları nerede sahip olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-318">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="13fec-319">En düşük uygun bir ürün geliştirirken, doğal ayrımı henüz çıkmıştır değil.</span><span class="sxs-lookup"><span data-stu-id="13fec-319">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="13fec-320">Bu koşullar bazıları geçici olabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-320">Some of these conditions might be temporary.</span></span> <span data-ttu-id="13fec-321">Tek parça bir uygulamayı oluşturun ve daha sonra bazı özellikleri geliştirilen ve mikro hizmet dağıtılan ayrı.</span><span class="sxs-lookup"><span data-stu-id="13fec-321">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="13fec-322">Diğer koşullar, uygulamanın birden fazla mikro hizmetler halinde hiçbir zaman bozuk durumda, yani, uygulamanın sorun alanı için gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-322">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="13fec-323">Bir uygulamaya birçok ayrı işlemler ayırma yükü tanıtır.</span><span class="sxs-lookup"><span data-stu-id="13fec-323">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="13fec-324">Özellikler farklı işlemlere ayırmak daha karmaşık yoktur.</span><span class="sxs-lookup"><span data-stu-id="13fec-324">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="13fec-325">İletişim protokolleri, daha karmaşık hale gelir.</span><span class="sxs-lookup"><span data-stu-id="13fec-325">The communication protocols become more complex.</span></span> <span data-ttu-id="13fec-326">Yerine yöntem çağrılarını, hizmetler arasında zaman uyumsuz iletişim kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="13fec-326">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="13fec-327">Bir mikro hizmet mimarisi için taşırken, birçok hizmetine uygulama mikro hizmetler sürümünde yapı taşlarını eklemeniz gerekir: olay veri yolu işleme, ileti dayanıklılık ve yeniden denemeler, nihai tutarlılığa kadar giden ve daha fazla.</span><span class="sxs-lookup"><span data-stu-id="13fec-327">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="13fec-328">Çok daha kolay [eShopOnWeb başvuru uygulaması](https://github.com/dotnet-architecture/eShopOnWeb) tek kapsayıcı monolitik kapsayıcı kullanımını destekler.</span><span class="sxs-lookup"><span data-stu-id="13fec-328">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="13fec-329">Uygulama, geleneksel MVC görünümleri, web API'leri ve Razor sayfaları içeren bir web uygulaması içerir.</span><span class="sxs-lookup"><span data-stu-id="13fec-329">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="13fec-330">Bu uygulamayı kullanarak çözüm kök başlatılabilir `docker-compose build` ve `docker-compose up` komutları.</span><span class="sxs-lookup"><span data-stu-id="13fec-330">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="13fec-331">Bu komut, web kapsayıcısı yapılandırır kullanarak örnek `Dockerfile` web projesinin kök dizininde bulunan ve belirtilen bir bağlantı noktası kapsayıcı çalışır.</span><span class="sxs-lookup"><span data-stu-id="13fec-331">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="13fec-332">Bu uygulama kaynağını Github'dan indirip yerel olarak çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="13fec-332">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="13fec-333">Tek parça bu uygulama bir kapsayıcı ortamında dağıtılan fayda sağlar.</span><span class="sxs-lookup"><span data-stu-id="13fec-333">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="13fec-334">Biri için kapsayıcı dağıtımı uygulamanın her örneği aynı ortamda çalıştığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="13fec-334">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="13fec-335">Bu, burada erken test ve geliştirme gerçekleşmesi Geliştirici ortamı içerir.</span><span class="sxs-lookup"><span data-stu-id="13fec-335">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="13fec-336">Geliştirme ekibi, uygulamayı üretim ortamına eşleşen bir kapsayıcı ortamında çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-336">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="13fec-337">Ayrıca, kapsayıcıya alınmış uygulamaları ölçek genişletme daha düşük maliyetle.</span><span class="sxs-lookup"><span data-stu-id="13fec-337">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="13fec-338">Bir kapsayıcı ortamı kullanarak büyük kaynak geleneksel VM ortamları paylaşımı etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="13fec-338">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="13fec-339">Son olarak, ASP.NET'in, iş mantığı ve depolama sunucusu arasında bir ayrım zorlar.</span><span class="sxs-lookup"><span data-stu-id="13fec-339">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="13fec-340">Uygulama Ölçeklendirmesi eşitlenene gibi birden çok kapsayıcı tümünü tek bir fiziksel depolama bir ortamda kullanır.</span><span class="sxs-lookup"><span data-stu-id="13fec-340">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="13fec-341">Bu depolama ortamına genelde bir SQL Server veritabanı çalıştıran bir yüksek kullanılabilirlik sunucusu olacaktır.</span><span class="sxs-lookup"><span data-stu-id="13fec-341">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="13fec-342">Docker desteği</span><span class="sxs-lookup"><span data-stu-id="13fec-342">Docker support</span></span>

<span data-ttu-id="13fec-343">`eShopOnWeb` Üzerinde .NET Core projesi çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="13fec-343">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="13fec-344">Bu nedenle, Windows tabanlı veya Linux tabanlı kapsayıcılar içinde çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-344">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="13fec-345">Aynı ana bilgisayar türü için SQL Server kullanmak istediğiniz bir dağıtım için Docker unutmayın.</span><span class="sxs-lookup"><span data-stu-id="13fec-345">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="13fec-346">Linux tabanlı kapsayıcılar bir daha küçük kaplama alanı izin ve tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="13fec-346">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="13fec-347">Visual Studio 2017 veya sonraki bir projeye sağ tıklayarak mevcut bir uygulamaya Docker desteği eklemek için kullanabileceğiniz **Çözüm Gezgini** seçip **Ekle** > **Docker Destek**.</span><span class="sxs-lookup"><span data-stu-id="13fec-347">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="13fec-348">Bu, gerekli dosyaları ekler ve bunları kullanmak için projeyi değiştirir.</span><span class="sxs-lookup"><span data-stu-id="13fec-348">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="13fec-349">Geçerli `eShopOnWeb` örnek zaten bu dosyaları yerinde sahiptir.</span><span class="sxs-lookup"><span data-stu-id="13fec-349">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="13fec-350">Çözüm düzeyinde `docker-compose.yml` dosya ne oluşturmak için görüntüler ve başlatmak için hangi kapsayıcıları hakkında bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="13fec-350">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="13fec-351">Dosya kullanmanıza olanak tanır `docker-compose` birden çok uygulama aynı anda başlatmak için komutu.</span><span class="sxs-lookup"><span data-stu-id="13fec-351">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="13fec-352">Bu durumda, yalnızca Web projesi kullanıma sunuluyor.</span><span class="sxs-lookup"><span data-stu-id="13fec-352">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="13fec-353">Bağımlılıklar, ayrı bir veritabanı kapsayıcısı gibi yapılandırmak için de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="13fec-353">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="13fec-354">`docker-compose.yml` Dosya başvuruları `Dockerfile` içinde `Web` proje.</span><span class="sxs-lookup"><span data-stu-id="13fec-354">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="13fec-355">`Dockerfile` Nasıl uygulama üzerinde yapılandırılır ve hangi temel kapsayıcı kullanılacak belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="13fec-355">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="13fec-356">`Web`' `Dockerfile`:</span><span class="sxs-lookup"><span data-stu-id="13fec-356">The `Web`' `Dockerfile`:</span></span>

```
FROM mcr.microsoft.com/dotnet/core/sdk:2.2 AS build
WORKDIR /app

COPY *.sln .
COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/core/aspnet:2.2 AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

# Optional: Set this here if not setting it from docker-compose.yml
# ENV ASPNETCORE_ENVIRONMENT Development

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="13fec-357">Docker ile ilgili sorunları giderme</span><span class="sxs-lookup"><span data-stu-id="13fec-357">Troubleshooting Docker problems</span></span>

<span data-ttu-id="13fec-358">Kapsayıcılı uygulama çalıştırıldıktan sonra siz durduruncaya kadar çalışmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="13fec-358">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="13fec-359">Çalışan kapsayıcıları görmek `docker ps` komutu.</span><span class="sxs-lookup"><span data-stu-id="13fec-359">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="13fec-360">Çalışan kapsayıcıya kullanarak durdurabilirsiniz `docker stop` komut ve kapsayıcı kimliği belirtme</span><span class="sxs-lookup"><span data-stu-id="13fec-360">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="13fec-361">Çalışan Docker kapsayıcılar, aksi takdirde kullanılacak geliştirme ortamınızda deneyebilir bağlantı noktalarına bağlı olabilir olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="13fec-361">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="13fec-362">Çalıştırın veya çalışan bir Docker kapsayıcısı aynı bağlantı noktasını kullanarak bir uygulamanın hatalarını ayıklama kullanmayı denerseniz, sunucunun bu bağlantı noktasına bağlanamaz bildiren bir hata alırsınız.</span><span class="sxs-lookup"><span data-stu-id="13fec-362">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="13fec-363">Bir kez daha, kapsayıcı durdurma Sorun giderildi.</span><span class="sxs-lookup"><span data-stu-id="13fec-363">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="13fec-364">Visual Studio'yu kullanarak uygulamanıza Docker desteği eklemek istiyorsanız, bunu yaptığınızda Docker Masaüstü çalıştığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="13fec-364">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="13fec-365">Docker Masaüstü çalışmıyorsa Sihirbazı başlattığınızda sihirbaz düzgün çalışmıyor.</span><span class="sxs-lookup"><span data-stu-id="13fec-365">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="13fec-366">Ayrıca, sihirbazın geçerli kapsayıcı seçiminizi doğru Docker desteği Ekle inceler.</span><span class="sxs-lookup"><span data-stu-id="13fec-366">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="13fec-367">Windows kapsayıcıları için destek eklemek istiyorsanız, Docker Windows yapılandırılmış kapsayıcılarla çalıştıran masaüstü varken, Sihirbazı çalıştırmak gerekir.</span><span class="sxs-lookup"><span data-stu-id="13fec-367">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="13fec-368">Linux kapsayıcıları için destek eklemek istiyorsanız, yapılandırılmış Linux kapsayıcıları ile çalışan Docker varken Sihirbazı'nı çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="13fec-368">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="13fec-369">Başvuruları – ortak web mimarileri</span><span class="sxs-lookup"><span data-stu-id="13fec-369">References – Common web architectures</span></span>
> - **<span data-ttu-id="13fec-370">Temiz mimarisi</span><span class="sxs-lookup"><span data-stu-id="13fec-370">The Clean Architecture</span></span>**  
>   <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - **<span data-ttu-id="13fec-371">Çoklu kare mimarisi</span><span class="sxs-lookup"><span data-stu-id="13fec-371">The Onion Architecture</span></span>**  
>   <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - **<span data-ttu-id="13fec-372">Depo düzeni</span><span class="sxs-lookup"><span data-stu-id="13fec-372">The Repository Pattern</span></span>**  
>   <https://deviq.com/repository-pattern/>
> - **<span data-ttu-id="13fec-373">Temiz mimarisi çözümü örneği</span><span class="sxs-lookup"><span data-stu-id="13fec-373">Clean Architecture Solution Sample</span></span>**  
>   <https://github.com/ardalis/cleanarchitecture>
> - **<span data-ttu-id="13fec-374">E-kitap mikro hizmet mimarileri oluşturma</span><span class="sxs-lookup"><span data-stu-id="13fec-374">Architecting Microservices e-book</span></span>**  
>   <https://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
><span data-ttu-id="13fec-375">[Önceki](architectural-principles.md)
>[İleri](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="13fec-375">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>

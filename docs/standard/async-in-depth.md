---
title: Zaman uyumsuz derinlemesine
description: Nasıl miyim/O-bağlı ve CPU bağımlı zaman uyumsuz kod yazmayı basit kullanarak .NET görev tabanlı zaman uyumsuz model olduğunu öğrenin.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 7b9017c30deebf6762b60d70e2be0b68ab5e27fc
ms.sourcegitcommit: 69bf8b719d4c289eec7b45336d0b933dd7927841
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2019
ms.locfileid: "57844742"
---
# <a name="async-in-depth"></a><span data-ttu-id="476cc-103">Zaman uyumsuz derinlemesine</span><span class="sxs-lookup"><span data-stu-id="476cc-103">Async in depth</span></span>

<span data-ttu-id="476cc-104">G/ç ve CPU sınır yazma zaman uyumsuz kod basit .NET görev tabanlı zaman uyumsuz model kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="476cc-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="476cc-105">Model tarafından sunulan `Task` ve `Task<T>` türleri ve `async` ve `await` C# ve Visual Basic anahtar sözcükleri.</span><span class="sxs-lookup"><span data-stu-id="476cc-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="476cc-106">(Dile özgü kaynakları bulunur [Ayrıca bkz:](#see-also) bölümüne.) Bu makalede .NET zaman uyumsuz nasıl kullanıldığını açıklar ve perde kullanılan zaman uyumsuz framework hakkında Öngörüler sağlar.</span><span class="sxs-lookup"><span data-stu-id="476cc-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-taskt"></a><span data-ttu-id="476cc-107">Görev ve görev\<T ></span><span class="sxs-lookup"><span data-stu-id="476cc-107">Task and Task\<T></span></span>

<span data-ttu-id="476cc-108">Görevleridir olarak bilinen uygulamak için kullanılan yapıları [, Promise modeli eşzamanlılık](https://en.wikipedia.org/wiki/Futures_and_promises).</span><span class="sxs-lookup"><span data-stu-id="476cc-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="476cc-109">Kısacası, bunlar sonraki bir noktada, "iş promise" tamamlanacak promise temiz bir API ile birlikte olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="476cc-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

* <span data-ttu-id="476cc-110">`Task` bir değer döndürmeyen tek bir işlemi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="476cc-110">`Task` represents a single operation which does not return a value.</span></span>
* <span data-ttu-id="476cc-111">`Task<T>` türünde bir değer döndüren tek bir işlemi temsil eden `T`.</span><span class="sxs-lookup"><span data-stu-id="476cc-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="476cc-112">Zaman uyumsuz olarak gerçekleştirilecek iş özetlerini görevleri hakkında daha fazla neden önemlidir ve *değil* iş parçacığı üzerinde bir soyutlamadır.</span><span class="sxs-lookup"><span data-stu-id="476cc-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="476cc-113">Varsayılan olarak, uygun işletim sistemi için geçerli iş parçacığı ve temsilci iş görevleri yürütün.</span><span class="sxs-lookup"><span data-stu-id="476cc-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="476cc-114">İsteğe bağlı olarak, görevleri açıkça ayrı bir iş parçacığı üzerinde çalıştırılacak istenebilir `Task.Run` API.</span><span class="sxs-lookup"><span data-stu-id="476cc-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="476cc-115">Görevleri izleme, üzerinde bekleyen ve sonuç değeri erişmek için bir API Protokolü kullanıma sunma (durumunda `Task<T>`) bir görev.</span><span class="sxs-lookup"><span data-stu-id="476cc-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="476cc-116">Dil Tümleştirmesi ile `await` anahtar sözcüğü, görevleri kullanarak için üst düzey bir Özet sağlar.</span><span class="sxs-lookup"><span data-stu-id="476cc-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span>

<span data-ttu-id="476cc-117">Kullanarak `await` görev tamamlanana kadar denetim çağırana sonuçlanmıyor tarafından bir görev devam ederken yararlı işlerini yapmak için uygulama veya hizmet verir.</span><span class="sxs-lookup"><span data-stu-id="476cc-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="476cc-118">Kodunuzun geri çağırmaları veya görev tamamlandıktan sonra yürütmeye devam etmeyi olayları dayalı gerekmez.</span><span class="sxs-lookup"><span data-stu-id="476cc-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="476cc-119">Görev API tümleştirmesi ve dil, sizin için yapar.</span><span class="sxs-lookup"><span data-stu-id="476cc-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="476cc-120">Kullanıyorsanız `Task<T>`, `await` anahtar sözcüğü ayrıca "sarmalamadan çıkarma" Görev tamamlandığında, döndürülen değer.</span><span class="sxs-lookup"><span data-stu-id="476cc-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="476cc-121">Bunun nasıl çalıştığını ayrıntıları, aşağıda daha ayrıntılı açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="476cc-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="476cc-122">Görevler ve onlarla etkileşim kurmak için farklı yollar hakkında daha fazla bilgi [görev tabanlı zaman uyumsuz desen (TAP)](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) konu.</span><span class="sxs-lookup"><span data-stu-id="476cc-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="476cc-123">Ben/O-bağlama işlemi için görevlere daha yakından bakın</span><span class="sxs-lookup"><span data-stu-id="476cc-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="476cc-124">Aşağıdaki bölümde, bir normal zaman uyumsuz g/ç çağrısı ile neler sunduğu 10.000 feet görünüm tanımlar.</span><span class="sxs-lookup"><span data-stu-id="476cc-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="476cc-125">Birkaç örnek ile başlayalım.</span><span class="sxs-lookup"><span data-stu-id="476cc-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="476cc-126">İlk örnek, bir zaman uyumsuz yöntemini çağırır ve, büyük olasılıkla henüz tamamlanmamış etkin bir görev döndürür.</span><span class="sxs-lookup"><span data-stu-id="476cc-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();

    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

<span data-ttu-id="476cc-127">İkinci örnek, kullanımını ekler `async` ve `await` görev üzerinde çalışmaya anahtar sözcükleri.</span><span class="sxs-lookup"><span data-stu-id="476cc-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();

    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");

    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.

    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="476cc-128">Çağrı `GetStringAsync()` çağrılar aracılığıyla bu kadar düşük düzeyli .NET kitaplıkları (belki başka bir zaman uyumsuz yöntem çağırmadan) ulaştığında bir P/Invoke birlikte çalışma çağrısına yerel ağ kitaplığı.</span><span class="sxs-lookup"><span data-stu-id="476cc-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="476cc-129">Yerel Kitaplığı daha sonra sistem API çağrısını çağırabilir (gibi `write()` Linux üzerinde bir yuva için).</span><span class="sxs-lookup"><span data-stu-id="476cc-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="476cc-130">Bir görev nesnesi, yerel ve yönetilen sınırında, büyük olasılıkla kullanarak oluşturulacak [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span><span class="sxs-lookup"><span data-stu-id="476cc-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="476cc-131">Görev nesnesi katmanından aktarılabilir, büyük olasılıkla üzerinde çalıştırılan veya doğrudan döndürülen, sonuçta ilk arayana döndürülür.</span><span class="sxs-lookup"><span data-stu-id="476cc-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span>

<span data-ttu-id="476cc-132">Yukarıdaki ikinci örnekte bir `Task<T>` nesne öğesinden döndürüleceği `GetStringAsync`.</span><span class="sxs-lookup"><span data-stu-id="476cc-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="476cc-133">Kullanımını `await` anahtar sözcüğü, yeni oluşturulan görev nesnesi döndürmek yöntemin neden olur.</span><span class="sxs-lookup"><span data-stu-id="476cc-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="476cc-134">Denetim, bu konumdan çağırana döner `GetFirstCharactersCountAsync` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="476cc-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="476cc-135">Özellikleri ve yöntemleri [görev&lt;T&gt; ](xref:System.Threading.Tasks.Task%601) etkinleştir çağıranlar GetFirstCharactersCountAsync kalan kod yürütüldüğünde tamamlayacak görev, ilerleyişini izlemek için nesne.</span><span class="sxs-lookup"><span data-stu-id="476cc-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="476cc-136">Sistem API çağrısından sonra isteği artık çekirdek alanında ağ alt sistemini yolu işletim sisteminin yapıyor (gibi `/net` Linux Çekirdeği'nde).</span><span class="sxs-lookup"><span data-stu-id="476cc-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="476cc-137">Burada, işletim Sisteminin ağ isteği işleyecek *zaman uyumsuz olarak*.</span><span class="sxs-lookup"><span data-stu-id="476cc-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="476cc-138">Ayrıntılar kullanılan işletim sistemi bağlı olarak farklı olabilir (cihaz sürücüsü çağrı çalışma zamanı geri gönderilen sinyal olarak zamanlanmış olabilir veya bir cihaz sürücüsü arama yapılabilir ve *ardından* geri gönderilen sinyal), ancak çalışma zamanı sonunda bildirilir Ağ isteği devam ediyor.</span><span class="sxs-lookup"><span data-stu-id="476cc-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="476cc-139">Şu anda, aygıt sürücüsünün ya da zamanlanmış, devam eden veya zaten tamamlandı (istek zaten kullanıma "kablo üzerinden" dır) - ancak bu tüm gerçekleştiği zaman uyumsuz olarak olduğundan, aygıt sürücüsünü hemen başka bir şey işleyebildiğinden çalışır!</span><span class="sxs-lookup"><span data-stu-id="476cc-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="476cc-140">Örneğin, Windows işletim sistemi iş parçacığı ağ cihaz sürücüsü çağrıda ve ağ üzerinden bir kesme istek Paketi'ni (IRP) işlemi gerçekleştirmek için bu işlemi temsil eden ister.</span><span class="sxs-lookup"><span data-stu-id="476cc-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="476cc-141">Aygıt sürücüsü IRP alır, ağ çağrıda, IRP "bekliyor" olarak işaretler ve işletim sistemine geri döndürür.</span><span class="sxs-lookup"><span data-stu-id="476cc-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="476cc-142">İşletim sistemi iş parçacığı artık IRP "bekliyor" olduğunu bildiğinden, bu proje için yapmak için daha fazla bir iş içermiyorsa ve "geri bu diğer işlemleri gerçekleştirmesi için kullanılabilir, böylece döndürür".</span><span class="sxs-lookup"><span data-stu-id="476cc-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="476cc-143">İstek yerine veri aygıt sürücüsü geri gelir, yeni veri kesme alınan CPU bildirir.</span><span class="sxs-lookup"><span data-stu-id="476cc-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="476cc-144">Bu kesme nasıl ele, işletim sistemi bağlı olarak farklılık gösterir ancak sistem birlikte çalışma çağrısı ulaşana kadar sonunda veriler işletim sistemi geçirilir (örneğin, Linux'ta bir kesme işleyicisi altındaki işletim sistemi veri iletmek için IRQ yarısını zamanlar  zaman uyumsuz olarak).</span><span class="sxs-lookup"><span data-stu-id="476cc-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="476cc-145">Not Bu *ayrıca* zaman uyumsuz olarak olur!</span><span class="sxs-lookup"><span data-stu-id="476cc-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="476cc-146">Sonucu bir sonraki kullanılabilir iş parçacığı bulabildiği kadar kuyruğa alınır zaman uyumsuz yöntemin ve "Tamamlanan görevin sonucu kaydırma".</span><span class="sxs-lookup"><span data-stu-id="476cc-146">The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="476cc-147">Tüm bu işlem boyunca bir güvenebileceğinizdir olan **iş parçacığının görevi çalıştırmak için adanmış**.</span><span class="sxs-lookup"><span data-stu-id="476cc-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="476cc-148">İş bazı bağlam içinde yürütülen rağmen (diğer bir deyişle, işletim sistemi veri iletmek için bir aygıt sürücüsü ve kesme için yanıt yok), için adanmış iş parçacığı yok *bekleyen* geri dönmeniz istek verileri.</span><span class="sxs-lookup"><span data-stu-id="476cc-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="476cc-149">Bu, sistemin bazı g/ç çağrısı tamamlanması bekleniyor yerine iş çok daha büyük bir birime işlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="476cc-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="476cc-150">Yukarıdaki birçok iş duvar saati süresi bakımından ölçüldüğünde yapılması gibi görünse de, bu, gerçek g/ç işi yapmak için gereken süreyi için karşılaştırıldığında miniscule olur.</span><span class="sxs-lookup"><span data-stu-id="476cc-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="476cc-151">Ancak hiç kesin olası zaman çizelgesi için böyle bir çağrı şuna benzer:</span><span class="sxs-lookup"><span data-stu-id="476cc-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="476cc-152">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="476cc-152">0-1————————————————————————————————————————————————–2-3</span></span>

* <span data-ttu-id="476cc-153">Harcanan süre noktalarından `0` için `1` kadar zaman uyumsuz bir yöntem denetimi onu arayan verir gereken her şey vardır.</span><span class="sxs-lookup"><span data-stu-id="476cc-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
* <span data-ttu-id="476cc-154">Harcanan süre noktalarından `1` için `2` maliyet herhangi bir CPU ile g/ç üzerinde harcanan zamanı.</span><span class="sxs-lookup"><span data-stu-id="476cc-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
* <span data-ttu-id="476cc-155">Son olarak, noktalarından harcanan süre `2` için `3` Denetim Arka (ve büyük olasılıkla bir değer) Bu noktada yürütme yaptığı yeniden zaman uyumsuz yönteme geçiyor.</span><span class="sxs-lookup"><span data-stu-id="476cc-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="476cc-156">Bu sunucu senaryosu için anlamı nedir?</span><span class="sxs-lookup"><span data-stu-id="476cc-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="476cc-157">Bu model, iyi bir tipik sunucu senaryosu iş yükü ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="476cc-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="476cc-158">Tamamlanmamış görevler üzerinde engelleme durumu adanmış iş parçacığı olduğundan sunucu işten web istekleri çok daha yüksek hacimde servis edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="476cc-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="476cc-159">İki sunucu göz önünde bulundurun: zaman uyumsuz kodu çalıştırır ve desteklemez.</span><span class="sxs-lookup"><span data-stu-id="476cc-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="476cc-160">Bu örneğin amacı doğrultusunda, her sunucuyla yalnızca 5 iş parçacıkları isteklerine hizmet kullanılabilir vardır.</span><span class="sxs-lookup"><span data-stu-id="476cc-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="476cc-161">Bu numaraları imaginarily küçük ve yalnızca gösterim bir bağlamda hizmet unutmayın.</span><span class="sxs-lookup"><span data-stu-id="476cc-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="476cc-162">Her iki sunucuyu 6 eş zamanlı istekleri almak varsayılır.</span><span class="sxs-lookup"><span data-stu-id="476cc-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="476cc-163">Her istek bir g/ç işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="476cc-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="476cc-164">Sunucu *olmadan* 5 iş parçacıklarından miyim/O-bağlı iş tamamlandı ve yanıt yazılan kadar 6 isteği sıraya almak zaman uyumsuz kod vardır.</span><span class="sxs-lookup"><span data-stu-id="476cc-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="476cc-165">Sıranın uzun alma nedeni 20 istek geldiğinde noktada aşağı yavaş sunucu başlayabilir.</span><span class="sxs-lookup"><span data-stu-id="476cc-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="476cc-166">Sunucu *ile* üzerinde çalıştırılan zaman uyumsuz kod hala 6 istek sıralarını ancak kullandığından `async` ve `await`, her iş parçacıklarını serbest yukarı miyim/O-işi başladığında yerine bittiğinde.</span><span class="sxs-lookup"><span data-stu-id="476cc-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="476cc-167">Gelen isteklerin çok daha küçük için zamanında 20 isteği, kuyrukta birlikte gelir. (hiçbir şey içinde hiç olup olmadığını), ve sunucu yavaşlamasına olmaz.</span><span class="sxs-lookup"><span data-stu-id="476cc-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="476cc-168">Bu contrived örnek olsa da, gerçek dünyadaki çok benzer bir biçimde çalışır.</span><span class="sxs-lookup"><span data-stu-id="476cc-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="476cc-169">Aslında, büyüklük kertesinde kullanarak daha fazla isteklerini işlemek bir sunucuya bekleyebileceğiniz `async` ve `await` her istek için bir iş parçacığı ayrılmış, aldığı daha.</span><span class="sxs-lookup"><span data-stu-id="476cc-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="476cc-170">Bu istemci senaryo için anlamı nedir?</span><span class="sxs-lookup"><span data-stu-id="476cc-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="476cc-171">Kullanmak için en büyük kazanç `async` ve `await` yanıt hızını artış için bir istemci uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="476cc-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="476cc-172">Uygulama yanıt iş parçacıkları tarafından el ile UNICODE yapabileceğiniz rağmen bir iş parçacığını üretme işlemi yalnızca kullanarak göre pahalı bir işlemdir `async` ve `await`.</span><span class="sxs-lookup"><span data-stu-id="476cc-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="476cc-173">Özellikle de benzer bir şey için bir mobil oyun, g/ç burada ilgilenmektedir UI iş parçacığı olabildiğince az etkileyerek çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="476cc-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="476cc-174">Ben/O-bağlı iş neredeyse hiçbir zaman CPU üzerinde harcadığı olduğundan daha da önemlisi, şekilleri faydalı bir iş gerçekleştirmek için bir tüm CPU iş parçacığı ayrılmış bir düşük kaynak kullanımını olacaktır.</span><span class="sxs-lookup"><span data-stu-id="476cc-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="476cc-175">Ayrıca, (örneğin, bir kullanıcı Arabirimi güncelleştirme) UI iş parçacığı için iş gönderme ile çok basit `async` yöntemleri ve ek iş (örneğin, bir iş parçacığı açısından güvenli temsilci çağırma) gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="476cc-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a><span data-ttu-id="476cc-176">Görev ve görev derinlemesine\<T > CPU bağımlı işlem için</span><span class="sxs-lookup"><span data-stu-id="476cc-176">Deeper Dive into Task and Task\<T> for a CPU-Bound Operation</span></span>

<span data-ttu-id="476cc-177">CPU bağımlı `async` kodudur miyim/O-sınırdan biraz farklı `async` kod.</span><span class="sxs-lookup"><span data-stu-id="476cc-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="476cc-178">İş CPU üzerinde yapıldığından, hesaplama için bir iş parçacığı ayrılması etrafında erişmenin bir yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="476cc-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="476cc-179">Kullanımını `async` ve `await` arka plan ile etkileşim kurmak için temiz bir yol, iş parçacığı ve hızlı yanıt veren zaman uyumsuz yöntemi çağıran kişi tutmak sağlar.</span><span class="sxs-lookup"><span data-stu-id="476cc-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="476cc-180">Bu paylaşılan veriler için herhangi bir koruma sağlamaz unutmayın.</span><span class="sxs-lookup"><span data-stu-id="476cc-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="476cc-181">Paylaşılan veri kullanıyorsanız, uygun eşitleme stratejisi uygulamak gerekecektir.</span><span class="sxs-lookup"><span data-stu-id="476cc-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="476cc-182">CPU bağımlı zaman uyumsuz çağrı sunduğu 10.000 feet görünümü şu şekildedir:</span><span class="sxs-lookup"><span data-stu-id="476cc-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));

    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!

    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;

    return result;
}
```

<span data-ttu-id="476cc-183">`CalculateResult()` iş parçacığında çağrıldı yürütür.</span><span class="sxs-lookup"><span data-stu-id="476cc-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="476cc-184">Çağırdığında, `Task.Run`, pahalı CPU bağımlı işlem kuyruklar `DoExpensiveCalculation()`, iş parçacığı havuzundaki ve alan bir `Task<int>` tanıtıcı.</span><span class="sxs-lookup"><span data-stu-id="476cc-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="476cc-185">`DoExpensiveCalculation()` sonunda eşzamanlı olarak sonraki kullanılabilir iş parçacığı üzerinde başka bir CPU çekirdeği üzerinde büyük olasılıkla çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="476cc-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="476cc-186">Sırasında eş zamanlı iş gerçekleştirmek mümkündür `DoExpensiveCalculation()` başka bir iş parçacığı üzerinde meşgul olduğundan çağrılan iş parçacığı `CalculateResult()` hala yürütülüyor.</span><span class="sxs-lookup"><span data-stu-id="476cc-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="476cc-187">Bir kez `await` karşılaşılırsa, yürütülmesini `CalculateResult()` sırasında geçerli iş parçacığı ile yapılacak diğer işleri izin vererek arayanına üretilenleri kaydeder `DoExpensiveCalculation()` bir sonuç ayrıldığı.</span><span class="sxs-lookup"><span data-stu-id="476cc-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="476cc-188">Tamamlandıktan sonra sonuç ana iş parçacığı üzerinde çalıştırılacak sıraya alınır.</span><span class="sxs-lookup"><span data-stu-id="476cc-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="476cc-189">Sonuç olarak, ana iş parçacığı yürütülen döndüreceği `CalculateResult()`, sonucunu olması, bu noktada `DoExpensiveCalculation()`.</span><span class="sxs-lookup"><span data-stu-id="476cc-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="476cc-190">Neden zaman uyumsuz burada yardımcı oldu mu?</span><span class="sxs-lookup"><span data-stu-id="476cc-190">Why does async help here?</span></span>

<span data-ttu-id="476cc-191">`async` ve `await` yanıt hızını gerektiğinde CPU bağımlı iş yönetimi için en iyi uygulamalardan biridir.</span><span class="sxs-lookup"><span data-stu-id="476cc-191">`async` and `await` are the best practice for managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="476cc-192">Zaman uyumsuz CPU bağımlı iş ile kullanmak için birden çok desen vardır.</span><span class="sxs-lookup"><span data-stu-id="476cc-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="476cc-193">Zaman uyumsuz kullanarak küçük bir maliyeti yoktur ve sıkı döngüler için önerilmez unutulmaması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="476cc-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="476cc-194">Kodunuzda bu yeni özellikten nasıl yazdığınız belirlemek size aittir.</span><span class="sxs-lookup"><span data-stu-id="476cc-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="476cc-195">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="476cc-195">See also</span></span>

- [<span data-ttu-id="476cc-196">C# zaman uyumsuz programlama</span><span class="sxs-lookup"><span data-stu-id="476cc-196">Asynchronous programming in C#</span></span>](~/docs/csharp/async.md)
- [<span data-ttu-id="476cc-197">Zaman uyumsuz programlama ile async ve await (C#)</span><span class="sxs-lookup"><span data-stu-id="476cc-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)
- [<span data-ttu-id="476cc-198">Zaman uyumsuz programlamaF#</span><span class="sxs-lookup"><span data-stu-id="476cc-198">Async Programming in F#</span></span>](~/docs/fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [<span data-ttu-id="476cc-199">Zaman uyumsuz programlama ile Async ve Await (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="476cc-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](~/docs/visual-basic/programming-guide/concepts/async/index.md)

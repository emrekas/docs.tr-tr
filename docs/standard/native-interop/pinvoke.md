---
title: Platform çağırma (P/Invoke)
description: .NET 'te P/Invoke aracılığıyla yerel işlevlerin nasıl çağrılacağını öğrenin.
author: jkoritzinsky
ms.author: jekoritz
ms.date: 01/18/2019
ms.openlocfilehash: cda738a173cbe61cf49f79ceef78c533a5a879d9
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/28/2019
ms.locfileid: "70106793"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="0e9b3-103">Platform çağırma (P/Invoke)</span><span class="sxs-lookup"><span data-stu-id="0e9b3-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="0e9b3-104">P/Invoke, yönetilen kodunuzun yönetilmeyen kitaplıklardaki yapılara, geri çağırmaları ve işlevlere erişmenize olanak tanıyan bir teknolojidir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="0e9b3-105">P/Invoke API 'sinin çoğu iki ad alanında yer alır: `System` ve. `System.Runtime.InteropServices`</span><span class="sxs-lookup"><span data-stu-id="0e9b3-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="0e9b3-106">Bu iki ad alanını kullanmak, yerel bileşenle nasıl iletişim kurmak istediğinizi betimleyen araçlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="0e9b3-107">En yaygın örnek, ve yönetilen kodunuzda yönetilmeyen işlevleri çağıran için başlayalım.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="0e9b3-108">Komut satırı uygulamasından bir ileti kutusu gösterelim:</span><span class="sxs-lookup"><span data-stu-id="0e9b3-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="0e9b3-109">Önceki örnek basittir, ancak yönetilen koddan yönetilmeyen işlevleri çağırmak için nelerin gerekli olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="0e9b3-110">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="0e9b3-110">Let’s step through the example:</span></span>

- <span data-ttu-id="0e9b3-111">Line #1, `System.Runtime.InteropServices` gereken tüm öğeleri tutan ad alanı için using ifadesini gösterir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-111">Line #1 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="0e9b3-112">Satır #7 `DllImport` özniteliği tanıtır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-112">Line #7 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="0e9b3-113">Bu öznitelik, çalışma zamanına yönetilmeyen DLL yüklemesi gerektiğini söylediğinden önemlidir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="0e9b3-114">Geçirilen dize, hedef işlevimizin bulunduğu DLL 'dir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="0e9b3-115">Ayrıca, dizeleri sıralamak için kullanılacak [karakter kümesini](./charset.md) belirtir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="0e9b3-116">Son olarak, bu işlevin [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) öğesini çağırdığından ve çalışma zamanının, kullanıcının aracılığıyla <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>alabilmesi için hata kodunu yakalamasına yönelik olduğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="0e9b3-117">Line #8, P/Invoke işinin Crux 'tir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-117">Line #8 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="0e9b3-118">Yönetilmeyen bir **imzayla aynı imzaya** sahip bir yönetilen yöntemi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="0e9b3-119">Bildiriminde, çalışma zamanına bir dış yöntem olduğunu söyleyen ve bunu `extern`çağırdığınızda çalışma zamanının onu `DllImport` özniteliğinde belirtilen DLL 'de bulması gerektiğini fark eden yeni bir anahtar sözcük vardır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="0e9b3-120">Örneğin geri kalanı, yöntemi diğer yönetilen yöntemler gibi çağırmak için yalnızca yöntemini çağırır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="0e9b3-121">Örnek, macOS için benzerdir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-121">The sample is similar for macOS.</span></span> <span data-ttu-id="0e9b3-122">MacOS, adlandırma dinamik kitaplıklarının farklı `DllImport` bir şemasına sahip olduğundan, öznitelikteki kitaplığın adının değişmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="0e9b3-123">Aşağıdaki örnek, uygulamanın işlem `getpid(2)` kimliğini almak ve konsola yazdırmak için işlevini kullanır:</span><span class="sxs-lookup"><span data-stu-id="0e9b3-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="0e9b3-124">Linux üzerinde de benzerdir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-124">It is also similar on Linux.</span></span> <span data-ttu-id="0e9b3-125">İşlev adı, standart bir [POSIX](https://en.wikipedia.org/wiki/POSIX) sistem çağrısı `getpid(2)` olduğundan aynıdır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="0e9b3-126">Yönetilmeyen koddan yönetilen kodu çağırma</span><span class="sxs-lookup"><span data-stu-id="0e9b3-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="0e9b3-127">Çalışma zamanı, iletişimin her iki yönde de akmasını sağlar ve işlev işaretçilerini kullanarak yerel işlevlerden yönetilen koda geri çağrı yapmanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="0e9b3-128">Yönetilen koddaki bir işlev işaretçisi için en yakın şey bir **temsilcisidir**, bu nedenle yerel koddan yönetilen koda geri çağırmaları sağlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="0e9b3-129">Bu özelliği kullanmanın yöntemi, daha önce açıklanan yönetilen to Native işleme benzerdir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="0e9b3-130">Belirli bir geri çağırma için imzayla eşleşen bir temsilci tanımlayın ve bunu dış yönteme geçirin.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="0e9b3-131">Çalışma zamanı, diğer her şeyi ele alır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="0e9b3-132">Bu örnekte yürüyerek, birlikte çalışmanız gereken yönetilmeyen işlevlerin imzalarını gözden geçirmeniz iyi olur.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="0e9b3-133">Tüm pencereleri numaralandırmak için çağrılacak işlev aşağıdaki imzaya sahiptir:`BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="0e9b3-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="0e9b3-134">İlk parametre bir geri çağırmasıdır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-134">The first parameter is a callback.</span></span> <span data-ttu-id="0e9b3-135">Söyde bulunan geri çağırma aşağıdaki imzaya sahiptir:`BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="0e9b3-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="0e9b3-136">Şimdi örnek olarak şunu inceleyelim:</span><span class="sxs-lookup"><span data-stu-id="0e9b3-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="0e9b3-137">Örnekteki satır #9, yönetilmeyen koddan geri aramanın imzasıyla eşleşen bir temsilciyi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="0e9b3-138">LParam ve HWND türlerinin yönetilen kodda kullanarak `IntPtr` nasıl temsil edileceğini görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="0e9b3-139">Satırlar #13 ve #14 User32. `EnumWindows` dll kitaplığından işlevi ortaya çıkarabilir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="0e9b3-140">Satır #17-20 temsilciyi uygular.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="0e9b3-141">Bu basit örnek için, tanıtıcıyı yalnızca konsola çıkarmak istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="0e9b3-142">Son olarak, satır #24, dış yöntem, temsilciyle çağrılır ve geçirilir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="0e9b3-143">Linux ve macOS örnekleri aşağıda gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="0e9b3-144">Bunlar için, C Kitaplığı 'nda `ftw` `libc`bulunan işlevini kullanırız.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="0e9b3-145">Bu işlev dizin hiyerarşileri arasında geçiş yapmak için kullanılır ve parametrelerinden biri olarak bir işlev işaretçisi alır.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="0e9b3-146">Diyor işlevi şu imzaya sahiptir: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="0e9b3-147">MacOS örneği aynı işlevi kullanır ve MacOS farklı bir yerde devam `DllImport` `libc` ederken, tek fark özniteliğin bağımsız değişkenidir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="0e9b3-148">Yukarıdaki örneklerin her ikisi de parametrelere bağımlıdır ve her iki durumda da parametreler yönetilen türler olarak verilir.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="0e9b3-149">Çalışma zamanı "doğru şeyi" yapar ve bunları diğer tarafta eşdeğerleri halinde işler.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="0e9b3-150">Türlerin [tür sıralaması](type-marshaling.md)üzerindeki sayfamızda yerel koda nasıl sıralantığından ilgili bilgi edinin.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="0e9b3-151">Daha fazla kaynak</span><span class="sxs-lookup"><span data-stu-id="0e9b3-151">More resources</span></span>

- <span data-ttu-id="0e9b3-152">[PInvoke.net wiki](https://www.pinvoke.net/) , yaygın Windows API 'leri ve bunların nasıl çağrılacağını içeren harika bir wiki.</span><span class="sxs-lookup"><span data-stu-id="0e9b3-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="0e9b3-153">/CLI ' da C++P/Invoke</span><span class="sxs-lookup"><span data-stu-id="0e9b3-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="0e9b3-154">P/Invoke üzerinde mono belgeleri</span><span class="sxs-lookup"><span data-stu-id="0e9b3-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)

---
title: 'Nesne Ömrü: Nesneler oluşturma ve yok etme (Visual Basic)'
ms.date: 07/20/2015
f1_keywords:
- vb.Constructor
helpviewer_keywords:
- destructors, object lifetime
- Sub Finalize destructor
- objects [Visual Basic], destroying
- lifetime [Visual Basic], objects
- Sub New constructor, object lifetime
- Finalize method [Visual Basic], object lifetime
- objects [Visual Basic], creating
- Class_Terminate
- Dispose method [Visual Basic], object lifetime
- Class_Initialize
- object creation [Visual Basic], object lifetime
- parameterized constructors
- objects [Visual Basic], lifetime
- objects [Visual Basic], garbage collection
- constructors [Visual Basic], object lifetime
- Sub Dispose destructor
- garbage collection [Visual Basic], Visual Basic
ms.assetid: f1ee8458-b156-44e0-9a8a-5dd171648cd8
ms.openlocfilehash: 5b092f50ddff5c432fbd6396b5fedafe7a6acba0
ms.sourcegitcommit: 463f3f050cecc0b6403e67f19a61f870fb8e7b7d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/26/2019
ms.locfileid: "68512836"
---
# <a name="object-lifetime-how-objects-are-created-and-destroyed-visual-basic"></a><span data-ttu-id="e4cc7-102">Nesne Ömrü: Nesneler oluşturma ve yok etme (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="e4cc7-102">Object Lifetime: How Objects Are Created and Destroyed (Visual Basic)</span></span>

<span data-ttu-id="e4cc7-103">Bir sınıf örneği, bir nesnesi, `New` anahtar sözcüğü kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-103">An instance of a class, an object, is created by using the `New` keyword.</span></span> <span data-ttu-id="e4cc7-104">Başlatma görevleri genellikle yeni nesnelerde kullanılmadan önce gerçekleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-104">Initialization tasks often must be performed on new objects before they are used.</span></span> <span data-ttu-id="e4cc7-105">Ortak başlatma görevleri, dosyaları açmayı, veritabanlarına bağlanmayı ve kayıt defteri anahtarlarının değerlerini okumayı içerir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-105">Common initialization tasks include opening files, connecting to databases, and reading values of registry keys.</span></span> <span data-ttu-id="e4cc7-106">Visual Basic, *oluşturucular* (başlatma üzerinde denetime izin veren özel yöntemler) adlı yordamları kullanarak yeni nesnelerin başlatılmasını denetler.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-106">Visual Basic controls the initialization of new objects using procedures called *constructors* (special methods that allow control over initialization).</span></span>

<span data-ttu-id="e4cc7-107">Bir nesne kapsamdan ayrıldığında, ortak dil çalışma zamanı (CLR) tarafından serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-107">After an object leaves scope, it is released by the common language runtime (CLR).</span></span> <span data-ttu-id="e4cc7-108">Visual Basic, yok *ediciler*adlı yordamları kullanarak sistem kaynakları sürümünü denetler.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-108">Visual Basic controls the release of system resources using procedures called *destructors*.</span></span> <span data-ttu-id="e4cc7-109">Birlikte, oluşturucular ve Yıkıcılar sağlam ve öngörülebilir sınıf kitaplıklarının oluşturulmasını destekler.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-109">Together, constructors and destructors support the creation of robust and predictable class libraries.</span></span>

## <a name="using-constructors-and-destructors"></a><span data-ttu-id="e4cc7-110">Oluşturucular ve yıkıcıları kullanma</span><span class="sxs-lookup"><span data-stu-id="e4cc7-110">Using Constructors and Destructors</span></span>

<span data-ttu-id="e4cc7-111">Oluşturucular ve Yıkıcılar nesnelerin oluşturulmasını ve yok edilmesini denetler.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-111">Constructors and destructors control the creation and destruction of objects.</span></span> <span data-ttu-id="e4cc7-112">Visual Basic `Sub New` ve `Sub Finalize` , nesneleribaşlatma`Class_Terminate` ve yok etme ' daki ve yordamları, Visual Basic 6,0 ve önceki sürümlerde kullanılan veyöntemlerinideğiştirir.`Class_Initialize`</span><span class="sxs-lookup"><span data-stu-id="e4cc7-112">The `Sub New` and `Sub Finalize` procedures in Visual Basic initialize and destroy objects; they replace the `Class_Initialize` and `Class_Terminate` methods used in Visual Basic 6.0 and earlier versions.</span></span>

### <a name="sub-new"></a><span data-ttu-id="e4cc7-113">Yeni Sub</span><span class="sxs-lookup"><span data-stu-id="e4cc7-113">Sub New</span></span>

<span data-ttu-id="e4cc7-114">Oluşturucu `Sub New` , bir sınıf oluşturulduğunda yalnızca bir kez çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-114">The `Sub New` constructor can run only once when a class is created.</span></span> <span data-ttu-id="e4cc7-115">Aynı sınıftan ya da türetilmiş bir sınıftan başka bir oluşturucunun kod ilk satırında dışında, açıkça çağrılamaz.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-115">It cannot be called explicitly anywhere other than in the first line of code of another constructor from either the same class or from a derived class.</span></span> <span data-ttu-id="e4cc7-116">Ayrıca, `Sub New` yöntemi içindeki kod her zaman bir sınıftaki diğer koddan önce çalışır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-116">Furthermore, the code in the `Sub New` method always runs before any other code in a class.</span></span> <span data-ttu-id="e4cc7-117">Bir sınıf için açıkça bir `Sub New` `Sub New` yordam tanımlamadıysanız, Visual Basic ve sonraki sürümler, çalışma zamanında örtük olarak bir Oluşturucu oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-117">Visual Basic and later versions implicitly create a `Sub New` constructor at run time if you do not explicitly define a `Sub New` procedure for a class.</span></span>

<span data-ttu-id="e4cc7-118">Bir sınıf için Oluşturucu oluşturmak için, sınıf tanımında herhangi bir yerde `Sub New` adlı bir yordam oluşturun.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-118">To create a constructor for a class, create a procedure named `Sub New` anywhere in the class definition.</span></span> <span data-ttu-id="e4cc7-119">Parametreli bir Oluşturucu oluşturmak için, aşağıdaki kodda olduğu gibi, diğer herhangi bir yordam `Sub New` için bağımsız değişkenler belirttiğinizde olduğu gibi, bağımsız değişkenlerin adlarını ve veri türlerini belirtin:</span><span class="sxs-lookup"><span data-stu-id="e4cc7-119">To create a parameterized constructor, specify the names and data types of arguments to `Sub New` just as you would specify arguments for any other procedure, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#42)]

<span data-ttu-id="e4cc7-120">Oluşturucular, aşağıdaki kodda olduğu gibi sıklıkla aşırı yüklenmiştir:</span><span class="sxs-lookup"><span data-stu-id="e4cc7-120">Constructors are frequently overloaded, as in the following code:</span></span>

[!code-vb[VbVbalrOOP#116](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/WhidbeyStuff.vb#116)]

<span data-ttu-id="e4cc7-121">Başka bir sınıftan türetilmiş bir sınıf tanımladığınızda, temel sınıfın hiçbir parametre alan erişilebilir bir Oluşturucusu yoksa, oluşturucunun ilk satırı temel sınıfın oluşturucusuna bir çağrı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-121">When you define a class derived from another class, the first line of a constructor must be a call to the constructor of the base class, unless the base class has an accessible constructor that takes no parameters.</span></span> <span data-ttu-id="e4cc7-122">Yukarıdaki oluşturucuyu içeren temel sınıfa yapılan bir çağrı (örneğin, `MyBase.New(s)`).</span><span class="sxs-lookup"><span data-stu-id="e4cc7-122">A call to the base class that contains the above constructor, for example, would be `MyBase.New(s)`.</span></span> <span data-ttu-id="e4cc7-123">Aksi takdirde `MyBase.New` , isteğe bağlıdır ve Visual Basic çalışma zamanı onu örtülü olarak çağırır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-123">Otherwise, `MyBase.New` is optional, and the Visual Basic runtime calls it implicitly.</span></span>

<span data-ttu-id="e4cc7-124">Üst nesnenin oluşturucusunu çağırmak için kodu yazdıktan sonra, `Sub New` yordama ek başlatma kodu ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-124">After you write the code to call the parent object's constructor, you can add any additional initialization code to the `Sub New` procedure.</span></span> <span data-ttu-id="e4cc7-125">`Sub New`Parametreli bir Oluşturucu olarak çağrıldığında bağımsız değişkenleri kabul edebilir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-125">`Sub New` can accept arguments when called as a parameterized constructor.</span></span> <span data-ttu-id="e4cc7-126">Bu parametreler, Oluşturucu çağıran yordamdan geçirilir, örneğin, `Dim AnObject As New ThisClass(X)`.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-126">These parameters are passed from the procedure calling the constructor, for example, `Dim AnObject As New ThisClass(X)`.</span></span>

### <a name="sub-finalize"></a><span data-ttu-id="e4cc7-127">Sub Finalize</span><span class="sxs-lookup"><span data-stu-id="e4cc7-127">Sub Finalize</span></span>

<span data-ttu-id="e4cc7-128">Nesneleri serbest bırakmadan önce clr, bir `Finalize` `Sub Finalize` yordamı tanımlayan nesneler için yöntemini otomatik olarak çağırır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-128">Before releasing objects, the CLR automatically calls the `Finalize` method for objects that define a `Sub Finalize` procedure.</span></span> <span data-ttu-id="e4cc7-129">`Finalize` Yöntemi, dosyaları kapatmak ve durum bilgilerini kaydetmek için kod gibi bir nesne yok etmeden önce yürütülmesi gereken kodu içerebilir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-129">The `Finalize` method can contain code that needs to execute just before an object is destroyed, such as code for closing files and saving state information.</span></span> <span data-ttu-id="e4cc7-130">Yürütmeye `Sub Finalize`yönelik hafif bir performans cezası var, bu nedenle yalnızca nesneleri açıkça `Sub Finalize` serbest bırakmanız gerektiğinde bir yöntemi tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-130">There is a slight performance penalty for executing `Sub Finalize`, so you should define a `Sub Finalize` method only when you need to release objects explicitly.</span></span>

> [!NOTE]
> <span data-ttu-id="e4cc7-131">CLR içindeki çöp toplayıcı *yönetilmeyen nesneleri*, işletim sisteminin doğrudan ÇALıŞTıRDıĞı nesneleri clr ortamının dışında vermez (ve kullanamaz).</span><span class="sxs-lookup"><span data-stu-id="e4cc7-131">The garbage collector in the CLR does not (and cannot) dispose of *unmanaged objects*, objects that the operating system executes directly, outside the CLR environment.</span></span> <span data-ttu-id="e4cc7-132">Bunun nedeni, farklı yönetilmeyen nesnelerin farklı yollarla atılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-132">This is because different unmanaged objects must be disposed of in different ways.</span></span> <span data-ttu-id="e4cc7-133">Bu bilgiler, yönetilmeyen nesneyle doğrudan ilişkili değildir; nesnenin belgelerinde bulunması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-133">That information is not directly associated with the unmanaged object; it must be found in the documentation for the object.</span></span> <span data-ttu-id="e4cc7-134">Yönetilmeyen nesneler kullanan bir sınıf, kendi `Finalize` metodunda onları atmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-134">A class that uses unmanaged objects must dispose of them in its `Finalize` method.</span></span>

<span data-ttu-id="e4cc7-135">`Finalize` Yıkıcı, yalnızca ait olduğu sınıftan veya türetilmiş sınıflardan çağrılabilen, korunan bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-135">The `Finalize` destructor is a protected method that can be called only from the class it belongs to, or from derived classes.</span></span> <span data-ttu-id="e4cc7-136">Bir nesne yok `Finalize` edildiğinde sistem otomatik olarak çağrılır, bu nedenle türetilmiş sınıfın `Finalize` uygulamasının dışından açık `Finalize` bir şekilde çağırmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-136">The system calls `Finalize` automatically when an object is destroyed, so you should not explicitly call `Finalize` from outside of a derived class's `Finalize` implementation.</span></span>

<span data-ttu-id="e4cc7-137">Bir nesne hiçbir şey olarak ayarlandığında çalıştırılan bir şekilde, genellikle bir nesnenin kapsam kaybettiğinde ve Visual Basic `Finalize` yıkıcıyı çağırdığında bir gecikme vardır. `Class_Terminate`</span><span class="sxs-lookup"><span data-stu-id="e4cc7-137">Unlike `Class_Terminate`, which executes as soon as an object is set to nothing, there is usually a delay between when an object loses scope and when Visual Basic calls the `Finalize` destructor.</span></span> <span data-ttu-id="e4cc7-138">Visual Basic ve sonraki sürümler, kaynakları hemen serbest bırakmak için herhangi bir <xref:System.IDisposable.Dispose%2A>zamanda açıkça çağrılabilecek ikinci bir tür yıkıcı için izin verir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-138">Visual Basic and later versions allow for a second kind of destructor, <xref:System.IDisposable.Dispose%2A>, which can be explicitly called at any time to immediately release resources.</span></span>

> [!NOTE]
> <span data-ttu-id="e4cc7-139">`Finalize` Yıkıcı, uygulama tarafından işlenemediği ve uygulamanın sonlandırılmasına neden olabileceği için özel durumlar oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-139">A `Finalize` destructor should not throw exceptions, because they cannot be handled by the application and can cause the application to terminate.</span></span>

### <a name="how-new-and-finalize-methods-work-in-a-class-hierarchy"></a><span data-ttu-id="e4cc7-140">Yeni ve sonlandırma yöntemlerinin bir sınıf hiyerarşisinde çalışması</span><span class="sxs-lookup"><span data-stu-id="e4cc7-140">How New and Finalize Methods Work in a Class Hierarchy</span></span>

<span data-ttu-id="e4cc7-141">Bir sınıf örneği oluşturulduğunda, ortak dil çalışma zamanı (CLR), bu nesnede varsa adlı `New`bir yordamı yürütmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-141">Whenever an instance of a class is created, the common language runtime (CLR) attempts to execute a procedure named `New`, if it exists in that object.</span></span> <span data-ttu-id="e4cc7-142">`New`, bir nesne içindeki diğer herhangi bir `constructor` kod yürütülmeden önce yeni nesneleri başlatmak için kullanılan adlı bir yordam türüdür.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-142">`New` is a type of procedure called a `constructor` that is used to initialize new objects before any other code in an object executes.</span></span> <span data-ttu-id="e4cc7-143">Bir `New` Oluşturucu, dosyaları açmak, veritabanlarına bağlanmak, değişkenleri başlatmak ve bir nesne kullanılmadan önce gerçekleştirilmesi gereken diğer görevlerden yararlanmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-143">A `New` constructor can be used to open files, connect to databases, initialize variables, and take care of any other tasks that need to be done before an object can be used.</span></span>

<span data-ttu-id="e4cc7-144">Türetilmiş bir sınıfın bir örneği oluşturulduğunda, `Sub New` önce temel sınıfın Oluşturucusu yürütülür ve ardından türetilmiş sınıflardaki oluşturucular tarafından yürütülür.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-144">When an instance of a derived class is created, the `Sub New` constructor of the base class executes first, followed by constructors in derived classes.</span></span> <span data-ttu-id="e4cc7-145">Bu durum, bir `Sub New` oluşturucudaki ilk kod satırı, sınıf hiyerarşisinde kendisinin hemen üzerinde bulunan sınıfının oluşturucusunu çağırmak için sözdizimini `MyBase.New()`kullandığından oluşur.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-145">This happens because the first line of code in a `Sub New` constructor uses the syntax `MyBase.New()`to call the constructor of the class immediately above itself in the class hierarchy.</span></span> <span data-ttu-id="e4cc7-146">Daha `Sub New` sonra Oluşturucu, temel sınıfa yönelik oluşturucuya ulaşılana kadar sınıf hiyerarşisindeki her sınıf için çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-146">The `Sub New` constructor is then called for each class in the class hierarchy until the constructor for the base class is reached.</span></span> <span data-ttu-id="e4cc7-147">Bu noktada, temel sınıf için oluşturucudaki kod yürütülür ve ardından tüm türetilmiş sınıflarda bulunan kod ve en son türetilen sınıflardaki kod son olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-147">At that point, the code in the constructor for the base class executes, followed by the code in each constructor in all derived classes and the code in the most derived classes is executed last.</span></span>

![Sınıf hiyerarşisi oluşturucularını ve devralmayı gösteren ekran görüntüsü.](./media/object-lifetime-how-objects-are-created-and-destroyed/subnew-constructor-inheritance.gif)

<span data-ttu-id="e4cc7-149">Bir nesne artık gerekli olmadığında, CLR bellekten boşaltmadan önce bu <xref:System.Object.Finalize%2A> nesnenin yöntemini çağırır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-149">When an object is no longer needed, the CLR calls the <xref:System.Object.Finalize%2A> method for that object before freeing its memory.</span></span> <span data-ttu-id="e4cc7-150">Yöntemi, durum bilgilerini kaydetme `destructor` , veritabanlarına yönelik dosya ve veritabanına bağlantı kapatma gibi temizleme görevlerini gerçekleştirdiğinden ve nesneyi serbest bırakmadan önce gerçekleştirilmesi gereken diğer görevlere yönelik olarak adlandırılır. <xref:System.Object.Finalize%2A></span><span class="sxs-lookup"><span data-stu-id="e4cc7-150">The <xref:System.Object.Finalize%2A> method is called a `destructor` because it performs cleanup tasks, such as saving state information, closing files and connections to databases, and other tasks that must be done before releasing the object.</span></span>

![Finalize yöntemi yıkıcısını gösteren ekran görüntüsü.](./media/object-lifetime-how-objects-are-created-and-destroyed/finalize-method-destructor.gif)

## <a name="idisposable-interface"></a><span data-ttu-id="e4cc7-152">IDisposable arabirimi</span><span class="sxs-lookup"><span data-stu-id="e4cc7-152">IDisposable Interface</span></span>

<span data-ttu-id="e4cc7-153">Sınıf örnekleri genellikle Windows işleyicileri ve veritabanı bağlantıları gibi CLR tarafından yönetilmeyen kaynakları denetler.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-153">Class instances often control resources not managed by the CLR, such as Windows handles and database connections.</span></span> <span data-ttu-id="e4cc7-154">Bu kaynaklar, nesne çöp toplayıcı tarafından yok `Finalize` edildiğinde yayımlanabilmeleri için sınıfının yönteminde atılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-154">These resources must be disposed of in the `Finalize` method of the class, so that they will be released when the object is destroyed by the garbage collector.</span></span> <span data-ttu-id="e4cc7-155">Ancak çöp toplayıcı yalnızca CLR daha fazla boş bellek gerektirdiğinde nesneleri yok eder.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-155">However, the garbage collector destroys objects only when the CLR requires more free memory.</span></span> <span data-ttu-id="e4cc7-156">Bu, nesnenin kapsam dışına çıkana kadar uzun sürebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-156">This means that the resources may not be released until long after the object goes out of scope.</span></span>

<span data-ttu-id="e4cc7-157">Atık toplamayı tamamlamak için sınıflarınız, <xref:System.IDisposable> arabirimi uygularsa sistem kaynaklarını etkin bir şekilde yönetmeye yönelik bir mekanizma sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-157">To supplement garbage collection, your classes can provide a mechanism to actively manage system resources if they implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="e4cc7-158"><xref:System.IDisposable>, istemcileri bir nesne <xref:System.IDisposable.Dispose%2A>kullanmayı tamamlarsa çağrı gereken tek bir yöntemine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-158"><xref:System.IDisposable> has one method, <xref:System.IDisposable.Dispose%2A>, which clients should call when they finish using an object.</span></span> <span data-ttu-id="e4cc7-159">Yöntemi, <xref:System.IDisposable.Dispose%2A> kaynakları hemen serbest bırakmak ve dosya ve veritabanı bağlantıları kapatma gibi görevleri gerçekleştirmek için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-159">You can use the <xref:System.IDisposable.Dispose%2A> method to immediately release resources and perform tasks such as closing files and database connections.</span></span> <span data-ttu-id="e4cc7-160">Yok edicinin aksine, yöntemi otomatik olarak çağrılmaz. <xref:System.IDisposable.Dispose%2A> `Finalize`</span><span class="sxs-lookup"><span data-stu-id="e4cc7-160">Unlike the `Finalize` destructor, the <xref:System.IDisposable.Dispose%2A> method is not called automatically.</span></span> <span data-ttu-id="e4cc7-161">Bir sınıfın istemcileri, kaynakları hemen serbest <xref:System.IDisposable.Dispose%2A> bırakmak istediğinizde açıkça çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-161">Clients of a class must explicitly call <xref:System.IDisposable.Dispose%2A> when you want to immediately release resources.</span></span>

### <a name="implementing-idisposable"></a><span data-ttu-id="e4cc7-162">IDisposable uygulama</span><span class="sxs-lookup"><span data-stu-id="e4cc7-162">Implementing IDisposable</span></span>

<span data-ttu-id="e4cc7-163"><xref:System.IDisposable> Arabirimi uygulayan bir sınıf şu kod bölümlerini içermelidir:</span><span class="sxs-lookup"><span data-stu-id="e4cc7-163">A class that implements the <xref:System.IDisposable> interface should include these sections of code:</span></span>

- <span data-ttu-id="e4cc7-164">Nesnenin atılmış olup olmadığını izlemek için bir alan:</span><span class="sxs-lookup"><span data-stu-id="e4cc7-164">A field for keeping track of whether the object has been disposed:</span></span>

  ```vb
  Protected disposed As Boolean = False
  ```

- <span data-ttu-id="e4cc7-165"><xref:System.IDisposable.Dispose%2A> Sınıfının kaynaklarını serbest bırakır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-165">An overload of the <xref:System.IDisposable.Dispose%2A> that frees the class's resources.</span></span> <span data-ttu-id="e4cc7-166">Bu yöntem, <xref:System.IDisposable.Dispose%2A> taban sınıfının ve `Finalize` yöntemleri tarafından çağrılmalıdır:</span><span class="sxs-lookup"><span data-stu-id="e4cc7-166">This method should be called by the <xref:System.IDisposable.Dispose%2A> and `Finalize` methods of the base class:</span></span>

  ```vb
  Protected Overridable Sub Dispose(ByVal disposing As Boolean)
      If Not Me.disposed Then
          If disposing Then
              ' Insert code to free managed resources.
          End If
          ' Insert code to free unmanaged resources.
      End If
      Me.disposed = True
  End Sub
  ```

- <span data-ttu-id="e4cc7-167">Yalnızca aşağıdaki kodu <xref:System.IDisposable.Dispose%2A> içeren bir uygulamasıdır:</span><span class="sxs-lookup"><span data-stu-id="e4cc7-167">An implementation of <xref:System.IDisposable.Dispose%2A> that contains only the following code:</span></span>

  ```vb
  Public Sub Dispose() Implements IDisposable.Dispose
      Dispose(True)
      GC.SuppressFinalize(Me)
  End Sub
  ```

- <span data-ttu-id="e4cc7-168">Yalnızca aşağıdaki kodu içeren `Finalize` yöntemi geçersiz kılma:</span><span class="sxs-lookup"><span data-stu-id="e4cc7-168">An override of the `Finalize` method that contains only the following code:</span></span>

  ```vb
  Protected Overrides Sub Finalize()
      Dispose(False)
      MyBase.Finalize()
  End Sub
  ```

### <a name="deriving-from-a-class-that-implements-idisposable"></a><span data-ttu-id="e4cc7-169">IDisposable uygulayan bir sınıftan türetme</span><span class="sxs-lookup"><span data-stu-id="e4cc7-169">Deriving from a Class that Implements IDisposable</span></span>

<span data-ttu-id="e4cc7-170"><xref:System.IDisposable> Arabirimi uygulayan bir taban sınıftan türetilen bir sınıf, atılmalıdır ek kaynaklar kullanmadığı takdirde hiçbir temel yöntemi geçersiz kılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-170">A class that derives from a base class that implements the <xref:System.IDisposable> interface does not need to override any of the base methods unless it uses additional resources that need to be disposed.</span></span> <span data-ttu-id="e4cc7-171">Bu durumda, türetilmiş sınıf türetilmiş sınıfın kaynaklarını atmak için temel sınıfın `Dispose(disposing)` yöntemini geçersiz kılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-171">In that situation, the derived class should override the base class's `Dispose(disposing)` method to dispose of the derived class's resources.</span></span> <span data-ttu-id="e4cc7-172">Bu geçersiz kılma, temel sınıfın `Dispose(disposing)` yöntemini çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-172">This override must call the base class's `Dispose(disposing)` method.</span></span>

```vb
Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    If Not Me.disposed Then
        If disposing Then
            ' Insert code to free managed resources.
        End If
        ' Insert code to free unmanaged resources.
    End If
    MyBase.Dispose(disposing)
End Sub
```

<span data-ttu-id="e4cc7-173">Türetilmiş bir sınıf temel sınıfın <xref:System.IDisposable.Dispose%2A> ve `Finalize` yöntemlerinin üzerine içermemelidir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-173">A derived class should not override the base class's <xref:System.IDisposable.Dispose%2A> and `Finalize` methods.</span></span> <span data-ttu-id="e4cc7-174">Bu yöntemler türetilmiş sınıfın bir örneğinden çağrıldığında, taban sınıfın bu yöntemlerin uygulanması, türetilmiş sınıfın `Dispose(disposing)` yönteminin geçersiz kılmasını çağırır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-174">When those methods are called from an instance of the derived class, the base class's implementation of those methods call the derived class's override of the `Dispose(disposing)` method.</span></span>

## <a name="garbage-collection-and-the-finalize-destructor"></a><span data-ttu-id="e4cc7-175">Çöp toplama ve sonlandırma yıkıcısı</span><span class="sxs-lookup"><span data-stu-id="e4cc7-175">Garbage Collection and the Finalize Destructor</span></span>

<span data-ttu-id="e4cc7-176">.NET Framework, kullanılmayan kaynakları düzenli aralıklarla serbest bırakmak için *başvuru izleme atık toplama* sistemini kullanır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-176">The .NET Framework uses the *reference-tracing garbage collection* system to periodically release unused resources.</span></span> <span data-ttu-id="e4cc7-177">Visual Basic 6,0 ve önceki sürümler, kaynakları yönetmek için *başvuru sayımı* adlı farklı bir sistem kullandı.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-177">Visual Basic 6.0 and earlier versions used a different system called *reference counting* to manage resources.</span></span> <span data-ttu-id="e4cc7-178">Her iki sistem de aynı işlevi otomatik olarak gerçekleştirse de, bazı önemli farklılıklar vardır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-178">Although both systems perform the same function automatically, there are a few important differences.</span></span>

<span data-ttu-id="e4cc7-179">Sistem bu nesne nesnelerinin artık gerekli olmadığını belirlediğinde CLR nesneleri düzenli olarak yok eder.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-179">The CLR periodically destroys objects when the system determines that such objects are no longer needed.</span></span> <span data-ttu-id="e4cc7-180">Sistem kaynakları kısa tedarik edildiğinde nesneler daha hızlı serbest bırakılır ve aksi takdirde daha az sıklıkta yayımlanır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-180">Objects are released more quickly when system resources are in short supply, and less frequently otherwise.</span></span> <span data-ttu-id="e4cc7-181">Bir nesne kapsamı kaybettiğinde ve CLR yayımlandığında, Visual Basic 6,0 ve önceki sürümlerde bulunan nesnelerden farklı olarak, nesnenin yok edileceği tam olarak belirleyemeyeceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-181">The delay between when an object loses scope and when the CLR releases it means that, unlike with objects in Visual Basic 6.0 and earlier versions, you cannot determine exactly when the object will be destroyed.</span></span> <span data-ttu-id="e4cc7-182">Böyle bir durumda, nesneler *belirleyici olmayan bir ömrüne*sahip olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-182">In such a situation, objects are said to have *non-deterministic lifetime*.</span></span> <span data-ttu-id="e4cc7-183">Çoğu durumda, belirleyici olmayan ömür, bir nesne kapsamı kaybettiğinde, `Finalize` yıkıcının hemen yürütülmeyeceğini hatırlayabileceğiniz sürece uygulamaları nasıl yazacağınız değişmez.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-183">In most cases, non-deterministic lifetime does not change how you write applications, as long as you remember that the `Finalize` destructor may not immediately execute when an object loses scope.</span></span>

<span data-ttu-id="e4cc7-184">Çöp toplama sistemleri arasındaki başka bir farklılık, ' nin `Nothing`kullanımını içerir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-184">Another difference between the garbage-collection systems involves the use of `Nothing`.</span></span> <span data-ttu-id="e4cc7-185">Visual Basic 6,0 ve önceki sürümlerde başvuru saymadan yararlanmak için, programcılar bazen nesne değişkenlerine, `Nothing` bu değişkenlerin tuttuğu başvuruları serbest bırakmak için atanır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-185">To take advantage of reference counting in Visual Basic 6.0 and earlier versions, programmers sometimes assigned `Nothing` to object variables to release the references those variables held.</span></span> <span data-ttu-id="e4cc7-186">Değişken nesneye en son başvuruyu içeriyorsa, nesnenin kaynakları hemen serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-186">If the variable held the last reference to the object, the object's resources were released immediately.</span></span> <span data-ttu-id="e4cc7-187">Visual Basic sonraki sürümlerinde, bu yordamın hala değerli olduğu durumlar olabilir, ancak bunun gerçekleştirilmesi hiçbir zaman başvurulan nesnenin kaynaklarını hemen serbest bırakmaya neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-187">In later versions of Visual Basic, while there may be cases in which this procedure is still valuable, performing it never causes the referenced object to release its resources immediately.</span></span> <span data-ttu-id="e4cc7-188">Kaynakları hemen serbest bırakmak için, varsa nesnenin <xref:System.IDisposable.Dispose%2A> yöntemini kullanın.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-188">To release resources immediately, use the object's <xref:System.IDisposable.Dispose%2A> method, if available.</span></span> <span data-ttu-id="e4cc7-189">' A bir değişken `Nothing` ayarlamanız gereken tek zaman ömrü, çöp toplayıcının yalnız bırakılmış nesneleri algılamak için aldığı zamana göreli bir süredir.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-189">The only time you should set a variable to `Nothing` is when its lifetime is long relative to the time the garbage collector takes to detect orphaned objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="e4cc7-190">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="e4cc7-190">See also</span></span>

- <xref:System.IDisposable.Dispose%2A>
- <span data-ttu-id="e4cc7-191">[Bileşenlerin başlatılması ve sonlandırılması](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span><span class="sxs-lookup"><span data-stu-id="e4cc7-191">[Initialization and Termination of Components](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2013/ws9dc6t6(v=vs.120))</span></span>
- [<span data-ttu-id="e4cc7-192">New İşleci</span><span class="sxs-lookup"><span data-stu-id="e4cc7-192">New Operator</span></span>](../../../../visual-basic/language-reference/operators/new-operator.md)
- [<span data-ttu-id="e4cc7-193">Yönetilmeyen Kaynakları Temizleme</span><span class="sxs-lookup"><span data-stu-id="e4cc7-193">Cleaning Up Unmanaged Resources</span></span>](../../../../standard/garbage-collection/unmanaged.md)
- [<span data-ttu-id="e4cc7-194">Nothing</span><span class="sxs-lookup"><span data-stu-id="e4cc7-194">Nothing</span></span>](../../../../visual-basic/language-reference/nothing.md)

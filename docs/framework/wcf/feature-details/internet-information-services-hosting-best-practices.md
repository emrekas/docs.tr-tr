---
title: Internet Information Services Barındırma En İyi Uygulamaları
ms.date: 03/30/2017
ms.assetid: 0834768e-9665-46bf-86eb-d4b09ab91af5
ms.openlocfilehash: a4312a9affc1103f613f3f8ffd9a14696f9d4bcc
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61972620"
---
# <a name="internet-information-services-hosting-best-practices"></a><span data-ttu-id="548d8-102">Internet Information Services Barındırma En İyi Uygulamaları</span><span class="sxs-lookup"><span data-stu-id="548d8-102">Internet Information Services Hosting Best Practices</span></span>
<span data-ttu-id="548d8-103">Bu konuda, Windows Communication Foundation (WCF) hizmetlerini barındırmak için bazı en iyi uygulamalar açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="548d8-103">This topic outlines some best practices for hosting Windows Communication Foundation (WCF) services.</span></span>  
  
## <a name="implementing-wcf-services-as-dlls"></a><span data-ttu-id="548d8-104">Dll olarak uygulama WCF hizmetleri</span><span class="sxs-lookup"><span data-stu-id="548d8-104">Implementing WCF Services as DLLs</span></span>  
 <span data-ttu-id="548d8-105">Uygulama bir WCF hizmeti bir Web uygulamasının \bin dizinine dağıtılan bir DLL olarak dağıtılan Internet Information Services (IIS) sahip olmayan bir test ortamında Web uygulama modeli dışında hizmet Örneğin, yeniden sağlar.</span><span class="sxs-lookup"><span data-stu-id="548d8-105">Implementing a WCF service as a DLL that is deployed to the \bin directory of a Web application allows you reuse the service outside of the Web application model, for example, in a test environment that may not have Internet Information Services (IIS) deployed.</span></span>  
  
## <a name="service-hosts-in-iis-hosted-applications"></a><span data-ttu-id="548d8-106">IIS barındırılan uygulamalarda hizmet konakları</span><span class="sxs-lookup"><span data-stu-id="548d8-106">Service Hosts in IIS-Hosted Applications</span></span>  
 <span data-ttu-id="548d8-107">Kesinlik temelli barındırılan API'ler, ağ aktarımı barındırma ortamı IIS tarafından yerel olarak desteklenen, dinleme yeni hizmet konakları oluşturmak için kullanmayın (örneğin, [!INCLUDE[iis601](../../../../includes/iis601-md.md)] TCP barındırmak için Hizmetleri, çünkü TCP iletişimi üzerinde yerel olarak desteklenmiyor [!INCLUDE[iis601](../../../../includes/iis601-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="548d8-107">Do not use the imperative self-host APIs to create new service hosts that listen on network transports not natively supported by the IIS hosting environment (For example, [!INCLUDE[iis601](../../../../includes/iis601-md.md)] to host TCP services, because TCP communication is not natively supported on [!INCLUDE[iis601](../../../../includes/iis601-md.md)]).</span></span> <span data-ttu-id="548d8-108">Bu yaklaşım önerilmez.</span><span class="sxs-lookup"><span data-stu-id="548d8-108">This approach is not recommended.</span></span> <span data-ttu-id="548d8-109">IIS barındırma ortamında kesin oluşturulan hizmet konakları bilinmiyor.</span><span class="sxs-lookup"><span data-stu-id="548d8-109">Service hosts created imperatively are not known within the IIS hosting environment.</span></span> <span data-ttu-id="548d8-110">Barındırma uygulama havuzu boşta olup olmadığını belirlerken kesin oluşturulan Hizmetleri tarafından gerçekleştirilen işleme için IIS tarafından tasarlanan değil kritik noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="548d8-110">The critical point is that processing done by imperatively created services is not accounted for by IIS when it determines whether the hosting application pool is idle.</span></span> <span data-ttu-id="548d8-111">Sonuç tür kesin oluşturulan hizmet konakları sahip uygulamalar IIS ana bilgisayarı işlemlerinin agresif siler bir IIS barındırma ortamı olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="548d8-111">The result is that applications that have such imperatively created service hosts have an IIS hosting environment that aggressively disposes of IIS host processes.</span></span>  
  
## <a name="uris-and-iis-hosted-endpoints"></a><span data-ttu-id="548d8-112">URI ve IIS tarafından barındırılan uç noktaları</span><span class="sxs-lookup"><span data-stu-id="548d8-112">URIs and IIS-Hosted Endpoints</span></span>  
 <span data-ttu-id="548d8-113">IIS barındırılan hizmeti için uç noktalar göreli Tekdüzen Kaynak Tanımlayıcıları (URI'lar) değil mutlak adresleri kullanarak yapılandırılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="548d8-113">Endpoints for an IIS-hosted service should be configured using relative Uniform Resource Identifiers (URIs), not absolute addresses.</span></span> <span data-ttu-id="548d8-114">Bu uç nokta adresini barındırma uygulamaya ait URI adresleri kümesi içinde döner ve ileti tabanlı etkinleştirme beklendiği gibi olur sağlar güvence altına alır.</span><span class="sxs-lookup"><span data-stu-id="548d8-114">This guarantees that the endpoint address falls within the set of URI addresses that belong to the hosting application and ensures that message-based activation happens as expected.</span></span>  
  
## <a name="state-management-and-process-recycling"></a><span data-ttu-id="548d8-115">Durum Yönetimi ve işlem geri dönüştürme</span><span class="sxs-lookup"><span data-stu-id="548d8-115">State Management and Process Recycling</span></span>  
 <span data-ttu-id="548d8-116">IIS barındırma ortamı, bellekteki yerel durum bilgisi bulundurmaz Hizmetleri için optimize edilmiştir.</span><span class="sxs-lookup"><span data-stu-id="548d8-116">The IIS hosting environment is optimized for services that do not maintain local state in memory.</span></span> <span data-ttu-id="548d8-117">IIS, çeşitli dış ve iç olaylara yanıt olarak ana bilgisayar işlemi kaybolacak özel bellekte herhangi bir geçici durum neden geri dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="548d8-117">IIS recycles the host process in response to a variety of external and internal events, causing any volatile state stored exclusively in memory to be lost.</span></span> <span data-ttu-id="548d8-118">IIS'de barındırılan hizmetler, dış işlem (örneğin, bir veritabanı) bunların durumunu depolamanız gerekir veya bir bellek içi önbelleği bir uygulamanın olay Geri Dönüşüm, kolayca yeniden oluşturulabilir gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="548d8-118">Services hosted in IIS should store their state external to the process (for example, in a database) or in an in-memory cache that can easily be re-created if an application recycle event occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="548d8-119">İleti düzeyi güvenilirliği ve güvenliği için WCF kullanan olun protokolleri geçici bellek içi durumunu kullanın.</span><span class="sxs-lookup"><span data-stu-id="548d8-119">The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state.</span></span> <span data-ttu-id="548d8-120">WCF güvenilir oturumlar ve güvenlik oturumu beklenmedik bir şekilde uygulama geri dönüşümlerine genel nedeniyle sonlandırabilir.</span><span class="sxs-lookup"><span data-stu-id="548d8-120">WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles.</span></span> <span data-ttu-id="548d8-121">IIS barındırılan uygulamalar ya da uygulama katmanı durumu (örneğin, bir uygulama katmanı yapısı veya özel korelasyon başlığı) veya devre dışı bırakma ilişkilendirmek için WCF tarafından sağlanan oturum anahtarı dışında bir şey bağlı olmamalıdır bu protokolleri kullanın. IIS işlemi barındırılan uygulamayı geri dönüştürülüyor.</span><span class="sxs-lookup"><span data-stu-id="548d8-121">IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.</span></span>  
  
## <a name="optimizing-performance-in-middle-tier-scenarios"></a><span data-ttu-id="548d8-122">Orta katman senaryolarda performansı en iyi duruma getirme</span><span class="sxs-lookup"><span data-stu-id="548d8-122">Optimizing Performance in Middle-Tier Scenarios</span></span>  
 <span data-ttu-id="548d8-123">En iyi performans için bir *orta katman senaryo*— diğer hizmetlere gelen iletilere yanıt olarak çağıran bir hizmet — WCF hizmeti istemcisi uzak hizmet için bir kez örneklemek ve birden çok gelen arasında yeniden istek sayısı.</span><span class="sxs-lookup"><span data-stu-id="548d8-123">For optimal performance in a *middle-tier scenario*—a service that calls out to other services in response to incoming messages—instantiate the WCF service client to the remote service once and reuse it across multiple incoming requests.</span></span> <span data-ttu-id="548d8-124">WCF hizmeti istemcileri örnekleme hizmeti önceden var olan bir istemci örneği üzerinde çağrısı yaparak göre pahalı bir işlemdir ve istekler genelinde uzak istemciler önbelleğe alarak farklı bir performans kazancı elde edildi orta katman senaryoları üretir.</span><span class="sxs-lookup"><span data-stu-id="548d8-124">Instantiating WCF service clients is an expensive operation relative to making a service call on a pre-existing client instance, and middle-tier scenarios produce distinct performance gains by caching remote clients across requests.</span></span> <span data-ttu-id="548d8-125">WCF hizmeti istemcileri iş parçacığı açısından güvenli olduğundan, birden çok iş parçacığı arasında bir istemci erişimi eşitlemek gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="548d8-125">WCF service clients are thread-safe, so it is not necessary to synchronize access to a client across multiple threads.</span></span>  
  
 <span data-ttu-id="548d8-126">Orta katman senaryoları da tarafından oluşturulan zaman uyumsuz API'leri kullanarak performans kazancı elde edildi üretmek `svcutil /a` seçeneği.</span><span class="sxs-lookup"><span data-stu-id="548d8-126">Middle-tier scenarios also produce performance gains by using the asynchronous APIs generated by the `svcutil /a` option.</span></span> <span data-ttu-id="548d8-127">`/a` Seçeneğini neden [ServiceModel meta veri yardımcı Programracı (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) oluşturulacak `BeginXXX/EndXXX` üzerinde yapılacak muhtemelen uzun süren çağrısına uzak hizmetleri sağlayan her bir hizmet işlemi için yöntemleri arka plan iş parçacıkları.</span><span class="sxs-lookup"><span data-stu-id="548d8-127">The `/a` option causes the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to generate `BeginXXX/EndXXX` methods for each service operation, which allows potentially long-running calls to remote services to be made on background threads.</span></span>  
  
## <a name="wcf-in-multi-homed-or-multi-named-scenarios"></a><span data-ttu-id="548d8-128">Birden çok girişli veya çok adlandırılmış senaryolarda WCF</span><span class="sxs-lookup"><span data-stu-id="548d8-128">WCF in Multi-Homed or Multi-named scenarios</span></span>  
 <span data-ttu-id="548d8-129">WCF hizmetleri bilgisayarlar kümesi, ortak bir dış ad paylaşacağı bir IIS Web grubu içinde dağıttığınız (gibi `http://www.contoso.com`) farklı ana bilgisayar adları tarafından ayrı ayrı ele alınır ancak (örneğin, `http://www.contoso.com` iki farklı makinelere trafiği yönlendirebilir adlı `http://machine1.internal.contoso.com` ve `http://machine2.internal.contoso.com`).</span><span class="sxs-lookup"><span data-stu-id="548d8-129">You can deploy WCF services inside of an IIS Web farm, where a set of computers share a common external name (such as `http://www.contoso.com`) but are individually addressed by different hostnames (for example, `http://www.contoso.com` might direct traffic to two different machines named `http://machine1.internal.contoso.com` and `http://machine2.internal.contoso.com`).</span></span> <span data-ttu-id="548d8-130">Bu dağıtım senaryosu WCF tarafından tam olarak desteklenir, ancak özel yapılandırma (Web Hizmetleri Açıklama Dili) hizmetin meta verilerde doğru (Dış) ana bilgisayar adını görüntülemek için WCF hizmetlerini barındıran IIS Web sitesinin gerektirir.</span><span class="sxs-lookup"><span data-stu-id="548d8-130">This deployment scenario is fully supported by WCF, but requires special configuration of the IIS Web site hosting WCF services to display the correct (external) hostname in the service's metadata (Web Services Description Language).</span></span>  
  
 <span data-ttu-id="548d8-131">Doğru ana bilgisayar adını oluşturan WCF hizmet meta verileri görünmesini sağlamak için açık bir ana bilgisayar adı kullanmak için WCF hizmetlerini barındıran IIS Web sitesi için varsayılan kimlik yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="548d8-131">To ensure that the correct hostname appears in the service metadata WCF generates, configure the default identity for the IIS Web site that hosts WCF services to use an explicit hostname.</span></span> <span data-ttu-id="548d8-132">Örneğin, içinde bulunan bilgisayarları `www.contoso.com` grubu, bir IIS sitesi bağlamasının kullanmalıdır \*:80:www.contoso.com http ve \*: 443:www.contoso.com HTTPS için.</span><span class="sxs-lookup"><span data-stu-id="548d8-132">For example, computers that reside inside of the `www.contoso.com` farm should use an IIS site binding of \*:80:www.contoso.com for HTTP and \*:443:www.contoso.com for HTTPS.</span></span>  
  
 <span data-ttu-id="548d8-133">IIS Web sitesi bağlamalarının IIS Microsoft Yönetim Konsolu (MMC) ek bileşenini kullanarak yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="548d8-133">You can configure IIS Web site bindings by using the IIS Microsoft Management Console (MMC) snap-in.</span></span>  
  
## <a name="application-pools-running-in-different-user-contexts-overwrite-assemblies-from-other-accounts-in-the-temporary-folder"></a><span data-ttu-id="548d8-134">Derlemeleri geçici klasörde diğer hesaplardan farklı kullanıcı bağlamı içinde çalışan uygulama havuzları üzerine</span><span class="sxs-lookup"><span data-stu-id="548d8-134">Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder</span></span>  
 <span data-ttu-id="548d8-135">Uygulama havuzları farklı kullanıcı bağlamı içinde çalışan diğer hesapların geçici derlemelerden üzerine yazılamaz emin olmak için [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] dosyaları klasörü, farklı kimlikler kullanın ve farklı uygulamalara yönelik geçici klasör.</span><span class="sxs-lookup"><span data-stu-id="548d8-135">To ensure that application pools running in different user contexts cannot overwrite assemblies from other accounts in the temporary [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] files folder, use different identities and temporary folders for different applications.</span></span> <span data-ttu-id="548d8-136">Örneğin, iki sanal uygulamaları /Application1 varsa ve / Uygulama2 dizinlerini, iki uygulama havuzları, A ve B ile iki farklı kimlikler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="548d8-136">For example, if you have two virtual applications /Application1 and / Application2, you can create two Application pools, A and B, with two different identities.</span></span> <span data-ttu-id="548d8-137">Uygulama havuzu bir uygulama havuzu B çalıştırabilirsiniz (kullanıcı2) başka bir kullanıcı kimliği altında bir kullanıcı kimliği (kullanıcı1) çalışmasına ve /Application1 kullanmayın ve /Application2 b kullanmak için yapılandırma</span><span class="sxs-lookup"><span data-stu-id="548d8-137">Application pool A can run under one user identity (user1) while application pool B can run under another user identity (user2), and configure /Application1 to use A and /Application2 to use B.</span></span>  
  
 <span data-ttu-id="548d8-138">Web.config dosyasında kullanarak geçici klasörü yapılandırabilirsiniz \< system.web/compilation/@tempFolder>.</span><span class="sxs-lookup"><span data-stu-id="548d8-138">In Web.config, you can configure the temporary folder using \<system.web/compilation/@tempFolder>.</span></span> <span data-ttu-id="548d8-139">/Application1, "c:\tempForUser1" olabilir ve Uygulama2 dizinlerini için "c:\tempForUser2" olabilir.</span><span class="sxs-lookup"><span data-stu-id="548d8-139">For /Application1, it can be "c:\tempForUser1" and for application2 it can be "c:\tempForUser2".</span></span> <span data-ttu-id="548d8-140">Bu klasörleri iki kimlikleri için karşılık gelen yazma izni verin.</span><span class="sxs-lookup"><span data-stu-id="548d8-140">Grant corresponding write permission to these folders for the two identities.</span></span>  
  
 <span data-ttu-id="548d8-141">Ardından kullanıcı2 /application2 (c:\tempForUser1 altında) kod üretimi klasörünü değiştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="548d8-141">Then user2 cannot change the code-generation folder for /application2 (under c:\tempForUser1).</span></span>  
  
## <a name="enabling-asynchronous-processing"></a><span data-ttu-id="548d8-142">Zaman uyumsuz işleme etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="548d8-142">Enabling asynchronous processing</span></span>  
 <span data-ttu-id="548d8-143">Varsayılan olarak IIS 6.0 ve önceki barındırılan bir WCF hizmetine gönderilen iletiler, zaman uyumlu bir şekilde işlenir.</span><span class="sxs-lookup"><span data-stu-id="548d8-143">By default messages sent to a WCF service hosted under IIS 6.0 and earlier are processed in a synchronous manner.</span></span> <span data-ttu-id="548d8-144">ASP.NET WCF kendi iş parçacığında (ASP.NET çalışan iş parçacığı) çağırır ve WCF isteği işlemek için başka bir iş parçacığı kullanır.</span><span class="sxs-lookup"><span data-stu-id="548d8-144">ASP.NET calls into WCF on its own thread (the ASP.NET worker thread) and WCF uses another thread to process the request.</span></span> <span data-ttu-id="548d8-145">İşleme tamamlanana kadar WCF ASP.NET çalışan iş parçacığı tutar.</span><span class="sxs-lookup"><span data-stu-id="548d8-145">WCF holds onto the ASP.NET worker thread until it completes its processing.</span></span> <span data-ttu-id="548d8-146">Bu istek için zaman uyumlu işleme neden olur.</span><span class="sxs-lookup"><span data-stu-id="548d8-146">This leads to synchronous processing of requests.</span></span> <span data-ttu-id="548d8-147">– WCF ASP.NET iş parçacığı için istek işlenirken bulundurmayan bir isteği işlemek için gerekli iş parçacığı sayısını azaltır çünkü isteklerini zaman uyumsuz olarak işlenmesi daha büyük ölçeklendirme sağlar.</span><span class="sxs-lookup"><span data-stu-id="548d8-147">Processing requests asynchronously enables greater scalability because it reduces the number of threads required to process a request –WCF does not hold on to the ASP.NET thread while processing the request.</span></span> <span data-ttu-id="548d8-148">IIS 6.0 sunucusunu açın gelen istekleri azaltma hiçbir yolu olmadığından çalışan makineler için zaman uyumsuz davranış kullanımı önerilmez *hizmet reddi* (DOS) saldırıları.</span><span class="sxs-lookup"><span data-stu-id="548d8-148">Use of asynchronous behavior is not recommended for machines running IIS 6.0 because there is no way to throttle incoming requests that open up the server to *Denial Of Service* (DOS) attacks.</span></span> <span data-ttu-id="548d8-149">IIS 7. 0'ile başlayarak, eş zamanlı istek azaltma sunulmuştur: `[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`.</span><span class="sxs-lookup"><span data-stu-id="548d8-149">Starting with IIS 7.0, a concurrent request throttle has been introduced: `[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`.</span></span> <span data-ttu-id="548d8-150">Bu yeni kısıtlama ile zaman uyumsuz işleme kullanmak güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="548d8-150">With this new throttle it is safe to use the asynchronous processing.</span></span>  <span data-ttu-id="548d8-151">IIS 7.0 varsayılan olarak, zaman uyumsuz işleyicisi ve modül kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="548d8-151">By default in IIS 7.0, the asynchronous handler and module are registered.</span></span> <span data-ttu-id="548d8-152">Bu devre dışı bırakıldıysa, uygulamanızın Web.config dosyasında isteklerin zaman uyumsuz işleme el ile etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="548d8-152">If this has been turned off, you can manually enable asynchronous processing of requests in your application's Web.config file.</span></span> <span data-ttu-id="548d8-153">Kullandığınız ayarlar bağlıdır, `aspNetCompatibilityEnabled` ayarı.</span><span class="sxs-lookup"><span data-stu-id="548d8-153">The settings you use depend on your `aspNetCompatibilityEnabled` setting.</span></span> <span data-ttu-id="548d8-154">Varsa `aspNetCompatibilityEnabled` kümesine `false`, yapılandırma `System.ServiceModel.Activation.ServiceHttpModule` aşağıdaki yapılandırma kod parçacığında gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="548d8-154">If you have `aspNetCompatibilityEnabled` set to `false`, configure the `System.ServiceModel.Activation.ServiceHttpModule` as shown in the following configuration snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="false" />      
  </system.serviceModel>  
  <system.webServer>  
    <modules>  
      <remove name="ServiceModel"/>  
      <add name="ServiceModel"   
           preCondition="integratedMode,runtimeVersionv2.0"   
           type="System.ServiceModel.Activation.ServiceHttpModule, System.ServiceModel,Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
    </system.webServer>  
```  
  
 <span data-ttu-id="548d8-155">Varsa `aspNetCompatibilityEnabled` kümesine `true`, yapılandırma `System.ServiceModel.Activation.ServiceHttpHandlerFactory` aşağıdaki yapılandırma kod parçacığında gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="548d8-155">If you have `aspNetCompatibilityEnabled` set to `true`, configure the `System.ServiceModel.Activation.ServiceHttpHandlerFactory` as shown in the following config snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="true" />      
  </system.serviceModel>  
  <system.webServer>  
    <handlers>  
          <clear/>  
          <add name="TestAsyncHttpHandler"   
               path="*.svc"   
               verb="*"   
               type="System.ServiceModel.Activation.ServiceHttpHandlerFactory, System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"           
               />  
    </handlers>      
  </system.webServer>  
```  
  
## <a name="see-also"></a><span data-ttu-id="548d8-156">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="548d8-156">See also</span></span>

- [<span data-ttu-id="548d8-157">Barındırma hizmeti örnekleri</span><span class="sxs-lookup"><span data-stu-id="548d8-157">Service Hosting Samples</span></span>](../samples/hosting.md)
- [<span data-ttu-id="548d8-158">Windows Server App Fabric barındırma özellikleri</span><span class="sxs-lookup"><span data-stu-id="548d8-158">Windows Server App Fabric Hosting Features</span></span>](https://go.microsoft.com/fwlink/?LinkId=201276)

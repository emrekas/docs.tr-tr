---
title: Güvenilirlik En İyi Yöntemleri
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 37e6b995a84a54dfcb52460d11e9843a933a5684
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/05/2019
ms.locfileid: "57353081"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="cce0f-102">Güvenilirlik En İyi Yöntemleri</span><span class="sxs-lookup"><span data-stu-id="cce0f-102">Reliability Best Practices</span></span>

<span data-ttu-id="cce0f-103">SQL Server için aşağıdaki güvenilirlik kuralları yerleştirilir; Ancak, bunlar da herhangi bir ana bilgisayar tabanlı sunucu uygulama uygulanır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-103">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="cce0f-104">SQL Server gibi sunucu kaynak sızıntısı değil ve duruma değil, son derece önemlidir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-104">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="cce0f-105">Ancak, bir nesnenin durumunu değiştiren her yöntem için geri çekme kodu yazarak yapılamaz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-105">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="cce0f-106">Geri çekme kodu ile her yerde herhangi bir hata geri yüklenecek yüzde 100 güvenilir yönetilen kod yazma değil olmaktır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-106">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="cce0f-107">Bu, çok az başarı olasılığını göz korkutucu görevle olacaktır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-107">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="cce0f-108">Ortak dil çalışma zamanı (CLR) yönetilen kod için yeterince güçlü garanti uygun mükemmel kod yazmak için kolayca sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-108">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="cce0f-109">ASP.NET, SQL Server veritabanı edilemeyecek kadar uzun bir süredir kesinti olmadan dönüştürülemez yalnızca bir işlem kullandığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-109">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="cce0f-110">Bu zayıf garantiler ve tek bir işlemde çalışan ile güvenilirlik iş parçacıklarını sonlandırma veya tanıtıcıları veya bellek gibi işletim sistemi kaynakları sağlamak için gerekli ve alınması önlemler sızdırılmaz olduğunda uygulama etki alanları geri dönüşümü temel alır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-110">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="cce0f-111">Bile bu basit güvenilirlik kısıtlamayla, yine de önemli güvenilirlik gereksinimi vardır:</span><span class="sxs-lookup"><span data-stu-id="cce0f-111">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="cce0f-112">Hiçbir zaman sızıntısı işletim sistem kaynakları.</span><span class="sxs-lookup"><span data-stu-id="cce0f-112">Never leak operating system resources.</span></span>

- <span data-ttu-id="cce0f-113">Tüm yönetilen kilitleri CLR tüm raporlarda belirleyin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-113">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="cce0f-114">Hiçbir zaman kesme çapraz uygulama etki alanı paylaşılan izin verme durumuna <xref:System.AppDomain> düzgün çalışması için Geri Dönüşüm.</span><span class="sxs-lookup"><span data-stu-id="cce0f-114">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="cce0f-115">Teorik olarak işlemek için yönetilen kod yazmanıza olanak olmasına rağmen <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, ve <xref:System.OutOfMemoryException> özel durumlar, geliştiricilerin yazma gibi güçlü kod tüm uygulamanın tamamında mantıksız bekleniyor.</span><span class="sxs-lookup"><span data-stu-id="cce0f-115">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="cce0f-116">Bu nedenle, bant dışı özel durumları sonlandırılıyor yürütülen iş parçacığında sonucu; ve sonlandırılan iş parçacığının iş parçacığının bir kilidi tutan tarafından belirlenebilir, paylaşılan durum düzenliyorsanız sonra <xref:System.AppDomain> kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-116">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="cce0f-117">Paylaşılan durum düzenleme bir yöntem sonlandırıldığında için paylaşılan durum güncelleştirmeleri için güvenilir geri çekme kodu yazmayı mümkün olmadığı için durumu bozuk olacaktır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-117">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="cce0f-118">.NET Framework 2.0 sürümünde, yalnızca ana SQL Server güvenilirlik gerektirir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-118">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="cce0f-119">Derlemenizi SQL sunucu üzerinde çalışacaksa veritabanında çalıştırırken devre dışı bırakılmış belirli özellikleri olsa bile, derleme, her bir bölümü için güvenilirlik iş yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-119">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="cce0f-120">Kod Analizi motoru derleme düzeyinde kodu inceler ve devre dışı kod ayırt edemez çünkü bu gereklidir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-120">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="cce0f-121">Başka bir SQL Server programlama dikkat etmeniz gereken SQL Server her şey tek bir işlemde çalıştırılır ve <xref:System.AppDomain> geri dönüştürme kullanılan bellek ve işletim sistemi tanıtıcıları gibi tüm kaynakları Temizleme için.</span><span class="sxs-lookup"><span data-stu-id="cce0f-121">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="cce0f-122">Sonlandırıcılar veya yıkıcıları bağımlı olamaz veya `try/finally` geri çekme kodu için engeller.</span><span class="sxs-lookup"><span data-stu-id="cce0f-122">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="cce0f-123">Bunlar kesintiye ya da çağrılmadığı.</span><span class="sxs-lookup"><span data-stu-id="cce0f-123">They might be interrupted or not called.</span></span>

<span data-ttu-id="cce0f-124">Zaman uyumsuz özel durumları beklenmeyen konumlarda büyük olasılıkla her makine yönerge durum: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, ve <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-124">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="cce0f-125">Yönetilen iş parçacıklarını mutlaka SQL Win32 iş parçacığı değildir; Bunlar iyileştirmesini olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-125">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="cce0f-126">İşlem genelinde veya çapraz uygulama etki alanı değişebilir paylaşılan durum güvenli bir şekilde değiştirmek son derece zordur ve mümkün olduğunca kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-126">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="cce0f-127">Bellek yetersiz koşullar SQL Server'da nadir değildir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-127">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="cce0f-128">SQL Server'da barındırılan kitaplıkları paylaşılan durumlarını doğru şekilde güncelleştirilmiyor, kodu değil kurtarılacak yüksek bir olasılık yoktur veritabanı yeniden başlatılana kadar.</span><span class="sxs-lookup"><span data-stu-id="cce0f-128">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="cce0f-129">Ayrıca, bazı olağanüstü durumlarda, yeniden başlatmak veritabanına neden bu SQL Server işleminin başarısız olmasına neden olabilir mümkündür.</span><span class="sxs-lookup"><span data-stu-id="cce0f-129">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="cce0f-130">Veritabanını yeniden bir Web sitesini veya kullanılabilirlik mutsuz şirket işlemlerini etkiler.</span><span class="sxs-lookup"><span data-stu-id="cce0f-130">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="cce0f-131">Yavaş bir sızıntısı bellek veya tanıtıcıları gibi işletim sistemi kaynak sunucunun kurtarma kaybetme riski ayırma tutamaçlı sonunda başarısız olmasına neden olabilir veya potansiyel olarak sunucu yavaş performans düşebilir ve bir müşterinin uygulaması azaltır Kullanılabilirlik.</span><span class="sxs-lookup"><span data-stu-id="cce0f-131">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="cce0f-132">Açıkça bu senaryoları önlemek istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-132">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="cce0f-133">En iyi yöntem kuralları</span><span class="sxs-lookup"><span data-stu-id="cce0f-133">Best Practice Rules</span></span>

<span data-ttu-id="cce0f-134">Giriş ne sunucusunda çalışan yönetilen kod için kod incelemesi kararlılığını ve framework güvenilirliğini artırmak için catch zorunda odaklanır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-134">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="cce0f-135">Bu denetimler iyi genel aşamasındadır ve sunucu üzerinde mutlak olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-135">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="cce0f-136">Bir ölü kilidi veya kaynak kısıtlama karşılaşıldığında, SQL Server bir iş parçacığını durdurmak veya kapatabilirsiniz bir <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-136">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="cce0f-137">Bu durumda, yalnızca geri çekme kodu kısıtlı yürütme bölgede (CER) çalıştırılması sağlanır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-137">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="cce0f-138">Kaynak sızıntılarını önlemek için SafeHandle kullanın</span><span class="sxs-lookup"><span data-stu-id="cce0f-138">Use SafeHandle to Avoid Resource Leaks</span></span>

<span data-ttu-id="cce0f-139">Durumunda, bir <xref:System.AppDomain> kaldırma, size bağlı olamaz üzerinde `finally` blokları veya tüm işletim sistemi kaynak erişimi aracılığıyla soyutlamak önemlidir, yürütülen sonlandırıcılar <xref:System.Runtime.InteropServices.SafeHandle> sınıfı yerine <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, veya benzer sınıflar.</span><span class="sxs-lookup"><span data-stu-id="cce0f-139">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="cce0f-140">İzleme ve kullandığınız bile tutamaçları kapatmak CLR böylece <xref:System.AppDomain> kapatmayı çalışması.</span><span class="sxs-lookup"><span data-stu-id="cce0f-140">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="cce0f-141"><xref:System.Runtime.InteropServices.SafeHandle> CLR her zaman çalıştır kritik bir sonlandırıcı kullanacaklardır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-141"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="cce0f-142">İşletim sistemi tanıtıcıyı serbest şu kadar oluşturulduğu andan güvenli tanıtıcı depolanır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-142">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="cce0f-143">Penceresi yok aşamasında bir <xref:System.Threading.ThreadAbortException> yönelik bir tanıtıcı ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-143">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="cce0f-144">Ayrıca, platform çağırma başvuru sayısı, kullanım ömrü tanıtıcıyı bir yarış durumu arasında bir güvenlik sorunu engelleme, yakın izleme sağlayan tanıtıcı `Dispose` ve tanıtıcı kullanmakta olduğu bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="cce0f-144">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="cce0f-145">Şu anda yalnızca temiz bir işletim sistemini kurmak işlemek için bir Sonlandırıcısı olan çoğu sınıf Sonlandırıcı artık gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-145">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="cce0f-146">Bunun yerine, sonlandırıcı açık olacak <xref:System.Runtime.InteropServices.SafeHandle> türetilmiş sınıf.</span><span class="sxs-lookup"><span data-stu-id="cce0f-146">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="cce0f-147">Unutmayın <xref:System.Runtime.InteropServices.SafeHandle> yerine değil <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-147">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="cce0f-148">Açıkça işletim sistemi kaynaklarını silmek için Çekişme ve performans avantajları hala olası kaynak vardır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-148">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="cce0f-149">Yalnızca fark `finally` açıkça kaynaklarını silmek blokları tamamlanana kadar çalışmayabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-149">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="cce0f-150"><xref:System.Runtime.InteropServices.SafeHandle> uygulamak kendi sağlar <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> yordamı serbest bırakma veya bir dizi döngü içinde tanıtıcıları boşaltma bir işletim sistemi tanıtıcısı durumuna geçirme gibi tanıtıcı ücretsiz çalışma gerçekleştirir yöntemi.</span><span class="sxs-lookup"><span data-stu-id="cce0f-150"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="cce0f-151">CLR, bu yöntem çalıştırıldığını garanti eder.</span><span class="sxs-lookup"><span data-stu-id="cce0f-151">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="cce0f-152">Yazarı sorumluluğundadır <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> tanıtıcı tüm durumlarda yayımlanan emin olmak için uygulama.</span><span class="sxs-lookup"><span data-stu-id="cce0f-152">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="cce0f-153">Bunun yapılmaması, sızıntı tanıtıcısı ile ilişkili yerel kaynakların genellikle sonuçlanır be leaked tanıtıcı neden olur.</span><span class="sxs-lookup"><span data-stu-id="cce0f-153">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="cce0f-154">Bu nedenle yapısına kritik <xref:System.Runtime.InteropServices.SafeHandle> türetilmiş sınıflar gibi <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> uygulamasını çağırma anda kullanılamayabilir herhangi bir kaynak ayırma gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="cce0f-154">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="cce0f-155">İçinde uygulamanın başarısız olabileceği çağrı yöntemlere izin verilen olduğuna dikkat edin <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> koşuluyla kodunuz bu tür hataları işlemek ve yerel tanıtıcısını bırakmak için sözleşme tamamlayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-155">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="cce0f-156">Hata ayıklama amacıyla, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> sahip bir <xref:System.Boolean> döndürmek için ayarlanabilir değeri `false` yayın kaynağının önleyen işlemi yıkıcı hatayla karşılaşılırsa.</span><span class="sxs-lookup"><span data-stu-id="cce0f-156">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="cce0f-157">Bunu yaptığınızda etkinleşir [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) etkinleştirilirse sorun tanımlanmasına yardımcı olmak için MDA.</span><span class="sxs-lookup"><span data-stu-id="cce0f-157">Doing so will activate the [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="cce0f-158">Çalışma zamanı başka bir şekilde etkilemez. <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> yeniden aynı kaynak için çağrılmayacak ve tanıtıcı sızmasına sonuç.</span><span class="sxs-lookup"><span data-stu-id="cce0f-158">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="cce0f-159"><xref:System.Runtime.InteropServices.SafeHandle> belirli bağlamlarda uygun değil.</span><span class="sxs-lookup"><span data-stu-id="cce0f-159"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="cce0f-160">Bu yana <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> yöntemi, çalıştırılabilir bir <xref:System.GC> Sonlandırıcı iş parçacığı, belirli bir iş parçacığında boşaltılması için gerekli olan tanıtıcıları değil içinde kaydırılır bir <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-160">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="cce0f-161">Çalışma zamanı aranabilir sarmalayıcılarını (RCW), ek kod olmadan CLR tarafından temizlenebilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-161">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="cce0f-162">Kullanan kod için platform çağırma ve bir COM nesnesi olarak değerlendirir bir `IUnknown*` veya <xref:System.IntPtr>, kodu bir RCW kullanılacak yazılması.</span><span class="sxs-lookup"><span data-stu-id="cce0f-162">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="cce0f-163"><xref:System.Runtime.InteropServices.SafeHandle> bir yönetilmeyen yayın yöntemi yönetilen koda geri çağırma olasılığı nedeniyle bu senaryo için yeterli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-163"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-164">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-164">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-165">Kullanım <xref:System.Runtime.InteropServices.SafeHandle> işletim sistemi kaynakları kapsamak için.</span><span class="sxs-lookup"><span data-stu-id="cce0f-165">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="cce0f-166">Kullanmayın <xref:System.Runtime.InteropServices.HandleRef> veya türünde alanlar <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-166">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="cce0f-167">Sonlandırıcılar işletim sistemi kaynaklarını sızdırılmasını önlemek için çalışmaya olmadığından olun</span><span class="sxs-lookup"><span data-stu-id="cce0f-167">Ensure Finalizers Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>

<span data-ttu-id="cce0f-168">Dikkatli bir şekilde çalıştırmadıkları olsa bile, bir kritik işletim sistemi kaynağı sızdırılmaz emin olmak için bir sonlandırıcı gözden geçirin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-168">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="cce0f-169">Normal aksine <xref:System.AppDomain> uygulama kararlı bir duruma veya SQL Server kapatır gibi bir sunucusu olmayan kesin bir ani sırasında nesneleri yürütülürken kaldırma <xref:System.AppDomain> kaldırın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-169">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="cce0f-170">Kaynakları ani bir kaldırma durumunda olduğundan, bir uygulamanın doğruluğu garanti edilemez, ancak sunucu bütünlüğünü kaynak sızıntısı değil tarafından korunmalıdır sızdırılmaz emin olun.</span><span class="sxs-lookup"><span data-stu-id="cce0f-170">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="cce0f-171">Kullanım <xref:System.Runtime.InteropServices.SafeHandle> herhangi bir işletim sistemi kaynakları serbest bırakacak.</span><span class="sxs-lookup"><span data-stu-id="cce0f-171">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="cce0f-172">Son olarak, işletim sistemi kaynaklarını sızmasını önlemek için çalıştırılacak yan tümceleri gerekmez emin olun</span><span class="sxs-lookup"><span data-stu-id="cce0f-172">Ensure That finally Clauses Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>

<span data-ttu-id="cce0f-173">`finally` yan tümceleri garanti edilmez CERs dışında çalıştırmak için kitaplık geliştiricilerin kod içinde bağımlı kalmayacak gerektiren bir `finally` blok yönetilmeyen kaynakları serbest bırakacak.</span><span class="sxs-lookup"><span data-stu-id="cce0f-173">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="cce0f-174">Kullanarak <xref:System.Runtime.InteropServices.SafeHandle> önerilen çözümdür.</span><span class="sxs-lookup"><span data-stu-id="cce0f-174">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-175">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-175">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-176">Kullanım <xref:System.Runtime.InteropServices.SafeHandle> yerine işletim sistemi kaynakları Temizleme için `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="cce0f-176">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="cce0f-177">Kullanmayın <xref:System.IntPtr>; kullanma <xref:System.Runtime.InteropServices.SafeHandle> kaynakları kapsamak için.</span><span class="sxs-lookup"><span data-stu-id="cce0f-177">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="cce0f-178">Varsa finally yan tümcesi gerekir çalıştırın, içinde bir CER yerleştirin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-178">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="cce0f-179">Tüm kilitleri yönetilen mevcut kilitleme kod tamamlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-179">All Locks Should Go Through Existing Managed Locking Code</span></span>

<span data-ttu-id="cce0f-180">CLR böylece onu kapatabilirsiniz bilirsiniz kod bir kilit zaman olduğunu bilmeniz gerekir <xref:System.AppDomain> yerine yalnızca iş parçacığını iptal ediliyor.</span><span class="sxs-lookup"><span data-stu-id="cce0f-180">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="cce0f-181">Üzerinde iş parçacığı tarafından işletilen veri tutarsız bir durumda bıraktığınız iş parçacığının çalışmasını tehlikeli olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-181">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="cce0f-182">Bu nedenle, tüm <xref:System.AppDomain> geri dönüştürülmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-182">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="cce0f-183">Kilit tanımlamak başarısız olan sonuçlarını kilitlenmeleri veya hatalı sonuçları olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-183">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="cce0f-184">Yöntemleri kullanın <xref:System.Threading.Thread.BeginCriticalRegion%2A> ve <xref:System.Threading.Thread.EndCriticalRegion%2A> kilit bölgeleri.</span><span class="sxs-lookup"><span data-stu-id="cce0f-184">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="cce0f-185">Statik yöntemler üzerinde olduklarından <xref:System.Threading.Thread> yalnızca tek bir iş parçacığı başka bir iş parçacığının kilit sayacını düzenlemesini önlemek için yardımcı olan geçerli iş parçacığı için geçerli bir sınıf.</span><span class="sxs-lookup"><span data-stu-id="cce0f-185">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="cce0f-186"><xref:System.Threading.Monitor.Enter%2A> ve <xref:System.Threading.Monitor.Exit%2A> kullanımlarını yanı sıra kullanımı önerilir. Bu nedenle, yerleşik bu CLR bildirim sahip [lock deyimi](~/docs/csharp/language-reference/keywords/lock-statement.md), bu yöntemler kullanır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-186"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="cce0f-187">Döndürme kilitler gibi kilitleme başka mekanizmalar ve <xref:System.Threading.AutoResetEvent> kritik bölüm giriliyor CLR bildirmek için bu yöntemi çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-187">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="cce0f-188">Bu yöntemler kilitleri almayan; iş parçacığı durduruluyor paylaşılan durum tutarsız bırakabilir ve bunlar kritik bir bölümde kodu yürüten CLR bildirin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-188">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="cce0f-189">Özel bir gibi kendi kilit türü tanımladığınız varsa <xref:System.Threading.ReaderWriterLock> sınıfı, bu kilit sayısı yöntemleri kullanın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-189">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-190">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-190">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-191">İşaretleme ve kullanarak tüm kilitleri tanımlama <xref:System.Threading.Thread.BeginCriticalRegion%2A> ve <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-191">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="cce0f-192">Kullanmayın <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, ve <xref:System.Threading.Interlocked.Decrement%2A> döngü içinde.</span><span class="sxs-lookup"><span data-stu-id="cce0f-192">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="cce0f-193">Bir platform yapmak bu yöntemlerin Win32 türevleri çağırır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-193">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="cce0f-194">Kullanmayın <xref:System.Threading.Thread.Sleep%2A> döngü içinde.</span><span class="sxs-lookup"><span data-stu-id="cce0f-194">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="cce0f-195">Volatile alanları kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-195">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="cce0f-196">Temizleme kodu olmalıdır bir finally ya da bir catch bloğunun bir catch değil aşağıdaki</span><span class="sxs-lookup"><span data-stu-id="cce0f-196">Cleanup Code Must Be in a finally or a catch Block, Not Following a catch</span></span>

<span data-ttu-id="cce0f-197">Temizleme kodunu izlemelidir hiçbir zaman bir `catch` engelle; olmalıdır bir `finally` veya `catch` kendisini engelleyin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-197">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span>  <span data-ttu-id="cce0f-198">Bu, normal iyi bir uygulama olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-198">This should be a normal good practice.</span></span>  <span data-ttu-id="cce0f-199">A `finally` hem bir özel durum oluştuğunda hem de aynı kodu çalıştırdığı için blok genellikle tercih edilen sonuna `try` blok normalde karşılaşıldı.</span><span class="sxs-lookup"><span data-stu-id="cce0f-199">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="cce0f-200">Durumunda, örneğin oluşturulan beklenmeyen bir özel durum bir <xref:System.Threading.ThreadAbortException>, temizleme kodu çalışmayacak.</span><span class="sxs-lookup"><span data-stu-id="cce0f-200">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="cce0f-201">Herhangi bir yönetilmeyen, içinde temizlemek kaynakları bir `finally` , ideal olarak sarılacağını bir <xref:System.Runtime.InteropServices.SafeHandle> sızıntılarını önlemek için.</span><span class="sxs-lookup"><span data-stu-id="cce0f-201">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="cce0f-202">Not C# `using` anahtar sözcüğü etkin tanıtıcıları gibi nesnelerin dispose için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-202">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="cce0f-203">Ancak <xref:System.AppDomain> geri dönüştürme temiz Sonlandırıcı iş parçacığında kaynakları, temizleme kodu doğru konuma yerleştirmek yine de önemlidir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-203">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span>  <span data-ttu-id="cce0f-204">Bir iş parçacığı zaman uyumsuz bir özel bir kilit olmadan alırsa, CLR geri dönüştürmek zorunda kalmadan iş parçacığının kendisinde son denemesi Not <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-204">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="cce0f-205">Kaynakları daha çabuk yerine sonraki yardımcı daha fazla kaynağı kullanılabilir hale getirme ve daha iyi kullanım ömrü Yönetimi temizlendiğinden emin olma.</span><span class="sxs-lookup"><span data-stu-id="cce0f-205">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span>  <span data-ttu-id="cce0f-206">Ardından beklerken bazı hata kodu yolda bir dosya için bir tanıtıcı açıkça kapatmazsanız <xref:System.Runtime.InteropServices.SafeHandle> ilk kez kodunuzu çalıştığında, temizlemek için Sonlandırıcı Sonlandırıcı olmayan zaten çalıştırıldıysa tam aynı dosyaya erişmeyi deneyen başarısız olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-206">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="cce0f-207">Bu nedenle, temizleme kodunu var ve düzgün çalıştığını sağlamaya yardımcı olacak kesinlikle gerekli olmamasına rağmen daha temiz bir şekilde ve hızla hatalardan kurtarma.</span><span class="sxs-lookup"><span data-stu-id="cce0f-207">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-208">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-208">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-209">Sonra temizleme kodunu `catch` olması gereken bir `finally` blok.</span><span class="sxs-lookup"><span data-stu-id="cce0f-209">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="cce0f-210">Silinecek nda aramayı bir finally bloğunda.</span><span class="sxs-lookup"><span data-stu-id="cce0f-210">Place calls to dispose in a finally block.</span></span>  <span data-ttu-id="cce0f-211">`catch` blok içinde bir throw son veya rethrow gerekir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-211">`catch` blocks should end in a throw or rethrow.</span></span>  <span data-ttu-id="cce0f-212">Özel durumlar olacaktır ancak bir ağ bağlantısı kuruldu olup olmadığını algılama kodu gibi herhangi bir sayıda özel durum, bir özel durum sayısı normal koşullarda yakalama gerektiren herhangi bir kod burada alabilirsiniz vermelisiniz bir kod olmalıdır bir gösterge başarılı olur, görmek için test.</span><span class="sxs-lookup"><span data-stu-id="cce0f-212">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="cce0f-213">İşlem genelinde değişebilir paylaşılan durum uygulama etki alanları arasında ortadan ya da kısıtlı yürütme bölgeyi kullanın</span><span class="sxs-lookup"><span data-stu-id="cce0f-213">Process-Wide Mutable Shared State Between Application Domains Should Be Eliminated or Use a Constrained Execution Region</span></span>

<span data-ttu-id="cce0f-214">Giriş açıklandığı gibi paylaşılan işlem genelinde durum uygulama etki alanları arasında güvenilir bir şekilde izler. yönetilen kod yazmak oldukça zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-214">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="cce0f-215">İşlem genelinde paylaşılan durum uygulama etki alanları arasında Win32 kodda, CLR içinde ya da uzaktan iletişimi kullanarak yönetilen kodda ya da paylaşılan veri yapısının herhangi bir sıralama ' dir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-215">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="cce0f-216">Değişebilir bir paylaşılan durum doğru yönetilen kodda yazma çok zordur ve herhangi bir statik paylaşılan durum yalnızca harika dikkatli yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-216">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="cce0f-217">İşlem genelinde veya makine genelinde paylaşılan durum varsa, bunu ortadan kaldırın veya kısıtlı yürütme bölge (CER) kullanarak paylaşılan durumunu korumak için bir şekilde bulun.</span><span class="sxs-lookup"><span data-stu-id="cce0f-217">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="cce0f-218">Herhangi bir kitaplığı ile tanımlanan düzeltildi ve dağıtılmamış paylaşılan durum temiz gerektiren SQL Server gibi bir konak neden olabileceğini unutmayın <xref:System.AppDomain> çökmesine kaldırma.</span><span class="sxs-lookup"><span data-stu-id="cce0f-218">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="cce0f-219">Kod bir COM nesnesi kullanıyorsa, uygulama etki alanları arasında bu COM nesnesi paylaşımı kaçının.</span><span class="sxs-lookup"><span data-stu-id="cce0f-219">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="cce0f-220">Kilitler işlem genelinde veya uygulama etki alanları arasında çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-220">Locks Do Not Work Process-Wide or Between Application Domains.</span></span>

<span data-ttu-id="cce0f-221">Geçmişte, <xref:System.Threading.Monitor.Enter%2A> ve [lock deyimi](~/docs/csharp/language-reference/keywords/lock-statement.md) genel işlem kilitleri oluşturmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-221">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="cce0f-222">Örneğin, bu üzerinde kilitleme ortaya çıkar <xref:System.AppDomain> Çevik sınıflar gibi <xref:System.Type> örnekleri paylaşılmayan derlemelerden <xref:System.Threading.Thread> nesneleri, interned dizeleri ve Uzaktan iletişimi kullanarak uygulama etki alanları arasında paylaşılan herhangi bir dize.</span><span class="sxs-lookup"><span data-stu-id="cce0f-222">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="cce0f-223">Bu kilitleri artık işlem genelinde değildir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-223">These locks are no longer process-wide.</span></span>  <span data-ttu-id="cce0f-224">İşlem genelinde interapplication etki alanı kilit varlığı tanımlamak için kilit içindeki kod dosyası diskte veya büyük olasılıkla bir veritabanı gibi herhangi bir harici, kalıcı kaynak kullanıp kullanmadığını belirleyin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-224">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="cce0f-225">Bu süre sonu içinde kilit almayı unutmayın bir <xref:System.AppDomain> korunan kod, bir dış kaynağa kullanır, çünkü bu kodu aynı anda birden çok uygulama etki alanları arasında çalışabilir sorunlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-225">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="cce0f-226">Bu yazma sırasında bir sorun olabilir bir günlük dosyası veya işlem için bir yuva bağlama.</span><span class="sxs-lookup"><span data-stu-id="cce0f-226">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="cce0f-227">Bu değişiklikler, adlandırılmış kullanarak başka bir işlem genel kilidi almak için yönetilen kod kullanarak etmenin kolay bir yolu yoktur anlamına geliyor <xref:System.Threading.Mutex> veya <xref:System.Threading.Semaphore> örneği.</span><span class="sxs-lookup"><span data-stu-id="cce0f-227">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="cce0f-228">İki uygulama etki alanlarında aynı anda çalıştırmak, veya kullanmak kod oluşturma <xref:System.Threading.Mutex> veya <xref:System.Threading.Semaphore> sınıfları.</span><span class="sxs-lookup"><span data-stu-id="cce0f-228">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="cce0f-229">Varolan kod değiştirilemez, mutex adlı bir Win32 fiber modda çalışan aynı işletim sistemi iş parçacığı almak ve bir mutex yayın garanti edemez anlamına gelir çünkü bu eşitleme elde etmek için kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-229">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="cce0f-230">Yönetilen kullanmalısınız <xref:System.Threading.Mutex> sınıf veya bir adlandırılmış <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, veya bir <xref:System.Threading.Semaphore> CLR yönetilmeyen kod kullanarak kilit eşitleme yerine farkında bir şekilde kod kilit eşitlenecek.</span><span class="sxs-lookup"><span data-stu-id="cce0f-230">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="cce0f-231">Lock(typeof(MyType)) kaçının</span><span class="sxs-lookup"><span data-stu-id="cce0f-231">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="cce0f-232">Özel ve genel <xref:System.Type> paylaşılan derlemeler ile tüm uygulama etki alanları arasında paylaşılan kod yalnızca bir kopyasını nesneleri sorunları da sunar.</span><span class="sxs-lookup"><span data-stu-id="cce0f-232">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="cce0f-233">Paylaşılan derlemeler için yalnızca bir örneği olduğu bir <xref:System.Type> her işlem, birden çok uygulama etki alanları tam aynı paylaşıma anlamı <xref:System.Type> örneği.</span><span class="sxs-lookup"><span data-stu-id="cce0f-233">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="cce0f-234">Kilit almayı bir <xref:System.Type> örneği alır değil sürecinin tamamını etkileyen bir kilit yalnızca <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-234">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="cce0f-235">Varsa <xref:System.AppDomain> kilit vereceğine bir <xref:System.Type> iş parçacığı aniden durduruldu, kilit yayınlamayacaktır nesne.</span><span class="sxs-lookup"><span data-stu-id="cce0f-235">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="cce0f-236">Bu kilit ardından kilitlemek diğer uygulama etki alanları neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-236">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="cce0f-237">Statik yöntemleri kilitleri yararlanmak için en iyi yolu, kodu bir statik iç eşitleme nesnesi eklenmesini kapsar.</span><span class="sxs-lookup"><span data-stu-id="cce0f-237">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="cce0f-238">Bu sınıf oluşturucuda varsa, ancak bunu şu şekilde başlatılmamış başlatılamadı:</span><span class="sxs-lookup"><span data-stu-id="cce0f-238">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="cce0f-239">Ardından kilit, kullanım çekerken `InternalSyncObject` özelliği bir nesne üzerinde kilit elde edilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-239">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="cce0f-240">Özelliği kullanırsanız, sınıf oluşturucusu içinde iç eşitleme nesnesi başlatılmadı gerekmez.</span><span class="sxs-lookup"><span data-stu-id="cce0f-240">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="cce0f-241">Çift denetimi kilidi başlatma kodunu şu örnekteki gibi görünmelidir:</span><span class="sxs-lookup"><span data-stu-id="cce0f-241">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="cce0f-242">Lock(this) hakkında bir Not</span><span class="sxs-lookup"><span data-stu-id="cce0f-242">A Note About Lock(this)</span></span>

<span data-ttu-id="cce0f-243">Genel olarak erişilebilir olan tek bir nesne üzerinde bir kilidi almak için genel olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-243">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="cce0f-244">Ancak, nesne bir kilitlenme tüm alt sistemine neden olabilecek bir tekil nesnesi ise, yukarıdaki tasarım deseni de kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="cce0f-244">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="cce0f-245">Örneğin, bir kilit <xref:System.Security.SecurityManager> nesnesi içindeki bir kilitlenme neden <xref:System.AppDomain> tüm yapmadan <xref:System.AppDomain> kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-245">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="cce0f-246">Bu türün ortak olarak erişilebilen bir nesnede kilit olmayacağına iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-246">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="cce0f-247">Ancak bir tek bir koleksiyon veya dizi kilit genellikle bir sorun yoktur.</span><span class="sxs-lookup"><span data-stu-id="cce0f-247">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-248">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-248">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-249">Kilitleri, uygulama etki alanları arasında kullanılıyor olabilir ya da güçlü bir algılama kimliği olmayan türlerde almaz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-249">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="cce0f-250">Çağırmayın <xref:System.Threading.Monitor.Enter%2A> üzerinde bir <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, ya da türetilen herhangi bir nesne <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-250">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="cce0f-251">GC kaldırın. KeepAlive çağrıları</span><span class="sxs-lookup"><span data-stu-id="cce0f-251">Remove GC.KeepAlive Calls</span></span>

<span data-ttu-id="cce0f-252">Varolan kodu önemli ölçüde kullanmaz <xref:System.GC.KeepAlive%2A> zaman gerekir veya uygun olmadığı durumlarda kullanır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-252">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="cce0f-253">Dönüştürme sonra <xref:System.Runtime.InteropServices.SafeHandle>, sınıfları çağırmaya gerek yoktur <xref:System.GC.KeepAlive%2A>, bir sonlandırıcı olmayan ancak dayanır varsayılarak <xref:System.Runtime.InteropServices.SafeHandle> işletim sistemi sonlandırmak için işler.</span><span class="sxs-lookup"><span data-stu-id="cce0f-253">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="cce0f-254">While çağrısı koruma performans maliyeti <xref:System.GC.KeepAlive%2A> durum, göz ardı edilebilir markanızın, çağrı <xref:System.GC.KeepAlive%2A> gerekli ya da artık mevcut olmayabilir sorun kodu korumak daha zor yapar bir ömrü çözmek yeterli.</span><span class="sxs-lookup"><span data-stu-id="cce0f-254">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="cce0f-255">Ancak, COM birlikte çalışma CLR aranabilir sarmalayıcılarını (RCW) kullanırken <xref:System.GC.KeepAlive%2A> kod tarafından hala gereklidir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-255">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-256">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-256">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-257">Kaldırma <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-257">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-host-protection-attribute"></a><span data-ttu-id="cce0f-258">Konak koruma özniteliğini kullanın</span><span class="sxs-lookup"><span data-stu-id="cce0f-258">Use the Host Protection Attribute</span></span>

<span data-ttu-id="cce0f-259"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) bile tam güvenilir kod gibibelirlianabilgisayariçinuygunolanbazıyöntemlerçağırmasınıengellemekiçinanaizinvererekkonakkorumagereksinimlerinibelirlemekiçinbildirimedayalıgüvenlikeylemlerikullanımınısağlar<xref:System.Environment.Exit%2A>veya <xref:System.Windows.Forms.MessageBox.Show%2A> SQL Server için.</span><span class="sxs-lookup"><span data-stu-id="cce0f-259">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="cce0f-260">HPA barındıran ortak dil çalışma zamanı ve uygulama konak koruma, SQL Server gibi yalnızca yönetilmeyen uygulamaları etkiler.</span><span class="sxs-lookup"><span data-stu-id="cce0f-260">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="cce0f-261">Uygulandığında, bağlantı talebi oluşturulmasını güvenlik eylemi sonuçları sınıfta veya yöntemde kullanıma sunan konak kaynaklar temelinde.</span><span class="sxs-lookup"><span data-stu-id="cce0f-261">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="cce0f-262">Kod bir istemci uygulamasında veya konağı korumalı olmayan bir sunucuda çalıştırırsanız öznitelik "evaporates"; değil algılanır ve bu nedenle geçerli olmaz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-262">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="cce0f-263">Bu özniteliğin amacı, konağa özgü programlama modeli yönergeleri, güvenlik davranışı zorlamak sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-263">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="cce0f-264">Bağlantı talebi, model gereksinimleri programlamaya uyumluluğu denetlemek için kullanılır ancak <xref:System.Security.Permissions.HostProtectionAttribute> bir güvenlik izni değil.</span><span class="sxs-lookup"><span data-stu-id="cce0f-264">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="cce0f-265">Konak programlama modeli gereksinimlerine sahip değilse, bağlantı talepleri gerçekleşmez.</span><span class="sxs-lookup"><span data-stu-id="cce0f-265">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="cce0f-266">Bu öznitelik aşağıdakileri tanımlar:</span><span class="sxs-lookup"><span data-stu-id="cce0f-266">This attribute identifies the following:</span></span>

- <span data-ttu-id="cce0f-267">Yöntem veya programlama modeli, konak uymayan sınıfları ancak Aksi halde zararsız.</span><span class="sxs-lookup"><span data-stu-id="cce0f-267">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="cce0f-268">Yöntemleri veya konak programlama modeli uymayan ve kullanıcı sunucusu yönetilen kodu kararsız hale getiren için yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-268">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="cce0f-269">Yöntemleri veya programlama konak uymayan sınıfları model ve sunucu işlemi, bir destabilization için neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-269">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="cce0f-270">Bir korumalı konak ortamında yürütme uygulamalarla çağrılacak olan bir sınıf kitaplığı oluşturuyorsanız, bu öznitelik kullanıma sunan üyeleri uygulamalıdır <xref:System.Security.Permissions.HostProtectionResource> kaynak kategoriler.</span><span class="sxs-lookup"><span data-stu-id="cce0f-270">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="cce0f-271">Bu öznitelik ile .NET Framework sınıf kitaplığı üyeleri yalnızca şu anki çağırıcı denetlenecek neden.</span><span class="sxs-lookup"><span data-stu-id="cce0f-271">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="cce0f-272">Kitaplık üyesini, aynı şekilde, şu anki çağırıcı kontrol neden gerekir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-272">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="cce0f-273">İçinde HPA hakkında daha fazla bilgi edinmek <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-273">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-274">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-274">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-275">SQL Server için eşitleme veya iş parçacığı sunmak için kullanılan tüm yöntemler gerekir tanımlanan HPA ile.</span><span class="sxs-lookup"><span data-stu-id="cce0f-275">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="cce0f-276">Bu durum paylaşma, eşitlenen veya dış işlemleri yönetme yöntemleri içerir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-276">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="cce0f-277"><xref:System.Security.Permissions.HostProtectionResource> SQL Server'ı etkileyen değerler <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, ve <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-277">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="cce0f-278">Ancak, herhangi bir kullanıma sunan herhangi bir yöntemi <xref:System.Security.Permissions.HostProtectionResource> bir HPA tarafından yalnızca SQL etkileyen kaynakları kullananlar tanımlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-278">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="cce0f-279">Yönetilmeyen kodda süresiz olarak Engellemesi değil</span><span class="sxs-lookup"><span data-stu-id="cce0f-279">Do Not Block Indefinitely in Unmanaged Code</span></span>

<span data-ttu-id="cce0f-280">Yönetilen kod yerine yönetilmeyen kodda engelleme, CLR iş parçacığı durdurmak mümkün olmadığı için bir hizmet reddi saldırısına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-280">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="cce0f-281">Engellenen bir iş parçacığı kaldırılmasını CLR engeller <xref:System.AppDomain>, en az son derece güvenli olmayan bazı işlemler yapmaya gerek kalmadan.</span><span class="sxs-lookup"><span data-stu-id="cce0f-281">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="cce0f-282">Bir Win32 kullanarak engelleme eşitleme temel öğesi bir açık bir şey izin veremez örneğidir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-282">Blocking using a Win32 synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="cce0f-283">Bir çağrıda engelleme `ReadFile` bir yuvada mümkünse kaçınılmalıdır; ideal olarak, Win32 API şunun gibi bir işlem zaman aşımına için bir mekanizma sağlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-283">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Win32 API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="cce0f-284">Yerel çağıran herhangi bir yöntemi, ideal olarak makul, sınırlı zaman aşımı ile Win32 çağrı kullanmalısınız.</span><span class="sxs-lookup"><span data-stu-id="cce0f-284">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="cce0f-285">Kullanıcı zaman aşımını belirtmek için izin veriliyorsa, kullanıcı bazı belirli güvenlik izinleri olmadan sonsuz zaman aşımını belirtmek için izin verilmeyen.</span><span class="sxs-lookup"><span data-stu-id="cce0f-285">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="cce0f-286">Bir kılavuz olarak, bir yöntem ~ 10 saniyeden fazla için engeller, zaman aşımları destekleyen bir sürüm kullanması gerekir veya ek CLR desteği gerekir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-286">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="cce0f-287">Sorunlu API'leri bazı örnekleri aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-287">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="cce0f-288">Kanallar (anonim ve adlandırılmış), bir zaman aşımı ile oluşturulabilir; Ancak, kod, hiçbir zaman çağrıları sağlamalısınız `CreateNamedPipe` ya da `WaitNamedPipe` NMPWAIT_WAIT_FOREVER ile.</span><span class="sxs-lookup"><span data-stu-id="cce0f-288">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="cce0f-289">Ayrıca olabilir bir zaman aşımı belirtilmiş olsa bile engelleme beklenmeyen.</span><span class="sxs-lookup"><span data-stu-id="cce0f-289">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="cce0f-290">Çağırma `WriteFile` arabellek varsa, yani tüm bayt yazılır kadar anonim bir kanalda engeller, okunmamış verilerinde `WriteFile` çağrı kanalın arabellek alan okuyucu tarafından serbest kadar engeller.</span><span class="sxs-lookup"><span data-stu-id="cce0f-290">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="cce0f-291">Yuva zaman aşımı mekanizması geliştirir bazı API her zaman kullanmalısınız.</span><span class="sxs-lookup"><span data-stu-id="cce0f-291">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-292">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-292">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-293">Yönetilmeyen kod zaman aşımı olmadan engelleyen bir saldırı hizmet reddi olur.</span><span class="sxs-lookup"><span data-stu-id="cce0f-293">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="cce0f-294">Platform gerçekleştirmeyin çağrılarını çağırmak `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, ve `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="cce0f-294">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="cce0f-295">NMPWAIT_WAIT_FOREVER kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-295">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="cce0f-296">Tüm STA'ya bağımlı özellikler tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-296">Identify Any STA-Dependent Features.</span></span>

<span data-ttu-id="cce0f-297">Tek iş parçacıklı COM apartmanlar (STAs) kullanan herhangi bir kod belirleyin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-297">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="cce0f-298">SQL Server işleminde STAs devre dışıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-298">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="cce0f-299">Bağımlı Özellikler `CoInitialize`içinde SQL Server gibi performans sayaçlarını veya Pano devre dışı bırakılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-299">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="cce0f-300">Sonlandırıcılar eşitleme sorunlarını boş olduğundan emin olun</span><span class="sxs-lookup"><span data-stu-id="cce0f-300">Ensure Finalizers Are Free of Synchronization Problems</span></span>

<span data-ttu-id="cce0f-301">Birden çok Sonlandırıcı iş parçacığı, gelecekte sonlandırıcılar eşzamanlı olarak aynı türde farklı örnekleri için anlamına gelir. .NET Framework sürümleri bulunuyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-301">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="cce0f-302">İş parçacığı güvenli tamamen olması gerekmez; Çöp toplayıcı, yalnızca bir iş parçacığı Sonlandırıcı verilen nesne örneği için çalışacağını garanti eder.</span><span class="sxs-lookup"><span data-stu-id="cce0f-302">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="cce0f-303">Ancak, bir sonlandırıcı aynı anda birden çok farklı nesne örneklerinde çalıştırıldığında, yarış durumlarını ve kilitlenmeleri önlemek için kodlanmış olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-303">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="cce0f-304">İş parçacığı oluşturma sorunları, bir günlük dosyasında bir sonlandırıcı yazma gibi dış durumlarını kullanırken ele alınması gerekir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-304">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="cce0f-305">İş parçacığı güvenliği sağlamak için sonlandırma üzerinde güvenmeyin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-305">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="cce0f-306">İş parçacığı yerel depolaması, yönetilen veya yerel, sonlandırıcı iş parçacığında durumunu depolamak için kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-306">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-307">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-307">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-308">Sonlandırıcılar eşitleme sorunlarını boş olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-308">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="cce0f-309">Bir sonlandırıcı bir statik değişebilir durum kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-309">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="cce0f-310">Yönetilmeyen bellek mümkün olduğunda kaçının</span><span class="sxs-lookup"><span data-stu-id="cce0f-310">Avoid Unmanaged Memory If Possible</span></span>

<span data-ttu-id="cce0f-311">Yönetilmeyen bellek, yalnızca bir işletim sistemi tanıtıcısı gibi be leaked.</span><span class="sxs-lookup"><span data-stu-id="cce0f-311">Unmanaged memory can be leaked, just like an operating system handle.</span></span>  <span data-ttu-id="cce0f-312">Mümkünse, kullanarak yığın bellek kullanmaya çalıştığınızda [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) veya sabitlenmiş bir yönetilen nesne gibi [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) veya <xref:System.Runtime.InteropServices.GCHandle> kullanarak bir byte [].</span><span class="sxs-lookup"><span data-stu-id="cce0f-312">If possible, try to use memory on the stack using [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) or a pinned managed object such as the [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span>  <span data-ttu-id="cce0f-313"><xref:System.GC> Sonunda bunlar temizler.</span><span class="sxs-lookup"><span data-stu-id="cce0f-313">The <xref:System.GC> eventually cleans these up.</span></span>  <span data-ttu-id="cce0f-314">Yönetilmeyen bellek gerekir, ancak türetilen bir sınıf kullanmayı düşünün <xref:System.Runtime.InteropServices.SafeHandle> bellek ayırma sarmalamak için.</span><span class="sxs-lookup"><span data-stu-id="cce0f-314">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="cce0f-315">En az bir durumu olduğunu unutmayın. burada <xref:System.Runtime.InteropServices.SafeHandle> yeterli değil.</span><span class="sxs-lookup"><span data-stu-id="cce0f-315">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span>  <span data-ttu-id="cce0f-316">Ayırma ya da boş bellek COM yöntem çağrılarında aracılığıyla bellek ayırmak bir DLL için ortak olan `CoTaskMemAlloc` başka bir DLL ile bu bellek serbest bırakma sonra `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="cce0f-316">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="cce0f-317">Kullanarak <xref:System.Runtime.InteropServices.SafeHandle> yaşam ömrü yönetilmeyen bellek tie dener olduğundan bu sayfalarda uygunsuz olacaktır <xref:System.Runtime.InteropServices.SafeHandle> bir DLL denetim bellek kullanım ömrünü izin vermek yerine.</span><span class="sxs-lookup"><span data-stu-id="cce0f-317">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="cce0f-318">Tüm kullanımları Catch(Exception) gözden geçirin</span><span class="sxs-lookup"><span data-stu-id="cce0f-318">Review All Uses of Catch(Exception)</span></span>

<span data-ttu-id="cce0f-319">Catch blokları catch tüm özel durumlar yerine bir özel durum artık zaman uyumsuz özel durumları da yakalar.</span><span class="sxs-lookup"><span data-stu-id="cce0f-319">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span>  <span data-ttu-id="cce0f-320">İncelemek, olası yanlış bir davranışı catch bloğu içinde kendisi için işleme yanı sıra atlanabilir hiçbir önemli kaynak serbest bırakma veya geri çıkma kodu aranıyor, her bir catch(Exception) bloğu bir <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, veya <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-320">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="cce0f-321">Bu kod günlüğü ya da tam olarak bir belirli neden için başarısız bir özel durum gerçekleştiğinde, yalnızca belirli özel durumları veya görebileceği bazı varsayımlar yapmak mümkün olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-321">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="cce0f-322">Bu varsayımları içerecek şekilde güncelleştirilmesi gerekebilir <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-322">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="cce0f-323">Tüm değiştirme yerleştirir belirli türde bir beklediğiniz özel durumu yakalamak için tüm özel durumları oluşturulur, bu catch gibi göz önünde bir <xref:System.FormatException> dizeden biçimlendirme yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="cce0f-323">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="cce0f-324">Bu yakalama bloğunun beklenmeyen özel durumlar üzerinde çalışmasını engeller ve kod hataları beklenmeyen özel durumları yakalama tarafından gizlemez olmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="cce0f-324">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="cce0f-325">Genel bir kural olarak, hiçbir zaman kitaplık kodu bir özel durum işleme (bir özel durum yakalamak gereken kod, çağırdığınız kod uygulamadaki bir tasarım kusurunun belirtebilir).</span><span class="sxs-lookup"><span data-stu-id="cce0f-325">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="cce0f-326">Bazı durumlarda bir özel durum catch ve throw daha fazla veri sağlamak için farklı bir özel durum türü isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-326">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="cce0f-327">İç içe geçmiş özel durumları, bu durumda, gerçek hata nedenini depolamak kullanın <xref:System.Exception.InnerException%2A> yeni özel durum özelliği.</span><span class="sxs-lookup"><span data-stu-id="cce0f-327">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-328">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-328">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-329">Yönetilen kodda tüm catch bloğu bu catch tüm nesneleri veya tüm catch özel durumları gözden geçirin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-329">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="cce0f-330">İçinde C#, her ikisi de işaretlemesini yani `catch` {} ve `catch(Exception)` {}.</span><span class="sxs-lookup"><span data-stu-id="cce0f-330">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="cce0f-331">Özel durum türü belirli yapmayı düşünün veya bir beklenmeyen özel durum türü yakalarsa hatalı bir şekilde davranmaz emin olmak için kodu gözden geçirin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-331">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="cce0f-332">Varsaymayın Win32 iş parçacığı – bir Fiber olan yönetilen bir iş parçacığı</span><span class="sxs-lookup"><span data-stu-id="cce0f-332">Do Not Assume a Managed Thread Is a Win32 Thread – It Is a Fiber</span></span>

<span data-ttu-id="cce0f-333">Yönetilen iş parçacığı yerel depolama çalışır ama değil yönetilmeyen iş parçacığı yerel depolaması kullanıyorsanız veya kodu geçerli işletim sistemi iş parçacığı üzerinde yeniden çalıştıracak varsayar kullanarak.</span><span class="sxs-lookup"><span data-stu-id="cce0f-333">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span>  <span data-ttu-id="cce0f-334">Ayarları gibi iş parçacığının yerel ayarını değiştirmeyin.</span><span class="sxs-lookup"><span data-stu-id="cce0f-334">Do not change settings like the thread’s locale.</span></span>  <span data-ttu-id="cce0f-335">Çağırmayın `InitializeCriticalSection` veya `CreateMutex` kilit girer işletim sistemi iş parçacığı de kilit çıkmak gerektirdiğinden platform çağırma.</span><span class="sxs-lookup"><span data-stu-id="cce0f-335">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span>  <span data-ttu-id="cce0f-336">Bu durum iyileştirmesini kullanırken bulunmaz, Win32 kritik bölümler ve mutex'leri SQL'de doğrudan kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-336">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="cce0f-337">Unutmayın yönetilen <xref:System.Threading.Mutex> sınıfı, bu iş parçacığı benzeşimini sorunlar işlemez.</span><span class="sxs-lookup"><span data-stu-id="cce0f-337">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="cce0f-338">Güvenli bir şekilde durumu çoğunu yönetilen üzerinde kullanabileceğiniz <xref:System.Threading.Thread> yönetilen iş parçacığı yerel depolama ve iş parçacığının geçerli UI kültürünün dahil olmak üzere bir nesne.</span><span class="sxs-lookup"><span data-stu-id="cce0f-338">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span>  <span data-ttu-id="cce0f-339">Ayrıca <xref:System.ThreadStaticAttribute>, getiren mevcut bir statik değişken değerini erişilebilir (Bu, CLR yerel depolamada fiber yapmanın başka bir yolu) yalnızca geçerli yönetilen iş parçacığı tarafından.</span><span class="sxs-lookup"><span data-stu-id="cce0f-339">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span>  <span data-ttu-id="cce0f-340">Programlama modeli nedeniyle, bir iş parçacığının geçerli kültürü SQL'de çalıştırırken değiştirilemiyor.</span><span class="sxs-lookup"><span data-stu-id="cce0f-340">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-341">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-341">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-342">SQL Server fiber modda çalışır; iş parçacığı yerel depolama kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-342">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="cce0f-343">Platform önlemek için çağrıları `TlsAlloc`, `TlsFree`, `TlsGetValue`, ve `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="cce0f-343">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="cce0f-344">SQL Server tanıtıcı kimliğe bürünme sağlar</span><span class="sxs-lookup"><span data-stu-id="cce0f-344">Let SQL Server Handle Impersonation</span></span>

<span data-ttu-id="cce0f-345">Kimliğe bürünme iş parçacığı düzeyinde çalışır ve SQL çalışma zamanı fiber modunda olduğundan, yönetilen kod kullanıcıların kimliğine değil ve çağırmamalıdır `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="cce0f-345">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-346">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-346">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-347">SQL Server'ın kimliğe bürünme işlemek olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-347">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="cce0f-348">Kullanmayın `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, veya `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="cce0f-348">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="cce0f-349">Thread::suspend çağırmayın</span><span class="sxs-lookup"><span data-stu-id="cce0f-349">Do Not Call Thread::Suspend</span></span>

<span data-ttu-id="cce0f-350">Bir iş parçacığını askıya alma olanağı, basit bir işlemle görünebilir, ancak kilitlenmeleri neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-350">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="cce0f-351">İkinci bir iş parçacığı ve ardından ikinci bir iş parçacığı tarafından askıya bir kilidi tutan bir iş parçacığı aynı kilit almayı denerse bir kilitlenme oluşur.</span><span class="sxs-lookup"><span data-stu-id="cce0f-351">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="cce0f-352"><xref:System.Threading.Thread.Suspend%2A> Güvenlik, sınıf yükleme, uzaktan iletişim ve yansıma ile şu anda engelleyebilir.</span><span class="sxs-lookup"><span data-stu-id="cce0f-352"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cce0f-353">Kod çözümleme kural</span><span class="sxs-lookup"><span data-stu-id="cce0f-353">Code Analysis Rule</span></span>

<span data-ttu-id="cce0f-354">Çağırmayın <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-354">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="cce0f-355">Gerçek bir eşitleme kullanmayı bunun yerine, gibi ilkel bir <xref:System.Threading.Semaphore> veya <xref:System.Threading.ManualResetEvent> .</span><span class="sxs-lookup"><span data-stu-id="cce0f-355">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="cce0f-356">Kısıtlı yürütme bölgeleri ve güvenilirlik sözleşmeleri kritik işlemler koruyun</span><span class="sxs-lookup"><span data-stu-id="cce0f-356">Protect Critical Operations with Constrained Execution Regions and Reliability Contracts</span></span>

<span data-ttu-id="cce0f-357">Paylaşılan durum güncelleştirmelerinin karmaşık bir işlemi gerçekleştirirken veya, gerekiyor belirleyici ya da tamamen başarılı ya da tamamen başarısız kısıtlı yürütme bölgeye göre (CER) korumalı olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="cce0f-357">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="cce0f-358">Bu kod her durumda bile bir ani iş parçacığı durdurma veya bir ani çalışır garanti eder <xref:System.AppDomain> kaldırın.</span><span class="sxs-lookup"><span data-stu-id="cce0f-358">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="cce0f-359">Belirli bir CER olan `try/finally` bloğu için bir çağrı tarafından hemen öncesinde <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="cce0f-359">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="cce0f-360">Bunu yapmak, bu nedenle tüm kodu hazırlamak için tam zamanında derleyici bildirir çalıştırmadan önce finally bloğunda `try` blok.</span><span class="sxs-lookup"><span data-stu-id="cce0f-360">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="cce0f-361">Bu, kod içinde garanti finally bloğu yerleşik olarak bulunur ve tüm durumlarda çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="cce0f-361">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="cce0f-362">Boş olması, bir CER durumdur `try` blok.</span><span class="sxs-lookup"><span data-stu-id="cce0f-362">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="cce0f-363">Bir CER kullanarak zaman uyumsuz iş parçacığı iptalleri ve bellek yetersiz özel durumları karşı korur.</span><span class="sxs-lookup"><span data-stu-id="cce0f-363">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="cce0f-364">Bkz: <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> ayrıca tanıtıcıları yığın verebilmesine derin kodunu taşmaları bir CER formu.</span><span class="sxs-lookup"><span data-stu-id="cce0f-364">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="cce0f-365">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="cce0f-365">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="cce0f-366">SQL Server Programlama ve Konak Koruması Öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="cce0f-366">SQL Server Programming and Host Protection Attributes</span></span>](../../../docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)

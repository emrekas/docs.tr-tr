---
title: Yavaş Başlatma
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: ce217e2ed8e542ad0f7122970655aa32a353f51a
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61949948"
---
# <a name="lazy-initialization"></a><span data-ttu-id="892f5-102">Yavaş Başlatma</span><span class="sxs-lookup"><span data-stu-id="892f5-102">Lazy Initialization</span></span>
<span data-ttu-id="892f5-103">*Yavaş başlatma* nesnenin anlamına gelir oluşturulduktan önce kullanılana kadar ertelenir.</span><span class="sxs-lookup"><span data-stu-id="892f5-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="892f5-104">(Bu konu için koşulları *yavaş başlatma* ve *yavaş oluşturmada* eşanlamlıdır.) Yavaş başlatma, öncelikle performansı iyileştirmek için kısıp hesaplama önlemek ve program bellek gereksinimlerini azaltmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="892f5-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="892f5-105">En yaygın senaryolar şunlardır:</span><span class="sxs-lookup"><span data-stu-id="892f5-105">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="892f5-106">Oluşturmak pahalı bir nesnesinin yüklü ve program kullanamayabilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="892f5-107">Örneğin, bellekte olduğunu varsayalım. bir `Customer` nesnesi bir `Orders` içeren büyük bir dizi özelliği `Order` nesneleri başlatılması için bir veritabanı bağlantısı gerektirir.</span><span class="sxs-lookup"><span data-stu-id="892f5-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="892f5-108">Kullanıcı, siparişleri görüntülemek veya bir hesaplamanın verileri kullanmak hiçbir zaman isterse, sistem belleği veya döngüleri bilgi işlem oluşturmak için kullanılacak bir neden yoktur.</span><span class="sxs-lookup"><span data-stu-id="892f5-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="892f5-109">Kullanarak `Lazy<Orders>` bildirmek için `Orders` kaçınırsınız İsraf sistem kaynaklarının olmadığında nesne yavaş başlatma için nesne.</span><span class="sxs-lookup"><span data-stu-id="892f5-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="892f5-110">Ne zaman oluşturulacağı pahalı bir nesneye sahip ve diğer pahalı işlemler tamamlandıktan sonra oluşturulduktan kadar erteleme istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="892f5-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="892f5-111">Örneğin, programınız başlar, ancak bazı yalnızca hemen gerekli olan birden fazla nesne örneklerini yükler varsayalım.</span><span class="sxs-lookup"><span data-stu-id="892f5-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="892f5-112">Gerekli nesnelerden oluşturulan kadar gerekli olmayan nesnelerin başlatılması erteleyerek program başlangıç performansını artırabilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="892f5-113">Yavaş başlatma gerçekleştirmek için kendi kodunuzu yazabilirsiniz olmasa da kullanmanızı öneririz <xref:System.Lazy%601> yerine.</span><span class="sxs-lookup"><span data-stu-id="892f5-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="892f5-114"><xref:System.Lazy%601> ve ilgili türlerinden de iş parçacığı güvenliği destek ve tutarlı bir özel durum yayma İlkesi belirtin.</span><span class="sxs-lookup"><span data-stu-id="892f5-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="892f5-115">Aşağıdaki tabloda farklı senaryolarda yavaş başlatma etkinleştirmek için .NET Framework sürüm 4 sağlayan türleri listelenmektedir.</span><span class="sxs-lookup"><span data-stu-id="892f5-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="892f5-116">Tür</span><span class="sxs-lookup"><span data-stu-id="892f5-116">Type</span></span>|<span data-ttu-id="892f5-117">Açıklama</span><span class="sxs-lookup"><span data-stu-id="892f5-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="892f5-118">Sarmalayıcı sınıf herhangi bir sınıf kitaplığı veya kullanıcı tanımlı tür için yavaş başlatma semantikler sağlar.</span><span class="sxs-lookup"><span data-stu-id="892f5-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="892f5-119">Benzer <xref:System.Lazy%601> dışında bir iş parçacığı-yerel olarak yavaş başlatma semantiği sağlar.</span><span class="sxs-lookup"><span data-stu-id="892f5-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="892f5-120">Her iş parçacığı kendi benzersiz bir değer erişebilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="892f5-121">Sağlayan gelişmiş `static` (`Shared` Visual Basic'te) bir sınıf yükü olmadan nesnelerin geç başlatılmasını için yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="892f5-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="892f5-122">Temel yavaş başlatma</span><span class="sxs-lookup"><span data-stu-id="892f5-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="892f5-123">Geç başlatılan tür, örneğin, tanımlama için `MyType`, kullanın `Lazy<MyType>` (`Lazy(Of MyType)` Visual Basic'te), aşağıdaki örnekte gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="892f5-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="892f5-124">Hiçbir temsilci geçtiyse <xref:System.Lazy%601> oluşturucusu, kaydırılmış tür oluşturulur kullanarak <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> zaman value özelliği ilk erişilen.</span><span class="sxs-lookup"><span data-stu-id="892f5-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="892f5-125">Türü varsayılan bir oluşturucuya sahip değilse, bir çalışma zamanı özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="892f5-125">If the type does not have a default constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="892f5-126">Aşağıdaki örnekte, varsayımında `Orders` bir dizi içeren bir sınıf `Order` nesnelerini bir veritabanından alınır.</span><span class="sxs-lookup"><span data-stu-id="892f5-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="892f5-127">A `Customer` nesne örneğini içeren `Orders`, ancak kullanıcı eylemlerini, verilerden bağlı olarak `Orders` nesne gerekli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="892f5-128">Bir temsilci de geçirebilirsiniz <xref:System.Lazy%601> belirli bir oluşturucu çağırır oluşturucu aşırı Sarmalanan tür üzerinde oluşturma zamanında ve aşağıdaki örnekte gösterildiği gibi gerekli olan tüm diğer başlatma adımlarını gerçekleştirin.</span><span class="sxs-lookup"><span data-stu-id="892f5-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="892f5-129">Yavaş nesnesi oluşturulur sonra hiçbir örneği `Orders` kadar oluşturulan <xref:System.Lazy%601.Value%2A> yavaş değişkeninin özelliği ilk kez erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="892f5-130">İlk erişimde kaydırılmış tür oluşturulur ve döndürülen ve herhangi bir gelecek erişimi için depolanır.</span><span class="sxs-lookup"><span data-stu-id="892f5-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="892f5-131">A <xref:System.Lazy%601> nesne her zaman aynı nesne veya ile başlatıldı değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="892f5-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="892f5-132">Bu nedenle, <xref:System.Lazy%601.Value%2A> özelliği salt okunur.</span><span class="sxs-lookup"><span data-stu-id="892f5-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="892f5-133">Varsa <xref:System.Lazy%601.Value%2A> depoları başvuru türü, yeni bir nesne kendisine atayamazsınız.</span><span class="sxs-lookup"><span data-stu-id="892f5-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="892f5-134">(Ancak ayarlanabilir genel alanlar ve Özellikler değerini değiştirebilirsiniz.) Varsa <xref:System.Lazy%601.Value%2A> depoları bir değer türü, değerini değiştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="892f5-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="892f5-135">Bununla birlikte, değişken Oluşturucu yeniden yeni bağımsız değişkenler kullanarak harekete geçirerek yeni bir değişken oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="892f5-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="892f5-136">Yeni yavaş, önceki bir gibi değil örneğini `Orders` kadar kendi <xref:System.Lazy%601.Value%2A> özelliği ilk kez erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="892f5-137">İş parçacığı açısından güvenli başlatma</span><span class="sxs-lookup"><span data-stu-id="892f5-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="892f5-138">Varsayılan olarak, <xref:System.Lazy%601> iş parçacığı açısından güvenli nesneleridir.</span><span class="sxs-lookup"><span data-stu-id="892f5-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="892f5-139">Diğer bir deyişle, oluşturucu iş parçacığı güvenliği türü belirtmezse <xref:System.Lazy%601> oluşturduğu iş parçacığı açısından güvenli nesneleridir.</span><span class="sxs-lookup"><span data-stu-id="892f5-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="892f5-140">Çok iş parçacıklı senaryolarda erişmek için ilk iş parçacığında <xref:System.Lazy%601.Value%2A> iş parçacığı açısından güvenli özelliği <xref:System.Lazy%601> nesne için tüm iş parçacıklarının sonraki tüm erişimlerde onu başlatır ve tüm iş parçacıkları aynı verileri paylaşın.</span><span class="sxs-lookup"><span data-stu-id="892f5-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="892f5-141">Bu nedenle, hangi iş parçacığı nesnesi başlatan bir önemi yoktur ve yarış durumları zararsızdır.</span><span class="sxs-lookup"><span data-stu-id="892f5-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="892f5-142">Bu tutarlılık hata koşulları için özel durum Önbelleği'ni kullanarak genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="892f5-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="892f5-143">Daha fazla bilgi için sonraki bölüme bakın [yavaş nesneleri durumlar](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="892f5-143">For more information, see the next section, [Exceptions in Lazy Objects](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="892f5-144">Aşağıdaki örnek aynı gösteren `Lazy<int>` örneği için üç ayrı iş parçacığı aynı değere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="892f5-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="892f5-145">Her iş parçacığı üzerinde ayrı veri gerekiyorsa kullanın <xref:System.Threading.ThreadLocal%601> , bu konunun ilerleyen bölümlerinde açıklandığı şekilde yazın.</span><span class="sxs-lookup"><span data-stu-id="892f5-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="892f5-146">Bazı <xref:System.Lazy%601> oluşturuculara sahip adlı bir Boole parametresi `isThreadSafe` belirtmek için kullanılan olmadığını <xref:System.Lazy%601.Value%2A> özelliği birden çok iş parçacığı tarafından erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="892f5-147">Özelliği yalnızca bir iş parçacığından erişmek istiyorsanız, geçirin `false` büyüklükteki performans avantajı elde edilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="892f5-148">Özellik birden fazla iş parçacığından erişmek istiyorsanız, geçirin `true` istemek için <xref:System.Lazy%601> tek bir iş parçacığı başlatma sırasında bir özel durum oluşturduğunda yarış durumlarını doğru bir şekilde işlemek için örneği.</span><span class="sxs-lookup"><span data-stu-id="892f5-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="892f5-149">Bazı <xref:System.Lazy%601> oluşturuculara sahip bir <xref:System.Threading.LazyThreadSafetyMode> adlı parametre `mode`.</span><span class="sxs-lookup"><span data-stu-id="892f5-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="892f5-150">Bu oluşturucular bir ek iş parçacığı güvenlik modu sağlar.</span><span class="sxs-lookup"><span data-stu-id="892f5-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="892f5-151">Aşağıdaki tabloda nasıl, iş parçacığı güvenliği bir <xref:System.Lazy%601> nesne iş parçacığı güvenliği belirtin Oluşturucusu parametrelerin etkilenir.</span><span class="sxs-lookup"><span data-stu-id="892f5-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="892f5-152">Her Oluşturucu en fazla bir tür parametresi vardır.</span><span class="sxs-lookup"><span data-stu-id="892f5-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="892f5-153">Nesne iş parçacığı güvenliği</span><span class="sxs-lookup"><span data-stu-id="892f5-153">Thread safety of the object</span></span>|<span data-ttu-id="892f5-154">`LazyThreadSafetyMode` `mode` Parametre</span><span class="sxs-lookup"><span data-stu-id="892f5-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="892f5-155">Boole `isThreadSafe` parametresi</span><span class="sxs-lookup"><span data-stu-id="892f5-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="892f5-156">İş parçacığı güvenliği parametre yok</span><span class="sxs-lookup"><span data-stu-id="892f5-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="892f5-157">Tam iş parçacığı açısından güvenli; aynı anda yalnızca tek bir iş parçacığı değeriyle dener.</span><span class="sxs-lookup"><span data-stu-id="892f5-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="892f5-158">Evet.</span><span class="sxs-lookup"><span data-stu-id="892f5-158">Yes.</span></span>|  
|<span data-ttu-id="892f5-159">İş parçacığı-güvenli değildir.</span><span class="sxs-lookup"><span data-stu-id="892f5-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="892f5-160">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="892f5-160">Not applicable.</span></span>|  
|<span data-ttu-id="892f5-161">Tam iş parçacığı açısından güvenli; iş parçacıkları yarış'değeri başlatılamadı.</span><span class="sxs-lookup"><span data-stu-id="892f5-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="892f5-162">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="892f5-162">Not applicable.</span></span>|<span data-ttu-id="892f5-163">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="892f5-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="892f5-164">Tablonun gösterdiği gibi belirtme <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> için `mode` parametre belirtmekle aynı olan `true` için `isThreadSafe` parametresi ve belirterek <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> belirtmekle aynı `false`.</span><span class="sxs-lookup"><span data-stu-id="892f5-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="892f5-165">Belirtme <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> birden çok iş parçacığı başlatmaya sağlayan <xref:System.Lazy%601> örneği.</span><span class="sxs-lookup"><span data-stu-id="892f5-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="892f5-166">Yalnızca bir iş parçacığı bu yarışını kazanmak ve diğer tüm iş başarılı bir iş parçacığı tarafından başlatıldı değerini alır.</span><span class="sxs-lookup"><span data-stu-id="892f5-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="892f5-167">Başlatma sırasında bir iş parçacığında bir özel durum, iş parçacığı başarılı bir iş parçacığı tarafından ayarlanan değer almaz.</span><span class="sxs-lookup"><span data-stu-id="892f5-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="892f5-168">Özel durumlar önbelleğe alınmaz, bu nedenle erişmek için sonraki bir girişimi <xref:System.Lazy%601.Value%2A> özelliği içinde başarıyla başlatılmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="892f5-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="892f5-169">Bu, aşağıdaki bölümde anlatılan diğer modlarda özel durumları kabul edilir şekilde farklıdır.</span><span class="sxs-lookup"><span data-stu-id="892f5-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="892f5-170">Daha fazla bilgi için <xref:System.Threading.LazyThreadSafetyMode> sabit listesi.</span><span class="sxs-lookup"><span data-stu-id="892f5-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="892f5-171">Yavaş nesneleri özel durumları</span><span class="sxs-lookup"><span data-stu-id="892f5-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="892f5-172">Daha önce belirtildiği gibi bir <xref:System.Lazy%601> nesne her zaman aynı nesne veya birlikte başlatıldı değerini döndürür ve bu nedenle <xref:System.Lazy%601.Value%2A> özelliği salt okunur.</span><span class="sxs-lookup"><span data-stu-id="892f5-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="892f5-173">Özel durum önbelleğe almayı etkinleştirirseniz, bu değiştirilemezlik ayrıca özel durum davranışını genişletir.</span><span class="sxs-lookup"><span data-stu-id="892f5-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="892f5-174">Geç başlatılan bir nesne özel durum önbelleği etkinleştirildi ve kendi başlatma yöntemden bir özel durum oluşturur, <xref:System.Lazy%601.Value%2A> özelliğine önce erişilirse, o aynı erişmek için sonraki her denemede özel durum <xref:System.Lazy%601.Value%2A> özelliği .</span><span class="sxs-lookup"><span data-stu-id="892f5-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="892f5-175">Diğer bir deyişle, kaydırılmış Tür oluşturucu hiçbir zaman, hatta çok iş parçacıklı senaryolarda yeniden çağrılır.</span><span class="sxs-lookup"><span data-stu-id="892f5-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="892f5-176">Bu nedenle, <xref:System.Lazy%601> nesne üzerinde bir erişim bir özel durum ve bir sonraki erişimi bir değer döndürür.</span><span class="sxs-lookup"><span data-stu-id="892f5-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="892f5-177">Özel önbelleğe alma etkin kullandığınızda <xref:System.Lazy%601?displayProperty=nameWithType> başlatma yöntemini alan oluşturucu (`valueFactory` parametresi); Örneğin, kullandığınız zaman etkin `Lazy(T)(Func(T))`Oluşturucusu.</span><span class="sxs-lookup"><span data-stu-id="892f5-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="892f5-178">Oluşturucu ayrıca uzun sürerse bir <xref:System.Threading.LazyThreadSafetyMode> değeri (`mode` parametresi), belirtin <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> veya <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="892f5-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="892f5-179">Başlatma yöntemini belirleme, özel durum, bu iki mod için önbelleğe alınmasını etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="892f5-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="892f5-180">Başlatma yöntemi çok basit olabilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-180">The initialization method can be very simple.</span></span> <span data-ttu-id="892f5-181">Örneğin, varsayılan oluşturucusu çağırabilirsiniz `T`: `new Lazy<Contents>(() => new Contents(), mode)` C# veya `New Lazy(Of Contents)(Function() New Contents())` Visual Basic'te.</span><span class="sxs-lookup"><span data-stu-id="892f5-181">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="892f5-182">Kullanıyorsanız bir <xref:System.Lazy%601?displayProperty=nameWithType> başlatma yöntemini belirtmeyen bir kurucu, için varsayılan oluşturucu tarafından oluşturulan özel durumları `T` önbelleğe alınmaz.</span><span class="sxs-lookup"><span data-stu-id="892f5-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="892f5-183">Daha fazla bilgi için <xref:System.Threading.LazyThreadSafetyMode> sabit listesi.</span><span class="sxs-lookup"><span data-stu-id="892f5-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="892f5-184">Oluşturursanız, bir <xref:System.Lazy%601> nesnesi ile `isThreadSafe` kümesine Oluşturucu parametresi `false` veya `mode` kümesine Oluşturucu parametresi <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, erişmesi gereken <xref:System.Lazy%601> nesne tek bir iş parçacığından veya kendi sağlayın Eşitleme.</span><span class="sxs-lookup"><span data-stu-id="892f5-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="892f5-185">Bu, özel durum önbelleğe alma dahil olmak üzere nesnenin tüm yönleri için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="892f5-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="892f5-186">Önceki bölümde belirtildiği gibi <xref:System.Lazy%601> belirterek oluşturulan nesneleri <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> özel durumlar farklı şekilde ele.</span><span class="sxs-lookup"><span data-stu-id="892f5-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="892f5-187">İle <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, birden çok iş parçacığı başlatılamadı yarışabileceğiniz <xref:System.Lazy%601> örneği.</span><span class="sxs-lookup"><span data-stu-id="892f5-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="892f5-188">Bu durumda, özel durumlar önbelleğe alınmaz ve erişmeye <xref:System.Lazy%601.Value%2A> özellik başlatma başarılı olana kadar devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="892f5-189">Aşağıdaki tabloda özetlenmiştir biçimini <xref:System.Lazy%601> oluşturucular denetim özel önbelleğe alma.</span><span class="sxs-lookup"><span data-stu-id="892f5-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="892f5-190">Oluşturucu</span><span class="sxs-lookup"><span data-stu-id="892f5-190">Constructor</span></span>|<span data-ttu-id="892f5-191">İş parçacığı güvenlik modu</span><span class="sxs-lookup"><span data-stu-id="892f5-191">Thread safety mode</span></span>|<span data-ttu-id="892f5-192">Başlatma yöntemi kullanır.</span><span class="sxs-lookup"><span data-stu-id="892f5-192">Uses initialization method</span></span>|<span data-ttu-id="892f5-193">Özel durumlar önbelleğe alınır</span><span class="sxs-lookup"><span data-stu-id="892f5-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="892f5-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="892f5-194">Lazy(T)()</span></span>|<span data-ttu-id="892f5-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="892f5-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="892f5-196">Hayır</span><span class="sxs-lookup"><span data-stu-id="892f5-196">No</span></span>|<span data-ttu-id="892f5-197">Hayır</span><span class="sxs-lookup"><span data-stu-id="892f5-197">No</span></span>|  
|<span data-ttu-id="892f5-198">Lazy(T)(FUNC(T))</span><span class="sxs-lookup"><span data-stu-id="892f5-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="892f5-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="892f5-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="892f5-200">Evet</span><span class="sxs-lookup"><span data-stu-id="892f5-200">Yes</span></span>|<span data-ttu-id="892f5-201">Evet</span><span class="sxs-lookup"><span data-stu-id="892f5-201">Yes</span></span>|  
|<span data-ttu-id="892f5-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="892f5-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="892f5-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) veya `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="892f5-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="892f5-204">Hayır</span><span class="sxs-lookup"><span data-stu-id="892f5-204">No</span></span>|<span data-ttu-id="892f5-205">Hayır</span><span class="sxs-lookup"><span data-stu-id="892f5-205">No</span></span>|  
|<span data-ttu-id="892f5-206">Lazy(T)(FUNC(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="892f5-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="892f5-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) veya `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="892f5-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="892f5-208">Evet</span><span class="sxs-lookup"><span data-stu-id="892f5-208">Yes</span></span>|<span data-ttu-id="892f5-209">Evet</span><span class="sxs-lookup"><span data-stu-id="892f5-209">Yes</span></span>|  
|<span data-ttu-id="892f5-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="892f5-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="892f5-211">Kullanıcı tarafından belirtilen</span><span class="sxs-lookup"><span data-stu-id="892f5-211">User-specified</span></span>|<span data-ttu-id="892f5-212">Hayır</span><span class="sxs-lookup"><span data-stu-id="892f5-212">No</span></span>|<span data-ttu-id="892f5-213">Hayır</span><span class="sxs-lookup"><span data-stu-id="892f5-213">No</span></span>|  
|<span data-ttu-id="892f5-214">Lazy(T)(FUNC(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="892f5-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="892f5-215">Kullanıcı tarafından belirtilen</span><span class="sxs-lookup"><span data-stu-id="892f5-215">User-specified</span></span>|<span data-ttu-id="892f5-216">Evet</span><span class="sxs-lookup"><span data-stu-id="892f5-216">Yes</span></span>|<span data-ttu-id="892f5-217">Kullanıcının belirttiği Hayır <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; tersi durumda, Evet.</span><span class="sxs-lookup"><span data-stu-id="892f5-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="892f5-218">Geç başlatılan bir özelliği uygulama</span><span class="sxs-lookup"><span data-stu-id="892f5-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="892f5-219">Geç Başlatma kullanarak ortak özelliği uygulamak için olarak özelliğinin destek alanı tanımlar. bir <xref:System.Lazy%601>ve dönüş <xref:System.Lazy%601.Value%2A> özelliğinden `get` özellik erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="892f5-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="892f5-220"><xref:System.Lazy%601.Value%2A> Özelliği salt okunur; bu nedenle, kullanıma sunduğu özellik yoktur `set` erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="892f5-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="892f5-221">Tarafından desteklenen bir okuma/yazma özelliği gerekliyse bir <xref:System.Lazy%601> nesnesi `set` erişimci yeni oluşturmalısınız <xref:System.Lazy%601> nesne ve yedekleme deposu için atayın.</span><span class="sxs-lookup"><span data-stu-id="892f5-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="892f5-222">`set` Erişimci geçildi yeni özellik değeri döndüren bir lambda ifadesi oluşturmalısınız `set` erişimci ve oluşturucuya, lambda ifadesi için yeni geçirin <xref:System.Lazy%601> nesne.</span><span class="sxs-lookup"><span data-stu-id="892f5-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="892f5-223">Sonraki erişim <xref:System.Lazy%601.Value%2A> özelliği yeni başlatma neden olacak <xref:System.Lazy%601>ve onun <xref:System.Lazy%601.Value%2A> özelliği bundan sonra özelliğine atanan yeni değer döndürür.</span><span class="sxs-lookup"><span data-stu-id="892f5-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="892f5-224">Bu yaşar düzenleme için yerleşik çoklu iş parçacığı kullanımı korumaları korumak için nedeni <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="892f5-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="892f5-225">Aksi takdirde, özellik erişimcileri tarafından döndürülen değerin ilk önbellek zorunda <xref:System.Lazy%601.Value%2A> özelliği yalnızca önbelleğe alınan değeri değiştirmek ve bunu yapmak için kendi iş parçacığı açısından güvenli kod yazma gerekir.</span><span class="sxs-lookup"><span data-stu-id="892f5-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="892f5-226">Tarafından desteklenen bir okuma/yazma özelliği gerektirdiği ek başlatmalar nedeniyle bir <xref:System.Lazy%601> nesnesi, performansı kabul edilebilir olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="892f5-227">Ayrıca, belirli bir senaryoya bağlı olarak, ek koordinasyon yarış ayarlayıcılar alıcıları arasındaki önlemek için gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="892f5-228">İş parçacığı-yerel yavaş başlatma</span><span class="sxs-lookup"><span data-stu-id="892f5-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="892f5-229">Çok iş parçacıklı bazı senaryolarda, her iş parçacığının kendi özel veri vermek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="892f5-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="892f5-230">Bu tür veriler denir *iş parçacığı-yerel veri*.</span><span class="sxs-lookup"><span data-stu-id="892f5-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="892f5-231">.NET Framework sürüm 3.5 ve önceki sürümlerinde, geçerli olabilir `ThreadStatic` özniteliği iş parçacığı-yerel yapmak için bir statik değişken.</span><span class="sxs-lookup"><span data-stu-id="892f5-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="892f5-232">Ancak, `ThreadStatic` özniteliği Zarif hatalarına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="892f5-233">Örneğin, aşağıdaki örnekte gösterildiği gibi erişen yalnızca ilk iş parçacığında başlatılacak değişkeni bile temel başlatma deyimleri neden olur.</span><span class="sxs-lookup"><span data-stu-id="892f5-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="892f5-234">Tüm diğer iş parçacıkları üzerinde varsayılan değerine (sıfır) kullanarak değişkeni başlatılır.</span><span class="sxs-lookup"><span data-stu-id="892f5-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="892f5-235">.NET Framework sürüm 4 alternatif olarak, kullandığınız <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> tüm iş parçacıkları tarafından başlatılan bir örnek tabanlı, iş parçacığı yerel değişkeni oluşturmak için tür <xref:System.Action%601> sağladığınız temsilci.</span><span class="sxs-lookup"><span data-stu-id="892f5-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="892f5-236">Aşağıdaki örnekte, tüm iş parçacıkları, erişim `counter` başlangıç değeri 1 görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="892f5-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="892f5-237"><xref:System.Threading.ThreadLocal%601> aynı şekilde çok nesne sarmalar <xref:System.Lazy%601>, temel farklar:</span><span class="sxs-lookup"><span data-stu-id="892f5-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="892f5-238">Her iş parçacığı, diğer iş parçacığı tarafından erişilebilir değil, kendi özel verileri kullanarak iş parçacığı yerel değişkenini ayarlar.</span><span class="sxs-lookup"><span data-stu-id="892f5-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="892f5-239"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> Özelliği okuma-yazma ve bir kez herhangi bir sayıda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="892f5-240">Bu örneğin, bir özel durum yayma etkileyebilir `get` işlemi, bir özel durum yükseltme, ancak bir sonraki başarılı bir şekilde değer başlatabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="892f5-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="892f5-241">Hiçbir başlatma temsilci sağlanırsa <xref:System.Threading.ThreadLocal%601> Sarmalanan türünü türünün varsayılan değerini kullanarak başlatın.</span><span class="sxs-lookup"><span data-stu-id="892f5-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="892f5-242">Bu bağlamda <xref:System.Threading.ThreadLocal%601> tutarlıdır <xref:System.ThreadStaticAttribute> özniteliği.</span><span class="sxs-lookup"><span data-stu-id="892f5-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="892f5-243">Aşağıdaki örnek, her iş parçacığı erişen gösterir `ThreadLocal<int>` örneğini benzersiz kendi veri kopyasını alır.</span><span class="sxs-lookup"><span data-stu-id="892f5-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="892f5-244">Thread-Local değişkenleri Parallel.For ve ForEach</span><span class="sxs-lookup"><span data-stu-id="892f5-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="892f5-245">Kullanırken <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> yöntemi veya <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> yöntemi yinelemek için paralel olarak veri kaynakları üzerinde iş parçacığı-yerel veri için yerleşik desteğe sahip aşırı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="892f5-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="892f5-246">Bu yöntemleri, iş parçacığı-yerel konumu oluşturmanıza, erişmek ve ve verileri temizlemek için yerel temsilciler kullanılarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="892f5-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="892f5-247">Daha fazla bilgi için [nasıl yapılır: İş parçacığı yerel değişkenleriyle bir Parallel.For döngüsü yazma](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) ve [nasıl yapılır: Bölüm yerel değişkenleriyle bir Parallel.ForEach döngüsü yazma](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="892f5-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="892f5-248">Geç Başlatma kullanarak düşük ek yük senaryoları için</span><span class="sxs-lookup"><span data-stu-id="892f5-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="892f5-249">Çok sayıda nesnelerin geç başlatma için sahip olduğu senaryolarda, sarmalama, her bir nesnenin karar verebilirsiniz bir <xref:System.Lazy%601> çok fazla bellek veya çok sayıda bilgi işlem kaynakları gerektirir.</span><span class="sxs-lookup"><span data-stu-id="892f5-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="892f5-250">Veya katı gereksinimlere sahip olabileceğiniz hakkında nasıl yavaş başlatma sunulur.</span><span class="sxs-lookup"><span data-stu-id="892f5-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="892f5-251">Bu gibi durumlarda, kullandığınız `static` (`Shared` Visual Basic'te) yöntemleri <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> yavaş-her bir nesne örneğinde sarmalama olmadan başlatma için sınıf <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="892f5-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="892f5-252">Aşağıdaki örnekte, tüm sarmalama yerine varsayalım. `Orders` bir nesne <xref:System.Lazy%601> geç başlatılan tek sahip nesne `Order` yalnızca gerekli olup olmadığını nesneleri.</span><span class="sxs-lookup"><span data-stu-id="892f5-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="892f5-253">Bu örnekte, başlatma yordamı döngünün her yinelenişinde çağrılan dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="892f5-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="892f5-254">Çok iş parçacıklı senaryolarda başlatma yordamı çağırmak için ilk iş parçacığında değeri tüm iş parçacıkları tarafından görülen bir bileşendir.</span><span class="sxs-lookup"><span data-stu-id="892f5-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="892f5-255">Sonraki iş parçacığı da başlatma yordamı çağırmak, ancak sonuçları kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="892f5-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="892f5-256">Bu tür bir yarış durumu olası kabul edilebilir değilse, aşırı yüklemesini kullanın <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> bir Boole bağımsız değişkeni ve bir eşitleme nesnesi alır.</span><span class="sxs-lookup"><span data-stu-id="892f5-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="892f5-257">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="892f5-257">See also</span></span>

- [<span data-ttu-id="892f5-258">Yönetilen İş Parçacığı Oluşturma Temelleri</span><span class="sxs-lookup"><span data-stu-id="892f5-258">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="892f5-259">İş Parçacıkları ve İş Parçacığı Oluşturma</span><span class="sxs-lookup"><span data-stu-id="892f5-259">Threads and Threading</span></span>](../../../docs/standard/threading/threads-and-threading.md)
- [<span data-ttu-id="892f5-260">Görev Paralel Kitaplığı (TPL)</span><span class="sxs-lookup"><span data-stu-id="892f5-260">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="892f5-261">Nasıl yapılır: Nesnelerin geç başlatılmasını gerçekleştirme</span><span class="sxs-lookup"><span data-stu-id="892f5-261">How to: Perform Lazy Initialization of Objects</span></span>](../../../docs/framework/performance/how-to-perform-lazy-initialization-of-objects.md)

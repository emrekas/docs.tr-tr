---
title: Güvenlik ve Uzaktan Yönetim Konuları
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 46e2e1c327a683782b68069ace2ad6c40bbc856e
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/18/2019
ms.locfileid: "59225293"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="a1d8a-102">Güvenlik ve Uzaktan Yönetim Konuları</span><span class="sxs-lookup"><span data-stu-id="a1d8a-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="a1d8a-103">Uzaktan iletişimini uygulama etki alanları, işlemleri veya bilgisayarlar arasında çağırma saydam ayarlamanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="a1d8a-104">Ancak, kod erişim güvenlik yığın İlerlemesi (aynı işlemde uygulama etki alanları arasında geçerli) işlem veya makine sınırları geçemez.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="a1d8a-105">Uzaktan erişilebilir herhangi bir sınıf (türetilmiş bir <xref:System.MarshalByRefObject> sınıfı) güvenlik sorumluluğunu yapması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="a1d8a-106">Ya da kod kapalı ortamları yalnızca burada çağıran kod örtük olarak güvenilir olabilir veya uzaktan iletişim çağrıları, böylece bunlar korumalı kod kötü amaçla kullanılabilecek dış girişe edilmez tasarlanmalıdır kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="a1d8a-107">Genellikle, hiçbir zaman yöntemleri, özellikleri ve bildirim temelli tarafından korunan olayları açığa [LinkDemand](../../../docs/framework/misc/link-demands.md) ve <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> güvenlik denetimleri.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](../../../docs/framework/misc/link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="a1d8a-108">Uzaktan iletişimi ile bu denetimleri zorunlu değildir.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="a1d8a-109">Diğer güvenlik denetimlerini, gibi <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md)ve benzeri bir işlem içinde uygulama etki alanları arasında çalışır ancak çapraz işlem veya çapraz makine senaryolarda çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="a1d8a-110">Korumalı nesneler</span><span class="sxs-lookup"><span data-stu-id="a1d8a-110">Protected objects</span></span>  
 <span data-ttu-id="a1d8a-111">Bazı nesneler kendilerini güvenlik durumda tutun.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="a1d8a-112">Bu nesneler, ardından kendi izinlerini dışında bir güvenlik yetkilendirmesi sahip olabilir güvenilmeyen koda geçirilmemelidir.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="a1d8a-113">Bir örnek oluşturduğundan bir <xref:System.IO.FileStream> nesne.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="a1d8a-114"><xref:System.Security.Permissions.FileIOPermission> Oluşturma sırasında talep ve başarılı olursa dosya nesne döndürülür.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="a1d8a-115">Ancak, bu nesne başvurusu, kod dosya izinleri olmadan aktarılırsa nesne okumak ve bu belirli bir dosyaya yazmak mümkün olacaktır.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="a1d8a-116">Böyle bir nesne için basit defense aynı talep olmaktır **FileIOPermission** ortak bir API öğesi aracılığıyla nesne başvurusu almak için arayan herhangi bir kod.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="a1d8a-117">Uygulama etki alanı kesişim sorunları</span><span class="sxs-lookup"><span data-stu-id="a1d8a-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="a1d8a-118">Yönetilen barındırma ortamları kodda yalıtmak için çeşitli derlemeler için izin düzeylerini azaltma açık İlkesi ile birden çok alt uygulama etki alanları oluşturmak için yaygındır.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="a1d8a-119">Bununla birlikte, varsayılan uygulama etki alanında bu derlemeler için ilke değişmeden kalır.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="a1d8a-120">Bir alt uygulama etki alanlarının bir derlemeyi yüklemek için varsayılan uygulama etki alanı zorunlu kılabilirsiniz, kod yalıtım etkisini kaybolur ve zorla yüklü bütünleştirilmiş kodundaki türler daha yüksek bir güven düzeyinde kodu çalıştırmak mümkün olacaktır.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="a1d8a-121">Uygulama etki alanı, bir derlemeyi yüklemek ve diğer uygulama etki alanında barındırılan bir nesne için bir proxy çağırarak içlerindeki kodu çalıştırmak için başka bir uygulama etki alanı zorlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="a1d8a-122">Bir uygulama etki alanları arası proxy almak için nesneyi barındırma uygulama etki alanı yöntemi çağrısı parametre veya dönüş değerindeki aracılığıyla dağıtmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="a1d8a-123">Veya, uygulama etki alanı yalnızca oluşturulmuş olsa bile, bir proxy Oluşturucusu olan <xref:System.AppDomain> varsayılan nesne.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="a1d8a-124">Bu nedenle, yalıtım kodu bozmayı önlemek için daha yüksek bir güven düzeyi içeren bir uygulama etki alanı sıralanmış-tarafından-başvuru nesnelere başvurular dağıtmak değil (sınıfından türetilen sınıfların örneklerini <xref:System.MarshalByRefObject>) düşük ile uygulama etki alanlarına etki alanında güven düzeyleri.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="a1d8a-125">Genellikle, varsayılan uygulama etki alanı ile denetim nesnesi içindeki her bir uygulama etki alanları alt oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="a1d8a-126">Denetim nesnesi yeni uygulama etki alanı yönetir ve bazen varsayılan uygulama etki alanından siparişleri alır, ancak bu gerçekten etki alanını doğrudan iletişim kuramaz.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="a1d8a-127">Bazen, varsayılan uygulama etki alanı kendi proxy denetimi nesneye çağırır.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="a1d8a-128">Bununla birlikte, varsayılan uygulama etki alanına geri çağırmaya denetim nesnesi için gerekli olduğu durumlar olabilir.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="a1d8a-129">Bu durumlarda, varsayılan uygulama etki alanı denetim nesnesi oluşturucusuna bir başvuruya göre geri çağırma nesnesi geçirir.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="a1d8a-130">Bu proxy korumak için denetimi nesnesinin sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="a1d8a-131">Denetim nesnesi üzerinde bir genel sınıfın genel statik alan proxy yerleştirmeniz ya da proxy aksi genel olarak kullanıma sunmak için varsa, bu tehlikeli bir varsayılan uygulama etki alanına geri aramayı başka bir kod mekanizma açılacaktır.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="a1d8a-132">Bu nedenle, Denetim nesneler her zaman proxy özel olarak saklamak için örtük olarak güvenilir.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a1d8a-133">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="a1d8a-133">See also</span></span>

- [<span data-ttu-id="a1d8a-134">Güvenli Kodlama Yönergeleri</span><span class="sxs-lookup"><span data-stu-id="a1d8a-134">Secure Coding Guidelines</span></span>](../../../docs/standard/security/secure-coding-guidelines.md)

---
title: Win32 ve WPF Arasında İleti Döngüleri Paylaşma
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: 2de3c2eba534618f6bd6dee0b2c23758f9e15f3f
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/05/2019
ms.locfileid: "57378225"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="238ed-102">Win32 ve WPF Arasında İleti Döngüleri Paylaşma</span><span class="sxs-lookup"><span data-stu-id="238ed-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="238ed-103">Bu konu ile birlikte çalışabilirlik için bir ileti döngüsü uygulanacağını açıklar [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], varolan kullanılarak ileti döngüsü <xref:System.Windows.Threading.Dispatcher> veya üzerinde ayrı bir ileti döngüsü oluşturarak [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] kodunuzun tarafında.</span><span class="sxs-lookup"><span data-stu-id="238ed-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="238ed-104">ComponentDispatcher ve ileti döngüsü</span><span class="sxs-lookup"><span data-stu-id="238ed-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="238ed-105">Birlikte çalışabilirlik ve klavye olay desteği için normal bir senaryo uygulamaktır <xref:System.Windows.Interop.IKeyboardInputSink>, veya alt Sınıflama zaten uygulayan sınıflardan <xref:System.Windows.Interop.IKeyboardInputSink>, gibi <xref:System.Windows.Interop.HwndSource> veya <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="238ed-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="238ed-106">Ancak, tüm olası ileti döngüsü gereksinimleriniz arasında birlikte çalışabilirlik sınırlarınız ileti alma ve gönderme olabilir klavye havuz desteği adres değil.</span><span class="sxs-lookup"><span data-stu-id="238ed-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="238ed-107">Bir uygulama ileti döngüsü mimarisinin resmileştirin yardımcı olmak için [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] sağlar <xref:System.Windows.Interop.ComponentDispatcher> izlemek bir ileti döngüsü için basit bir protokol tanımlayan sınıf.</span><span class="sxs-lookup"><span data-stu-id="238ed-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="238ed-108"><xref:System.Windows.Interop.ComponentDispatcher> bazı üyeleri ortaya koyar statik bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="238ed-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="238ed-109">Her yöntem kapsamını örtük olarak çağıran iş parçacığına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="238ed-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="238ed-110">İleti döngüsü bazıları çağırmalıdır [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] kritik zamanlarda (sonraki bölümde tanımlanmaktadır).</span><span class="sxs-lookup"><span data-stu-id="238ed-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="238ed-111"><xref:System.Windows.Interop.ComponentDispatcher> diğer bileşenleri (örneğin, klavye havuz) dinlemek olayları sağlar.</span><span class="sxs-lookup"><span data-stu-id="238ed-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="238ed-112"><xref:System.Windows.Threading.Dispatcher> Çağrıları tüm uygun sınıf <xref:System.Windows.Interop.ComponentDispatcher> uygun bir dizide yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="238ed-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="238ed-113">Kendi ileti döngüsü uyguluyorsanız, kodunuzu çağırmadan sorumludur <xref:System.Windows.Interop.ComponentDispatcher> benzer bir biçimde yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="238ed-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="238ed-114">Çağırma <xref:System.Windows.Interop.ComponentDispatcher> bir iş parçacığı üzerinde yöntemleri yalnızca o iş parçacığı üzerinde kayıtlı olan olay işleyicilerini çağırma.</span><span class="sxs-lookup"><span data-stu-id="238ed-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="238ed-115">İleti döngüsü yazma</span><span class="sxs-lookup"><span data-stu-id="238ed-115">Writing Message Loops</span></span>  
 <span data-ttu-id="238ed-116">Bir denetim listesi aşağıdadır <xref:System.Windows.Interop.ComponentDispatcher> üyeleri kendi ileti döngüsü yazarsanız kullanırsınız:</span><span class="sxs-lookup"><span data-stu-id="238ed-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <span data-ttu-id="238ed-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: iş parçacığı kalıcı olduğunu belirtmek için bu ileti döngünüz çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="238ed-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <span data-ttu-id="238ed-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: iş parçacığı kalıcı döndürüldü belirtmek için ileti döngüsü çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="238ed-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <span data-ttu-id="238ed-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>:, ileti döngüsü olduğunu belirten çağırmalıdır <xref:System.Windows.Interop.ComponentDispatcher> tetiklemelidir <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> olay.</span><span class="sxs-lookup"><span data-stu-id="238ed-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="238ed-120"><xref:System.Windows.Interop.ComponentDispatcher> oluşturmaz <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> varsa <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> olduğu `true`, ancak ileti döngüleri çağırmayı seçebilir <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> bile <xref:System.Windows.Interop.ComponentDispatcher> kalıcı durumundayken içinde yanıt veremez.</span><span class="sxs-lookup"><span data-stu-id="238ed-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <span data-ttu-id="238ed-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: yeni bir ileti kullanılabilir olduğunu belirtmek için ileti döngüsü çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="238ed-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="238ed-122">Dönüş değeri belirten bir dinleyici için olup olmadığını bir <xref:System.Windows.Interop.ComponentDispatcher> olay işlenen ileti.</span><span class="sxs-lookup"><span data-stu-id="238ed-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="238ed-123">Varsa <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> döndürür `true` (işlenmiş) dağıtıcısı daha fazla ileti ile hiçbir işlem yapmamanız.</span><span class="sxs-lookup"><span data-stu-id="238ed-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="238ed-124">Dönüş değeri ise `false`, dağıtıcı çağırmak için beklenen [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] işlevi `TranslateMessage`, ardından çağırın `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="238ed-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="238ed-125">ComponentDispatcher kullanarak ve var olan ileti işleme</span><span class="sxs-lookup"><span data-stu-id="238ed-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="238ed-126">Bir denetim listesi aşağıdadır <xref:System.Windows.Interop.ComponentDispatcher> üyeleri devralınan güveniyorsanız kullanacağınız [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ileti döngüsü.</span><span class="sxs-lookup"><span data-stu-id="238ed-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <span data-ttu-id="238ed-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: uygulama kalıcı olup olmadığını döndürür (örneğin, kalıcı ileti döngüsü itilmiş).</span><span class="sxs-lookup"><span data-stu-id="238ed-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="238ed-128"><xref:System.Windows.Interop.ComponentDispatcher> sınıf sayısını sürdüren nedeniyle bu durumu izleyebilir <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> ve <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> ileti döngüsünden gelen çağrıları.</span><span class="sxs-lookup"><span data-stu-id="238ed-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <span data-ttu-id="238ed-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> ve <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> olayları temsilci çağrılarını standart kurallarını izler.</span><span class="sxs-lookup"><span data-stu-id="238ed-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="238ed-130">Temsilciler, belirtilmemiş sırayla çağrılır ve ilk iletiyi işlenmiş olarak işaretler bile tüm temsilciler çağrılır.</span><span class="sxs-lookup"><span data-stu-id="238ed-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <span data-ttu-id="238ed-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: boşta işlem için uygun ve etkili bir zamanı belirtir (iş parçacığı için bekleyen diğer ileti vardır).</span><span class="sxs-lookup"><span data-stu-id="238ed-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="238ed-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> iş parçacığı kalıcı ise oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="238ed-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
-   <span data-ttu-id="238ed-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: ileti pompası işler tüm iletiler için oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="238ed-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
-   <span data-ttu-id="238ed-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: sırasında işlenmemiş olan tüm iletiler için yükseltilmiş <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span><span class="sxs-lookup"><span data-stu-id="238ed-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="238ed-135">Bir iletiyi kabul işlenmiş IF <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> olay veya <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> olay `handled` olay verilerini başvuruya göre geçirilen parametre `true`.</span><span class="sxs-lookup"><span data-stu-id="238ed-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="238ed-136">Olay işleyicileri varsa iletisini Yoksay `handled` olduğu `true`, farklı bir işleyici işlenen ileti ilk anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="238ed-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="238ed-137">Her iki olayları için olay işleyicileri, ileti değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="238ed-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="238ed-138">Dağıtıcı değiştirilmiş ileti ve değil değişmeden orijinal mesajın dağıtmalıdır.</span><span class="sxs-lookup"><span data-stu-id="238ed-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="238ed-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> Tüm dinleyici, ancak mimari amaç için teslim yalnızca HWND, hedeflenen iletileri çağırmak iletisine yanıt kodunu içeren üst düzey pencere olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="238ed-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="238ed-140">HwndSource ComponentDispatcher olayları nasıl işler?</span><span class="sxs-lookup"><span data-stu-id="238ed-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="238ed-141">Varsa <xref:System.Windows.Interop.HwndSource> (üst HWND), bir üst düzey pencere ile kaydolacak <xref:System.Windows.Interop.ComponentDispatcher>.</span><span class="sxs-lookup"><span data-stu-id="238ed-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="238ed-142">Varsa <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> oluşturulur, ve eğer ileti için <xref:System.Windows.Interop.HwndSource> veya alt pencereler <xref:System.Windows.Interop.HwndSource> çağrıları kendi <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> klavye havuz dizisi.</span><span class="sxs-lookup"><span data-stu-id="238ed-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="238ed-143">Varsa <xref:System.Windows.Interop.HwndSource> hiçbir işleme olacaktır (sahip bir üst HWND) bir üst düzey pencere değil.</span><span class="sxs-lookup"><span data-stu-id="238ed-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="238ed-144">Yalnızca üst düzey pencere işleme yapmak için beklenen bir durumdur ve yok üst düzey pencere klavye havuz desteği ile birlikte çalışabilirlik her senaryo bir parçası olarak olması beklenir.</span><span class="sxs-lookup"><span data-stu-id="238ed-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="238ed-145">Varsa <xref:System.Windows.Interop.HwndHost.WndProc%2A> üzerinde bir <xref:System.Windows.Interop.HwndSource> çağrılır ilk çağrılan bir uygun klavye havuz yöntemi, uygulamanızın daha yüksek düzey klavye olaylarını gibi alacak <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="238ed-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="238ed-146">Ancak, istenen klavye girişi model özelliklerini erişim anahtarı desteği gibi bozar hiçbir klavye havuzu yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="238ed-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="238ed-147">İleti döngüsünden düzgün ilgili iş parçacığı üzerinde bildirim değil çünkü bu gerçekleşebilir <xref:System.Windows.Interop.ComponentDispatcher>, veya üst HWND uygun klavye havuz yanıtları çağırmadı.</span><span class="sxs-lookup"><span data-stu-id="238ed-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="238ed-148">Kullanarak kancaları eklediyseniz klavye havuzuna giden bir ileti için HWND gönderilmeyebilir <xref:System.Windows.Interop.HwndSource.AddHook%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="238ed-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="238ed-149">İletiyi doğrudan gönderilen ileti pompası düzeyinde işlenen `DispatchMessage` işlevi.</span><span class="sxs-lookup"><span data-stu-id="238ed-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="238ed-150">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="238ed-150">See also</span></span>
- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="238ed-151">WPF ve Win32 Birlikte Çalışması</span><span class="sxs-lookup"><span data-stu-id="238ed-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="238ed-152">İş Parçacığı Modeli</span><span class="sxs-lookup"><span data-stu-id="238ed-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="238ed-153">Girişe Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="238ed-153">Input Overview</span></span>](input-overview.md)

---
title: Bağımlılık Özelliği Geri Aramaları ve Doğrulama
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- dependency properties [WPF], validation
- coerce value callbacks [WPF]
- callbacks [WPF], validation
- dependency properties [WPF], callbacks
- validation of dependency properties [WPF]
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
ms.openlocfilehash: 7f00961ba100700c68936cc33facfdc758c77d3f
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/22/2019
ms.locfileid: "69940818"
---
# <a name="dependency-property-callbacks-and-validation"></a><span data-ttu-id="27f3e-102">Bağımlılık Özelliği Geri Aramaları ve Doğrulama</span><span class="sxs-lookup"><span data-stu-id="27f3e-102">Dependency Property Callbacks and Validation</span></span>
<span data-ttu-id="27f3e-103">Bu konuda, doğrulama belirleme, özelliğin etkin değeri değiştirildiğinde çağrılan geri çağrılar ve geçersiz kılma gibi özelliklerle ilgili özellikler için alternatif özel uygulamalar kullanılarak bağımlılık özelliklerinin nasıl oluşturulacağı açıklanmaktadır. Bunun dışında, değer belirleme üzerindeki etkiler.</span><span class="sxs-lookup"><span data-stu-id="27f3e-103">This topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination.</span></span> <span data-ttu-id="27f3e-104">Bu konuda Ayrıca, bu teknikleri kullanarak varsayılan özellik sistem davranışlarındaki genişlemenin uygun olduğu senaryolar ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-104">This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="27f3e-105">Önkoşullar</span><span class="sxs-lookup"><span data-stu-id="27f3e-105">Prerequisites</span></span>  
 <span data-ttu-id="27f3e-106">Bu konu, bağımlılık özelliği uygulama ve meta verilerin özel bir bağımlılık özelliğine uygulanma şeklini anladığınızı varsayar.</span><span class="sxs-lookup"><span data-stu-id="27f3e-106">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="27f3e-107">Bağlam için bkz. [Özel bağımlılık özellikleri](custom-dependency-properties.md) ve [bağımlılık özelliği meta verileri](dependency-property-metadata.md) .</span><span class="sxs-lookup"><span data-stu-id="27f3e-107">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="Validation_Callbacks"></a>   
## <a name="validation-callbacks"></a><span data-ttu-id="27f3e-108">Doğrulama geri çağırmaları</span><span class="sxs-lookup"><span data-stu-id="27f3e-108">Validation Callbacks</span></span>  
 <span data-ttu-id="27f3e-109">Doğrulama geri çağırmaları, ilk kez kaydettiğinizde bir bağımlılık özelliğine atanabilir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-109">Validation callbacks can be assigned to a dependency property when you first register it.</span></span> <span data-ttu-id="27f3e-110">Doğrulama geri çağırması, özellik meta verilerinin bir parçası değildir; Bu, <xref:System.Windows.DependencyProperty.Register%2A> yönteminin doğrudan bir girişi olur.</span><span class="sxs-lookup"><span data-stu-id="27f3e-110">The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="27f3e-111">Bu nedenle, bir bağımlılık özelliği için bir doğrulama geri çağırması oluşturulduktan sonra, yeni bir uygulama tarafından geçersiz kılınamaz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-111">Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="27f3e-112">Geri çağrılar bir nesne değeri sağlandıklarından uygulanır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-112">The callbacks are implemented such that they are provided an object value.</span></span> <span data-ttu-id="27f3e-113">Bunlar, `true` belirtilen değer özelliği için geçerliyse döndürülür; Aksi takdirde, döndürülür. `false`</span><span class="sxs-lookup"><span data-stu-id="27f3e-113">They return `true` if the provided value is valid for the property; otherwise, they return `false`.</span></span> <span data-ttu-id="27f3e-114">Özelliğin özellik sistemiyle kaydedilen tür için doğru türde olduğu varsayılır, bu nedenle geri çağırmalar içindeki tür denetimi normalde yapılmaz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-114">It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done.</span></span> <span data-ttu-id="27f3e-115">Geri çağrılar, çeşitli farklı işlemlerde özellik sistemi tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-115">The callbacks are used by the property system in a variety of different operations.</span></span> <span data-ttu-id="27f3e-116">Bu, varsayılan değer tarafından başlangıç türü başlatmayı, çağırarak <xref:System.Windows.DependencyObject.SetValue%2A>programlı değişikliği veya belirtilen yeni varsayılan değerle meta verileri geçersiz kılmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-116">This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided.</span></span> <span data-ttu-id="27f3e-117">Doğrulama geri çağırması bu işlemlerden herhangi biri tarafından çağrılırsa ve döndürürse `false`, bir özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="27f3e-117">If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised.</span></span> <span data-ttu-id="27f3e-118">Uygulama yazarları bu özel durumları işleyecek şekilde hazırlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-118">Application writers must be prepared to handle these exceptions.</span></span> <span data-ttu-id="27f3e-119">Doğrulama geri çağırmaların ortak kullanımı, numaralandırma değerlerini doğrulayarak veya özellik sıfır veya daha büyük olması gereken ölçümleri ayarladığında, tamsayıların değerlerini kısıtlayan veya Double değerleri kısıtlayan.</span><span class="sxs-lookup"><span data-stu-id="27f3e-119">A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.</span></span>  
  
 <span data-ttu-id="27f3e-120">Doğrulama geri çağırmaları özellikle, örnek Doğrulayıcıları değil sınıf Doğrulayıcıları olmak üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-120">Validation callbacks specifically are intended to be class validators, not instance validators.</span></span> <span data-ttu-id="27f3e-121">Geri aramanın parametreleri, doğrulanacak özelliklerin ayarlandığı belirli <xref:System.Windows.DependencyObject> bir iletişim kurmaz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-121">The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set.</span></span> <span data-ttu-id="27f3e-122">Bu nedenle, doğrulama geri çağırmaları bir özellik değerini etkileyebilecek olası "bağımlılıkları" zorlama için yararlı değildir, burada bir özelliğin örneğe özgü değeri diğer özelliklerin örneğe özgü değerleri gibi faktörlere bağlı olarak veya çalışma zamanı durumu.</span><span class="sxs-lookup"><span data-stu-id="27f3e-122">Therefore the validation callbacks are not useful for enforcing the possible "dependencies" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.</span></span>  
  
 <span data-ttu-id="27f3e-123">Aşağıda, çok basit bir doğrulama geri çağırma senaryosuna yönelik örnek kod verilmiştir: <xref:System.Double> ilkel olarak yazılan bir özelliğin veya <xref:System.Double.NegativeInfinity>olmadığı <xref:System.Double.PositiveInfinity> doğrulanıyor.</span><span class="sxs-lookup"><span data-stu-id="27f3e-123">The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.</span></span>  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>   
## <a name="coerce-value-callbacks-and-property-changed-events"></a><span data-ttu-id="27f3e-124">Coerce değeri geri çağırmaları ve özellik değişti olayları</span><span class="sxs-lookup"><span data-stu-id="27f3e-124">Coerce Value Callbacks and Property Changed Events</span></span>  
 <span data-ttu-id="27f3e-125">Zorunlu değer geri çağırmaları, bağımlılık özelliğinin <xref:System.Windows.DependencyObject> değeri değiştiğinde özellik sistemi tarafından çağrılan <xref:System.Windows.PropertyChangedCallback> uygulamalar gibi, özellikler için belirli örneği geçirir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-125">Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes.</span></span> <span data-ttu-id="27f3e-126">Bu iki geri çağırmaları birlikte kullanarak, bir özellikte yapılan değişikliklerin başka bir özelliğin zorla veya yeniden değerlemeyi zorlamasının zorlanacağı öğelerde bir dizi özellik oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-126">Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.</span></span>  
  
 <span data-ttu-id="27f3e-127">Bağımlılık özelliklerinin bir bağlantı kullanımı için tipik bir senaryo, en düşük ve en yüksek değer ve gerçek ya da geçerli değer için üçüncü bir özellik olan öğenin her birini bir özellik taşıdığı bir kullanıcı arabirimi temelli özelliğine sahip olduğunuz durumlar olur.</span><span class="sxs-lookup"><span data-stu-id="27f3e-127">A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value.</span></span> <span data-ttu-id="27f3e-128">Burada, en büyük değer, geçerli değerin yeni en yüksek değeri aşması için ayarlandıysa, geçerli değeri yeni en büyük değerinden büyük olmayacak şekilde ve en düşük ile geçerli olan benzer bir ilişkiyi zorlamak isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-128">Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.</span></span>  
  
 <span data-ttu-id="27f3e-129">Aşağıda, bu ilişkiyi gösteren üç bağımlılık özelliklerinden yalnızca biri için çok kısa bir örnek kod verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-129">The following is very brief example code for just one of the three dependency properties that illustrate this relationship.</span></span> <span data-ttu-id="27f3e-130">Örnek, bir en düşük `CurrentReading` /en yüksek/geçerli ilişkili \* okuma özellikleri kümesinin özelliğinin nasıl kaydedildiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-130">The example shows how the `CurrentReading` property of a Min/Max/Current set of related \*Reading properties is registered.</span></span> <span data-ttu-id="27f3e-131">Önceki bölümde gösterildiği gibi doğrulamayı kullanır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-131">It uses the validation as shown in the previous section.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="27f3e-132">Geçerli için geri çağırma özelliği, değişikliği diğer bağımlı özelliklerle iletmek için kullanılır ve bu diğer özellikler için kaydedilen zorunlu değer geri çağırmaları açıkça çağrılır:</span><span class="sxs-lookup"><span data-stu-id="27f3e-132">The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:</span></span>  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 <span data-ttu-id="27f3e-133">Zorunlu değer geri çağırması, geçerli özelliğin potansiyel olarak bağlı olduğu özelliklerin değerlerini denetler ve gerekirse geçerli değeri zorlar:</span><span class="sxs-lookup"><span data-stu-id="27f3e-133">The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:</span></span>  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
> <span data-ttu-id="27f3e-134">Özelliklerin varsayılan değerleri zorlanmaz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-134">Default values of properties are not coerced.</span></span> <span data-ttu-id="27f3e-135">Varsayılan değere eşit bir özellik değeri, bir özellik değeri hala başlangıçtaki varsayılan değeri varsa veya ile <xref:System.Windows.DependencyObject.ClearValue%2A>diğer değerleri temizleyerek meydana gelebilir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-135">A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.</span></span>  
  
 <span data-ttu-id="27f3e-136">Coerce değeri ve özellik değiştirme geri çağırmaları özellik meta verilerinin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-136">The coerce value and property changed callbacks are part of property metadata.</span></span> <span data-ttu-id="27f3e-137">Bu nedenle, belirli bir bağımlılık özelliği için geri çağırmaları, bu özelliğe ait meta verileri geçersiz kılarak, bağımlılık özelliğine sahip olan türden türettiğiniz bir tür üzerinde var olduğu gibi değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-137">Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.</span></span>  
  
<a name="Advanced"></a>   
## <a name="advanced-coercion-and-callback-scenarios"></a><span data-ttu-id="27f3e-138">Gelişmiş zorlama ve geri arama senaryoları</span><span class="sxs-lookup"><span data-stu-id="27f3e-138">Advanced Coercion and Callback Scenarios</span></span>  
  
### <a name="constraints-and-desired-values"></a><span data-ttu-id="27f3e-139">Kısıtlamalar ve Istenen değerler</span><span class="sxs-lookup"><span data-stu-id="27f3e-139">Constraints and Desired Values</span></span>  
 <span data-ttu-id="27f3e-140"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Geri çağrılar, bildirdiğiniz mantığa uygun olarak bir değeri zorlamak için özellik sistemi tarafından kullanılır, ancak yerel olarak ayarlanmış özelliğin bir zorunlu değeri, dahili olarak "istenen değeri" devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-140">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a "desired value" internally.</span></span> <span data-ttu-id="27f3e-141">Kısıtlamalar, uygulama ömrü boyunca dinamik olarak değiştirilebilen diğer özellik değerlerini temel alıyorsa, zorlama kısıtlamaları da dinamik olarak değiştirilir ve kısıtlanmış Özellik değeri, istenen değere yakın şekilde almak için değerini değiştirebilir yeni kısıtlamalar verilme olasılığı vardır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-141">If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints.</span></span> <span data-ttu-id="27f3e-142">Tüm kısıtlamalar yükseltilmemiş ise değer istenen değer olacaktır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-142">The value will become the desired value if all constraints are lifted.</span></span> <span data-ttu-id="27f3e-143">Döngüsel bir şekilde birbirlerine bağımlı birden fazla özellik varsa, oldukça karmaşık bazı bağımlılık senaryolarına neden olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-143">You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner.</span></span> <span data-ttu-id="27f3e-144">Örneğin, Min/Max/Current senaryosunda, en az ve en fazla kullanıcı ayarlanabilir olmasını seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-144">For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable.</span></span> <span data-ttu-id="27f3e-145">Bu durumda, en yüksek değeri en düşük olan ve tam tersi olarak değiştirmeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-145">If so, you might need to coerce that Maximum is always greater than Minimum and vice versa.</span></span> <span data-ttu-id="27f3e-146">Ancak, bu zorlama etkin ise ve en fazla minimum değere zorsa, her ikisine de bağlı olduğundan ve değeri sıfır olan değerler arasındaki aralığa sınırlı olduğundan, geçerli olmayan bir durumda kalır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-146">But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero.</span></span> <span data-ttu-id="27f3e-147">Daha sonra, en yüksek veya en düşük değeri ayarlanıyorsa, geçerli geçerli değeri hala depolandığından ve kısıtlamalar gevşmiş olduğu için istenen değere ulaşmaya çalıştığından, şu değerlerden birini "takip et" olarak görünür.</span><span class="sxs-lookup"><span data-stu-id="27f3e-147">Then, if Maximum or Minimum are adjusted, Current will seem to "follow" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.</span></span>  
  
 <span data-ttu-id="27f3e-148">Karmaşık bağımlılıklarda Teknik olarak yanlış bir şey yoktur, ancak çok sayıda yeniden deneme gerektiren ve kullanıcı ARABIRIMI doğrudan etkiliyorsa kullanıcıları kafa karıştırıcı olabilecek hafif bir performans olabilir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-148">There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly.</span></span> <span data-ttu-id="27f3e-149">Özellik değişikliği ve coerce değeri geri çağırmaları konusunda dikkatli olun ve denenmekte olan zorlamasının mümkün olduğunca kesin olarak değerlendirileceğini ve "aşırı kısıtlama" gerçekleştirmeyeceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="27f3e-149">Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not "overconstrain".</span></span>  
  
### <a name="using-coercevalue-to-cancel-value-changes"></a><span data-ttu-id="27f3e-150">Değer değişikliklerini Iptal etmek için CoerceValue kullanma</span><span class="sxs-lookup"><span data-stu-id="27f3e-150">Using CoerceValue to Cancel Value Changes</span></span>  
 <span data-ttu-id="27f3e-151">Özellik sistemi, değeri <xref:System.Windows.CoerceValueCallback> <xref:System.Windows.DependencyProperty.UnsetValue> özel bir durum olarak döndüren her türlü ele alınacaktır.</span><span class="sxs-lookup"><span data-stu-id="27f3e-151">The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case.</span></span> <span data-ttu-id="27f3e-152">Bu özel durum, <xref:System.Windows.CoerceValueCallback> Çağrılmakta olan özellik değişikliğinin özellik sistemi tarafından reddedilmesi ve özellik sisteminin bunun yerine özelliğin sahip olduğu önceki değeri rapor etmesi gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-152">This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had.</span></span> <span data-ttu-id="27f3e-153">Bu mekanizma, zaman uyumsuz olarak başlatılan bir özellikte yapılan değişikliklerin geçerli nesne durumu için hala geçerli olduğunu denetlemek ve değilse değişiklikleri bastırmak için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-153">This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not.</span></span> <span data-ttu-id="27f3e-154">Başka bir olası senaryo, hangi özellik değeri belirleme bileşeninin raporlanan değerden sorumlu olduğuna bağlı olarak bir değeri seçmeli olarak gizlenebilir.</span><span class="sxs-lookup"><span data-stu-id="27f3e-154">Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported.</span></span> <span data-ttu-id="27f3e-155">Bunu yapmak için, geri çağırma ve özellik <xref:System.Windows.DependencyProperty> tanımlayıcısı ' nı <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>giriş olarak kullanabilir ve sonra öğesini işleyebilirsiniz <xref:System.Windows.ValueSource>.</span><span class="sxs-lookup"><span data-stu-id="27f3e-155">To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="27f3e-156">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="27f3e-156">See also</span></span>

- [<span data-ttu-id="27f3e-157">Bağımlılık Özelliklerine Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="27f3e-157">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="27f3e-158">Bağımlılık Özelliği Meta Verisi</span><span class="sxs-lookup"><span data-stu-id="27f3e-158">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="27f3e-159">Özel Bağımlılık Özellikleri</span><span class="sxs-lookup"><span data-stu-id="27f3e-159">Custom Dependency Properties</span></span>](custom-dependency-properties.md)

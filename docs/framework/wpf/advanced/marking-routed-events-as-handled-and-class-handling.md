---
title: Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 6e3f314de07948e53ffed13ddc1289c1de115edd
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401637"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi
Yönlendirilmiş bir olaya yönelik işleyiciler olay verileri içinde işlenen olayı işaretleyebilir. Olayı işlemek, yolu etkin bir şekilde kısaltacak. Sınıf işleme, yönlendirilmiş olaylar tarafından desteklenen bir programlama kavramıdır. Sınıf işleyicisi, sınıfın herhangi bir örneği üzerinde herhangi bir örnek işleyicisinden önce çağrılan bir işleyiciyle bir sınıf düzeyinde belirli bir yönlendirilmiş olayı işleme fırsatına sahiptir.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Önkoşullar  
 Bu konu, [yönlendirilmiş olaylara genel bakış](routed-events-overview.md)bölümünde tanıtılan kavramlara elaborates.  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Olayları Işlenmiş olarak Işaretleme  
 <xref:System.Windows.RoutedEventArgs.Handled%2A> Özelliğinin değerini, yönlendirilmiş bir olayın olay verilerinde olarak ayarlarsanız, bu, "olayları işlenmiş olarak işaretleme" olarak adlandırılır. `true` Yönlendirilmiş olayları, uygulama yazarı olarak veya var olan yönlendirilmiş olaylara yanıt veren bir denetim yazarı olarak veya yeni yönlendirilmiş olayları uygulayan bir denetim yazarı olarak işaretlemeniz gerektiğinde, için mutlak bir kural yoktur. Çoğu durumda, yönlendirilmiş olayın olay verilerinde gerçekleştirilen "işlenmiş" kavramı, kendi uygulamanızın API 'lerde [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sunulan çeşitli yönlendirilmiş olaylara ve özel yönlendirilmiş olaylara yönelik yanıtları için sınırlı bir protokol olarak kullanılmalıdır. "İşlenmiş" sorunu düşünmenin bir diğer yolu da, kodunuzun yönlendirilmiş olaya önemli ve görece bir şekilde yanıt vermesi durumunda, genellikle yönlendirilmiş bir olayı işaretlememesidir. Genellikle, tek bir yönlendirilmiş olay oluşumu için ayrı işleyici uygulamaları gerektiren birden fazla önemli yanıt olmamalıdır. Daha fazla yanıt gerekiyorsa, gerekli kod, iletmek üzere yönlendirilmiş olay sistemi kullanılarak değil, tek bir işleyici içinde zincirleme olan uygulama mantığı aracılığıyla uygulanmalıdır. "Önemli" ne olduğuna ilişkin kavram da öznel olur ve uygulamanıza veya kodunuza bağlıdır. Genel kılavuz olarak bazı "önemli yanıt" örnekleri şunlardır: odak ayarlama, genel durumu değiştirme, görsel temsili etkileyen özellikleri ayarlama ve diğer yeni olaylar oluşturma. Önemli olmayan yanıt örnekleri şunlardır: özel durumu değiştirme (görsel etki veya programlı gösterim olmadan), olayların günlüğe kaydedilmesi ya da bir olayın bağımsız değişkenlerine bakmak ve yanıt vermeyi tercih etmek.  
  
 Yönlendirilmiş olay sistemi davranışı, bu "önemli yanıt" modelini, ' ın içinde [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] eklendiği veya ortak <xref:System.Windows.UIElement.AddHandler%2A> imzası olayın bulunduğu bir yönlendirilmiş olaya yanıt olarak çağrılmadığı için yönlendirilmiş bir olayın işlenmiş durumunu kullanmak üzere zorlar. veriler zaten işlenmiş olarak işaretlendi. Olay rotasında daha önceki katılımcılar tarafından işlenmiş olarak işaretlenen yönlendirilmiş olayları işlemek için `handledEventsToo` parametre sürümü (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) olan bir işleyici eklemenin ek çabasına gitmeniz gerekir.  
  
 Bazı durumlarda denetimlerin kendilerine belirli yönlendirilmiş olayları işlenmiş olarak işaretlemesi. İşlenmiş bir yönlendirilmiş olay, denetim uygulamasının bir [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] parçası olarak denetim uygulamasının bir parçası olarak önemli veya tamamlanmış olduğunu ve etkinliğin daha fazla işlem yapması gerekmediğini kontrol eden yazarlara yönelik bir kararı temsil eder. Genellikle bu, bir olay için bir sınıf işleyici eklenerek veya bir temel sınıfta bulunan sınıf işleyici sanallaştırmadan birini geçersiz kılarak yapılır. Gerekirse bu olay işlemesini hala çözebilirsiniz; Bu konunun ilerleyen kısımlarında bulunan [Denetim tarafından olay gizleme konusunda çalışma](#WorkingAroundEventSuppressionByControls) konusuna bakın.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Önizleme" (tünel oluşturma) olayları ile Kabarcıklanma olayları ve olay Işleme  
 Yönlendirilmiş olayların önizlemesi, öğe ağacı aracılığıyla bir tünel yolunu izleyen olaylardır. Adlandırma kuralı 'nda ifade edilen "Önizleme", Önizleme (tünel) yönlendirilmiş olaylarının, eşdeğer kabarcıklanma yönlendirilmiş olayından önce ortaya çıkarılan giriş olayları için genel prensibi bir giriştir. Ayrıca, bir tünel oluşturma ve kabarcıklanma çiftinin bulunduğu giriş yönlendirilmiş olaylarının farklı bir işleme mantığı vardır. Tünel oluşturma/önizleme yönlendirilmiş olayı bir olay dinleyicisi tarafından işlenmiş olarak işaretlenmişse, kabarcıklanma yönlendirilmiş olayının herhangi bir dinleyicisi tarafından gönderilmeden önce kabarcıklanma yönlendirilmiş olayı işlenirler. Tünel oluşturma ve kabarcıklanma yönlendirilmiş olayları teknik açıdan ayrı olaylardır, ancak bu davranışı etkinleştirmek için aynı olay verisi örneğini kasıtlı olarak paylaşır.  
  
 Tünel oluşturma ve kabarcıklanma yönlendirilmiş olayları arasındaki bağlantı, belirli bir sınıfın kendi kendine verilen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yönlendirilmiş olaylarını nasıl geliştirdiğine ilişkin iç uygulama tarafından gerçekleştirilir ve bu, eşleştirilmiş giriş yönlendirilmiş olaylarının doğru olarak belirlenir. Ancak, bu sınıf düzeyi uygulama mevcut değilse, tünel olarak yönlendirilen bir olay ve adlandırma şemasını paylaşan bir kabarcıklanma yönlendirilmiş olay arasında bağlantı yoktur: böyle bir uygulama olmadan, iki tamamen ayrı yönlendirilmiş olay olur ve bunlar olmaz sırayla tetiklenir veya olay verilerini paylaşır.  
  
 Özel bir sınıfta tünel/kabarcık girişi yönlendirilmiş olay çiftlerinin nasıl uygulanacağı hakkında daha fazla bilgi için bkz. [özel bir yönlendirilmiş olay oluşturma](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Sınıf Işleyicileri ve örnek Işleyicileri  
 Yönlendirilmiş olaylar, olaya iki farklı tür dinleyici düşünün: sınıf dinleyicileri ve örnek dinleyicileri. Türler belirli <xref:System.Windows.EventManager> bir API 'yi,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, statik oluşturucularını veya bir öğe temel sınıfından bir sınıf işleyici sanal yöntemini geçersiz kıldığından, sınıf dinleyicileri vardır. Örnek dinleyicileri, bir veya daha fazla işleyicinin bu yönlendirilmiş olay için bir çağrısıyla <xref:System.Windows.UIElement.AddHandler%2A>eklendiği özel sınıf örneklerdir/öğelerdir. Mevcut [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yönlendirilmiş olaylar <xref:System.Windows.UIElement.AddHandler%2A> , ortak dil çalışma zamanı ({} clr){} olay sarmalayıcısı 'nin bir parçası olarak, bu olayın basit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mekanizmasıyla aynı zamanda öznitelik sözdizimi aracılığıyla olay işleyicilerini iliştirme etkin. Bu nedenle, basit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] kullanım sonunda bir <xref:System.Windows.UIElement.AddHandler%2A> çağrıya karşılık gelir.  
  
 Görsel ağaç içindeki öğeler, kayıtlı işleyici uygulamaları için denetlenir. İşleyiciler, bu yönlendirilmiş olay için yönlendirme stratejisinin türüne ait olan sırada yol genelinde çağrılabilir. Örneğin, kabarcıklanma yönlendirilmiş olayları ilk olarak, yönlendirilmiş olayı oluşturan öğeye bağlı olan işleyicileri çağırır. Ardından, yönlendirilmiş olay "kabarcıklar" bir sonraki üst öğeye ve bu nedenle uygulama kök öğesine ulaşılana kadar devam eder.  
  
 Bir kabarcıklanma rotasındaki kök öğenin perspektifinden, sınıf işleme veya herhangi bir öğe, olay bağımsız değişkenlerini işlendiği gibi işaretleyen yönlendirilmiş olay çağırma işleyicilerinin kaynağına yakınsa, kök öğelerdeki işleyiciler çağrılmaz ve olay rotası , bu kök öğeye ulaşmadan önce etkin bir şekilde kısaltıldı. Ancak, bir sınıf işleyicisi veya örnek işleyicisi, yönlendirilmiş olayı işlenmiş olarak işaretlese bile, işleyiciler, hala çağrılması gereken özel bir koşullu kullanılarak eklenebildiğinden, yol tamamen durdurulmaz. Bu, daha sonra bu konunun ilerleyen kısımlarında [Olaylar Işlendiklerinde bile oluşturulan örnek Işleyicileri ekleme](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)bölümünde açıklanmaktadır.  
  
 Olay rotasına göre daha derin bir düzeyde, bir sınıfın belirli bir örneğinde çalışan büyük olasılıkla çok sayıda sınıf işleyicisi de vardır. Bunun nedeni, yönlendirilmiş olaylar için sınıf işleme modelinin her bir sınıf hiyerarşisindeki tüm olası sınıfların her bir yönlendirilmiş olay için kendi sınıf işleyicisine kaydolmalarını sağlar. Her sınıf işleyicisi bir iç depoya eklenir ve bir uygulamanın olay yolu oluşturulduğunda, sınıf işleyicilerinin hepsi olay yoluna eklenir. Sınıf işleyicileri rotaya, en çok türetilen sınıf işleyicisinin ilk çağrılmasından ve birbirini izleyen her taban sınıftan sınıf işleyicileri daha sonra çağrılır. Genellikle, sınıf işleyicileri, zaten işlenmiş olarak işaretlenmiş yönlendirilmiş olaylara yanıt vermek üzere kayıtlı değildir. Bu nedenle, bu sınıf işleme mekanizması iki seçenekten birini sunar:  
  
- Türetilmiş sınıflar, türetilmiş sınıf işleyiciden sonra bir zaman çağrıldığı için, yönlendirilmiş olayı ele alınmayan bir işleyici ekleyerek temel sınıftan devralınan sınıf işlemesini tamamlayabilir.  
  
- Türetilmiş sınıflar, işlenen olayı işaretleyen bir sınıf işleyicisi ekleyerek temel sınıftan sınıf işlemesini değiştirebilir. Görsel görünüm, durum mantığı, giriş işleme ve komut işleme gibi alanlarda amaçlanan temel denetim tasarımını değiştirebileceğinden, bu yaklaşım için dikkatli olmanız gerekir.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Denetim taban sınıflarına göre yönlendirilmiş olayların sınıf Işlemesi  
 Bir olay rotasında verilen her öğe düğümünde, sınıf dinleyicileri, öğe üzerindeki herhangi bir örnek dinleyicisine başlamadan önce yönlendirilmiş olaya yanıt verme fırsatına sahiptir. Bu nedenle, sınıf işleyicileri bazen belirli bir denetim sınıfı uygulamasının daha fazla yaymak istemeyen veya sınıfın bir özelliği olan bu yönlendirilmiş olayın özel işlemesini sağlamak için kullanılır. Örneğin, bir sınıf, belirli bir sınıf bağlamında bazı Kullanıcı giriş koşulunun anlamı hakkında daha fazla bilgi içeren kendi sınıfa özgü olayını oluşturabilir. Sınıf uygulama daha sonra, genel yönlendirilmiş olayı işlenmiş olarak işaretleyebilir. Sınıf işleyicileri genellikle paylaşılan olay verilerinin zaten işlenmiş olarak işaretlenmiş olduğu yönlendirilmiş olaylar için çağrılmaması gibi eklenirler, ancak tipik durumlarda, yönlendirilmiş olaylar olduğunda bile çağırmak üzere sınıf işleyicilerini kaydeden <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> bir imza de vardır. işlenmiş olarak işaretlendi.  
  
### <a name="class-handler-virtuals"></a>Sınıf Işleyici Sanallaştırals  
 Bazı öğeler, özellikle gibi <xref:System.Windows.UIElement>temel öğeler, genel yönlendirilmiş olaylar listesine karşılık gelen boş "on * Event" ve "OnPreview\*olayı" sanal yöntemlerini kullanıma sunar. Bu sanal yöntemler, bu yönlendirilmiş olay için bir sınıf işleyicisi uygulamak üzere geçersiz kılınabilir. Temel öğe sınıfları, daha önce açıklandığı gibi kullanarak <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> bu sanal yöntemleri, bu tür yönlendirilmiş olayların sınıf işleyicileri olarak kaydeder. Açık\*olay sanal yöntemleri, her tür için statik oluşturucularda özel başlatma gerektirmeden, ilgili yönlendirilmiş olaylar için sınıf işlemeyi uygulamayı çok daha kolay hale getirir. Örneğin, <xref:System.Windows.UIElement.OnDragEnter%2A> sanal yöntemi geçersiz kılarak türetilmiş herhangi bir <xref:System.Windows.UIElement> sınıftaki <xref:System.Windows.UIElement.DragEnter> olay için sınıf işleme ekleyebilirsiniz. Geçersiz kılma içinde, yönlendirilmiş olayı işleyebilir, diğer olayları oluşturabilir, örneklerde öğe özelliklerini değiştirebilen sınıfa özgü mantık başlatabilir veya bu eylemlerin herhangi bir birleşimini kullanabilirsiniz. İşlenen olayı işaretleseniz bile, genellikle temel uygulamayı bu geçersiz kılmalarla çağırmanız gerekir. Sanal yöntem temel sınıfta olduğundan, temel uygulamayı çağırmak kesinlikle önerilir. Her bir sanal bilgisayardan temel uygulamaları çağırmanın standart korumalı sanal düzeni temelde, bir sınıf hiyerarşisindeki tüm sınıflar için sınıf işleyicilerinin yer aldığı yönlendirilmiş olay sınıfı işlemeye yerel olan benzer bir mekanizmayı değiştirir ve paraleldir. en çok türetilen sınıf ' işleyicisiyle başlayan ve temel sınıf işleyicisine devam eden herhangi bir örnek üzerinde çağırılır. Temel uygulama çağrısını yalnızca sınıfınızın temel sınıf işleme mantığını değiştirmek için bir bilinçli gereksinimi varsa atlayın. Geçersiz kılmadan önce veya sonra temel uygulamayı çağırdığınıza bakılmaksızın uygulamanızın yapısına bağlı olursunuz.  
  
#### <a name="input-event-class-handling"></a>Giriş olayı sınıfı Işleme  
 Sınıf işleyici sanal yöntemlerinin tümü, yalnızca paylaşılan olay verilerinin zaten işlenmiş olarak işaretlenmediği durumlarda çağrılabilir. Ayrıca, giriş olayları için benzersiz olarak, tünel oluşturma ve köpürme sürümleri genellikle sırayla oluşturulur ve olay verilerini paylaşır. Bu, biri tünel oluşturma sürümü ve diğeri kabarcıklanma sürümü olan giriş olaylarının belirli bir çifti için, olayı hemen işlenmiş olarak işaretlemek istemeyebilirsiniz. İşlenen olayı işaretlemek için tünel oluşturma sınıfı işleme sanal yöntemini uygularsanız, bu, kabarcıklanma sınıfı işleyicisinin çağrılmasını engeller (Ayrıca, tüm normal olarak kaydedilmiş örnek işleyicilerini bir tünel veya kabarcıklanma olayı için engelliyor çağrıldığında).  
  
 Düğüm üzerinde sınıf işleme tamamlandıktan sonra, örnek dinleyicileri göz önünde bulundurulmalıdır.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Olaylar Işlendi olarak Işaretlendiğinde bile oluşturulan örnek Işleyicileri ekleme  
 <xref:System.Windows.UIElement.AddHandler%2A> Yöntemi, başka bir işleyici tarafından işaretlemek üzere olay verileri zaten ayarlanmış olsa bile, bir olay, rotadaki işleme öğesine her ulaştığında olay sistemi tarafından çağrılacak işleyicileri eklemenize olanak tanıyan belirli bir aşırı yükleme sağlar işlenen olarak olay. Bu genellikle yapılmaz. Genellikle, işleyiciler, birden fazla son sonuç istendiği halde bir öğe ağacında nerede işlendiğinin ne olursa olsun, bir olay tarafından etkilenmemiş olabilecek uygulama kodu alanlarının tüm bölümlerini ayarlamak için yazılabilir. Ayrıca, genellikle yalnızca bu olaya yanıt vermesi gereken bir öğe vardır ve uygun uygulama mantığı zaten gerçekleşiyordu. `handledEventsToo` Ancak aşırı yükleme, bir öğe ağacı veya denetim birleştirme içindeki başka bir öğenin zaten işlenmiş olarak bir olayı işaretlediği, ancak diğer öğelerin öğe ağacında daha yüksek veya daha düşük (rotaya bağlı olarak) devam ettiği durumlar için kullanılabilir kendi işleyicilerinin çağrılmasını istiyor.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Işlenmiş olayların ne zaman Işlenmemiş olarak Işaretleneceği  
 Genellikle, işlenmiş olarak işaretlenen yönlendirilmiş olaylar, üzerinde<xref:System.Windows.RoutedEventArgs.Handled%2A> `handledEventsToo`işlem gören işleyiciler tarafından bile işlenmemiş olarak işaretlenmemelidir ( `false`geri ayarlanmalıdır). Ancak, bazı giriş olayları, üst düzey olay ağaçta bir konumda ve alt düzey olay başka bir konumda görüldüğünde üst düzey ve alt düzey olay temsillerine sahiptir. Örneğin, bir alt öğenin, bir üst öğe gibi alt düzey bir olayı <xref:System.Windows.UIElement.TextInput> <xref:System.Windows.UIElement.KeyDown>dinlediği gibi üst düzey bir anahtar olayına dinlediği durumu göz önünde bulundurun. Üst öğe alt düzey olayı işlediğinde, daha üst düzey olay, daha yüksek olan alt öğede bile, olayı işlemeye yönelik ilk fırsata sahip olmalıdır.  
  
 Bu durumlarda, alt düzey olay için hem üst öğelere hem de alt öğelere işleyiciler eklemek gerekebilir. Alt öğe işleyicisi uygulama, düşük düzey olayı işlenmiş olarak işaretleyebilir, ancak üst öğe işleyicisi uygulamasının, ağacın (üst düzey olay) daha fazla öğenin yanıt vermesini sağlamak için yeniden işlenmemiş olarak ayarlanması gerekir. Bu durum oldukça nadir olmalıdır.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Denetim birleştirme için giriş olaylarını kasıtlı olarak gizleme  
 Yönlendirilmiş olayların sınıf işlemenin kullanıldığı ana senaryo, giriş olayları ve bileşik denetimler içindir. Ayrıştırılmış denetim, birden çok pratik denetimden veya denetim tabanlı sınıftan oluşan tanımdır. Genellikle denetimin yazarı her bir alt bileşeni tek bir olay kaynağı olarak raporlamak için, her bir alt bileşen tarafından her birinin tetiklenebilir tüm olası giriş olaylarını Amalgamate. Bazı durumlarda, denetim yazarı olayları tamamen ya da daha fazla bilgi içeren bileşen tanımlı bir olayı veya daha belirli bir davranışı ortaya koymak isteyebilir. Herhangi bir bileşen yazarı için hemen görünür olan kurallı örnek, her bir fare [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] olayını, tüm düğmelerin sahip olduğu sezgisel bir olaya en sonunda çözenleri nasıl işleyeni bir <xref:System.Windows.Controls.Button> şekilde <xref:System.Windows.Controls.Primitives.ButtonBase.Click> işler: bir olay.  
  
 <xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.FrameworkElement> Temelsınıf<xref:System.Windows.UIElement> (), <xref:System.Windows.Controls.Control> ve<xref:System.Windows.UIElement>' den türettikten türetilir ve denetim girişi işleme için gereken olay altyapısının büyük bölümü düzeyinde kullanılabilir. <xref:System.Windows.Controls.Button> Özellikle, <xref:System.Windows.UIElement> kendi sınırları içinde <xref:System.Windows.Input.Mouse> fare imleci için isabet sınamasını işleyen genel olayları işler ve gibi en sık kullanılan <xref:System.Windows.UIElement.MouseLeftButtonDown>düğme eylemleri için ayrı olaylar sağlar. <xref:System.Windows.UIElement>Ayrıca, için <xref:System.Windows.UIElement.MouseLeftButtonDown>ön gelir <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> sınıf işleyicisi olarak boş bir sanal sağlar ve <xref:System.Windows.Controls.Primitives.ButtonBase> bunu geçersiz kılar. Benzer şekilde <xref:System.Windows.Controls.Primitives.ButtonBase> , için <xref:System.Windows.UIElement.MouseLeftButtonUp>sınıf işleyicileri kullanır. Olay verilerini geçen geçersiz Kılmalarda, uygulamalar bu <xref:System.Windows.RoutedEventArgs> örneği olarak `true`ayarıyla <xref:System.Windows.RoutedEventArgs.Handled%2A> işlenir ve aynı olay verileri yolun diğer sınıf işleyicilerine geri kalanı boyunca devam eder ve örnek işleyiciler veya olay ayarlayıcıları için de kullanabilirsiniz. Ayrıca, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> geçersiz kılma <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı daha sonra oluşturacak. Çoğu dinleyicinin nihai sonucu, bu olayın doğru bir <xref:System.Windows.UIElement.MouseLeftButtonDown> düğmeden <xref:System.Windows.UIElement.MouseLeftButtonUp> kaynaklandığı ve bazı bir şekilde olmadığı bilindiğinden, <xref:System.Windows.Controls.Primitives.ButtonBase.Click>ve olaylarının "kaybolması" ve yerine değiştirildiği bir olay olur. düğmenin Birleşik parçası veya başka bir öğeden tamamen.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Denetimler tarafından olay gizleme etrafında çalışma  
 Bazen tek denetimler içindeki bu olay gizleme davranışı, uygulamanız için olay işleme mantığının bazı genel amaçları ile karışabilir. Örneğin, uygulamanızın uygulama kök öğesinde bulunan bir işleyiciye sahip olması durumunda, <xref:System.Windows.UIElement.MouseLeftButtonDown> bir düğmeye ait fare tıklamasının kök düzeyinde veya <xref:System.Windows.UIElement.MouseLeftButtonUp> işleyicileri çağırmadığından <xref:System.Windows.UIElement.MouseLeftButtonDown> fark edeceksiniz. Olay aslında balon (olay yolları gerçekten bitmemiştir, ancak yönlendirilmiş olay sistemi, işlenen olarak işaretlendikten sonra kendi işleyici çağırma davranışını değiştirir). Yönlendirilmiş olay düğmeye ulaştığında, <xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı daha fazla anlam ile değiştirmek için kullanıldığından <xref:System.Windows.UIElement.MouseLeftButtonDown> , sınıf işlemesi işlendi olarak işaretlendi. Bu nedenle, yol <xref:System.Windows.UIElement.MouseLeftButtonDown> üzerinde daha fazla standart işleyici çağrılmaz. İşleyicileriniz bu durumda çağrılacağından emin olmak için kullanabileceğiniz iki teknik vardır.  
  
 İlk teknik, `handledEventsToo` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>imzasını kullanarak işleyiciyi kasıtlı olarak eklemektir. Bu yaklaşımın bir sınırlaması, bir olay işleyicisini ekleme tekniğinin yalnızca koddan mümkün olduğu, biçimlendirmeden değil, yalnızca koddan mümkün olduğu bir kısıtlamadır. Olay işleyicisi adını olay özniteliği değeri [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] olarak belirtmenin basit sözdizimi, bu davranışı etkinleştirmez.  
  
 İkinci teknik yalnızca, yönlendirilmiş olayın tünelleme ve kabarcıklanma sürümlerinin eşleştirilmiş olduğu giriş olayları için geçerlidir. Bu yönlendirilmiş olaylar için, bunun yerine önizleme/tünelleme eşdeğeri yönlendirilmiş olaya işleyiciler ekleyebilirsiniz. Bu yönlendirilmiş olay, kökten başlayarak yol üzerinden tünellenir, bu nedenle düğme sınıfı işleme kodu bunu bir üst öğe düzeyinde uygulamanın öğe ağacında iliştirmenizi önlemiş hale gelir. Bu yaklaşımı kullanırsanız, işlenen önizleme olayını işaretleme konusunda dikkatli olun. Kök öğede işlenmekte olan <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> örnek için, olayı işleyici uygulamasında olarak <xref:System.Windows.RoutedEventArgs.Handled%2A> işaretlediyseniz, <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı gerçekten bastırır. Bu genellikle istenen davranış değildir.  
  
## <a name="see-also"></a>Ayrıca bkz.

- <xref:System.Windows.EventManager>
- [Önizleme Olayları](preview-events.md)
- [Özel Yönlendirilmiş Olay Oluşturma](how-to-create-a-custom-routed-event.md)
- [Yönlendirilmiş Olaylara Genel Bakış](routed-events-overview.md)

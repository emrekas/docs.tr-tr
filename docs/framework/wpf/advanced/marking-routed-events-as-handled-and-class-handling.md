---
title: Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 8a21b5e69e8fb3f9781d862bd62b0db92073b1dc
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/18/2019
ms.locfileid: "59172113"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi
Yönlendirilmiş olay işleyicileri içinde olay verilerini işlenen olayı işaretleyebilirsiniz. Olay işleme rotayı verimli kısaltır. Sınıf işleme yönlendirilmiş olaylar tarafından desteklenen programlama bir kavramdır. İşleyicisi sınıfı sınıfın bir örneği üzerinde herhangi bir örnek işleyici önce çağrılan bir işleyici ile bir sınıf düzeyinde belirli gönderilmiş bir olayı işleme fırsatına sahiptir.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Önkoşullar  
 Bu konu başlığı altında tanıtılan kavramları üzerinde elaborates [yönlendirilmiş olaylara genel bakış](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Ne zaman olayları işlenmiş olarak işaretleme  
 Değerini ayarlarsanız <xref:System.Windows.RoutedEventArgs.Handled%2A> özelliğini `true` olay verileri yönlendirilmiş olay için bu denir "işlenen olay işaretleme". Yönlendirilmiş olayları işlenmiş olarak işaretlediğinizde için mutlak kural yoktur, bir uygulama yazarı olarak veya bir denetim olarak var olan yönlendirilmiş olaylara yanıt verir veya yeni uygulayan Yazar yönlendirilmiş olaylar. Çoğunlukla, "yönlendirilmiş olay olay verilerinde taşınan gibi ele" kavramı sınırlı bir protokol olarak içinde kullanıma sunulan çeşitli yönlendirilmiş olaylar, kendi uygulamanızın yanıt için kullanılması gereken [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] ayrıca yönlendirilmiş herhangi bir özel olarak için olaylar. "İşlenen" sorun dikkate alınması gereken başka bir kodunuzu yönlendirilmiş olay için önemli ve görece eksiksiz bir şekilde yanıt, işlenmiş gönderilmiş bir olay genel olarak işaretlemeniz gerekir yoludur. Genellikle, olmamalıdır ayrı işleyicisi uygulamaları için tek yönlendirilmiş olay olayı gerektiren birden fazla önemli yanıt. Daha fazla yanıt gerekirse, gerekli kodu aracılığıyla tek bir işleyici içinde yerine yönlendirilmiş olay sistemi için iletme kullanarak zincirleme uygulama mantığı uygulanmalıdır. "Önemli" nedir kavramı da öznel ve uygulama ya da kod bağlıdır. Genel rehberlik sağlaması "önemli yanıt" buna örnek verilebilir: odak ayarlama, genel durumu değiştirme, görsel temsili etkileyen özellikler ayarı ve diğer yeni olayları oluşturma. Önemli olmayan yanıtlar örnekler: özel durumu (hiçbir görsel veya ile programlı gösterimi) değiştirme, olayların günlüğe kaydedilmesini veya bir olay bağımsız değişkenleri arama ve yanıt almak için değil, kendisine seçme.  
  
 Eklenen işleyiciler için gönderilmiş bir olayı işlenmiş durumunu kullanmak için bu "önemli yanıt" modeli yönlendirilmiş olay sistem davranışı güçlendirir [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] veya ortak imzası <xref:System.Windows.UIElement.AddHandler%2A> yönlendirilmiş bir olaya yanıt olarak çağrılmaz burada olayı verileri önceden işlenmiş olarak işaretlenir. Bir işleyici ekleme fazladan çaba aracılığıyla gitmelidir `handledEventsToo` parametresi sürümü (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) yönlendirme olay önceki katılımcıları tarafından işlenmiş olarak işaretlenmiş yönlendirilmiş olayları işlemek için.  
  
 Bazı durumlarda, kendilerini denetimler belirli yönlendirilmiş olaylar işlenmiş olarak işaretleyin. Bir karar tarafından işlenmiş gönderilmiş bir olayı temsil [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] denetim hiçbir işleme daha fazla denetim uygulaması ve olay parçası gerekiyor gibi önemli veya tam denetim eylemleri yönlendirilmiş olaya yanıt olarak yazar. Genellikle bu olay işleyicisi sınıfı ekleyerek veya mevcut bir taban sınıfa sınıfı işleyici sanalları biri geçersiz kılma tarafından gerçekleştirilir. Gerekirse, işleme Bu olay hala çalışabilirsiniz; bkz: [çalışma geçici olay gizleme denetimleri](#WorkingAroundEventSuppressionByControls) bu konunun devamındaki.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Preview" (tünel) olayları vs. Olaylar ve olay işleme tırmanma  
 Önizleme yönlendirilmiş olaylar öğe ağacında tünel bir rotayı takip olaylardır. Adlandırma kuralı ifade "Preview" (Tünelleme) önizleme yönlendirilmiş olaylar önce eşdeğer tırmanma yönlendirilmiş olay harekete geçirilen giriş olayları için genel ilke göstergesi. Ayrıca, bir tünel ve tırmanma çifti olan giriş yönlendirilmiş olaylar farklı işleme mantığı vardır. Tünel/yönlendirilen Önizleme olay bir olay dinleyicisi tarafından işlenmiş olarak işaretlenmişse, hatta herhangi tırmanma yönlendirilmiş olay dinleyicileri almadan önce ardından yönlendirilmiş olay işaretlenecek tırmanma işlenir. Tünel oluşturma ve tırmanma yönlendirilmiş olaylar için teknik ayrı olayları olsa da, bu davranışı etkinleştirmek için olay verilerini'nın aynı örneğine kasıtlı olarak paylaşırlar.  
  
 Tünel oluşturma ve tırmanma yönlendirilmiş olaylar arasındaki bağlantıyı herhangi nasıl verilen iç uygulaması tarafından gerçekleştirilir [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sınıf kendi bildirilen yönlendirilmiş olaylar oluşturur ve bu giriş eşleştirilmiş yönlendirilmiş olayları geçerlidir. Ancak bu sınıf düzeyi uygulama mevcut değilse, tünel gönderilmiş bir olayı adlandırma şeması paylaşan tırmanma gönderilmiş bir olayı arasındaki bağlantı yoktur: tür uygulaması olmadan bunlar tamamen ayrı iki yönlendirilmiş olaylar olacaktır ve olmaması Olay verileri dizisi veya paylaşımı oluşturulur.  
  
 Özel bir sınıf içinde tünel/Kabarcık giriş yönlendirilmiş olay çifti gerçekleştirme hakkında daha fazla bilgi için bkz. [özel yönlendirilmiş olay oluşturma](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Sınıf işleyicileri ve örnek işleyicileri  
 Yönlendirilmiş olaylar iki farklı türde olay dinleyicileri göz önünde bulundurun: sınıf dinleyicileri ve örnek dinleyiciler. Sınıf dinleyicileri türlerine belirli bir adlı için mevcut <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, kullanıcının statik oluşturucuda veya öğesi ana sınıfı sınıfı işleyici sanal yöntemle silmiş. Örnek dinleyiciler, belirli bir sınıf örnekleri/öğe olduğu bir veya daha fazla işleyicileri gönderilmiş bir olay için bir çağrı tarafından eklenmiş olan <xref:System.Windows.UIElement.AddHandler%2A>. Varolan [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yönlendirilmiş olaylar aramalar yapma <xref:System.Windows.UIElement.AddHandler%2A> parçası olarak [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] olay sarmalayıcı ekleme{} kaldırıp{} uygulamaları nasıl olan etkinliğin basit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mekanizması ekleme olay işleyicileri bir öznitelik söz dizimi aracılığıyla etkinleştirilir. Bu nedenle basit bile [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] kullanım sonuçta karşılık gelmektedir için bir <xref:System.Windows.UIElement.AddHandler%2A> çağırın.  
  
 Görsel ağacı içindeki öğeler için kayıtlı işleyici uygulamaları denetlenir. Yönlendirilmiş olay yönlendirme stratejisini türünde devralınır sırayla yol boyunca, potansiyel olarak işleyicileri çağrılır. Örneğin, tırmanma yönlendirilmiş olaylar ilk yönlendirilmiş olayı başlatan aynı öğeye bağlı olan bu işleyicileri çağırır. Ardından yönlendirilmiş olay uygulama kök öğe ve benzeri ulaşılana kadar sonraki üst öğeye "baloncuklar".  
  
 Sınıf işleme veya herhangi bir öğeye yakın yönlendirilmiş olay kaynağı olarak işlenen, olay bağımsız değişkenleri işaretlemek işleyicilerini çağırma tırmanma yol kök öğesi açısından bakıldığında, ardından öğeleri çağırılmaz kök işleyicileri ve olay yönlendirme Bu kök öğe ulaşmadan önce etkili bir şekilde düşürüldü. İşleyicileri işleyicisi sınıfı veya örneği işleyicisi yönlendirilmiş olay işlenmiş olarak işaretlenmiş olsa bile kullanıcılar hala çağrılmalıdır olduğunu, özel bir koşullu kullanarak eklenebildiği ancak rotası tamamen, durdurulur değil. Bu bölümünde açıklanan [ekleme örneği işleyicileri emin olan yükseltilmiş bile olduğunda olayları işaretli işlenmesini](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), bu konunun devamındaki.  
  
 Olay yolu daha ayrıntılı bir düzeyde de bir sınıfın belirli bir örneğinde çalışan potansiyel olarak birden fazla sınıf işleyicileri vardır. Bu olan yönlendirilmiş olaylar için sınıf işleme modeli, her bir sınıf hiyerarşisindeki tüm olası sınıflar sağladığından kaydedin her yönlendirilmiş olay için kendi sınıf işleyicisi. Bir iç deposuna her sınıf işleyicisi eklenir ve sınıf işleyicileri için uygulama olay yolu oluşturulduğunda, tüm olay yol eklenir. Sınıf işleyicileri, en çok türetilen sınıf önce çağrılır ve her art arda gelen taban sınıfından sınıf işleyicileri sonraki çağrılır yol eklenir. Genel olarak, bunlar da ele, zaten işaretlenmiş yönlendirilmiş olaylara yanıt vermesi, sınıf işleyicileri kayıtlı değil. Bu nedenle, işleme mekanizması bu sınıfı bir iki seçenek sağlar:  
  
-   Türetilmiş sınıflar temel sınıf işleyicisi türetilmiş sınıf işleyici süre sonra çağrılacak çünkü işlenen, yönlendirilmiş olay işaretlemez bir işleyici ekleyerek temel sınıftan devralınan sınıf işleme destekleyebilirsiniz.  
  
-   Türetilen sınıflar, sınıf işaretleyen işlenen yönlendirilmiş olay işleyicisi sınıfı ekleyerek taban sınıfından işleme değiştirebilirsiniz. Hedeflenen temel denetimi Tasarım görünümünü, durumu mantığı, giriş işleme ve komut işleme gibi alanlarda potansiyel olarak değişeceği bu yaklaşımı izleme konusunda dikkatli olmanız gerekir.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Yönlendirilmiş olaylar denetim temel sınıflar tarafından işlenmesini sınıfı  
 Bir olay yönlendirme'her verilen öğe düğümde sınıf dinleyicileri öğesi can herhangi bir örneği Dinleyicide önce yönlendirilmiş olay yanıtlama olanağına sahiptir. Bu nedenle, sınıf işleyicileri bazen daha da yayılmasına izin veya özel bir sınıfın özelliğidir, yönlendirilmiş olay işlenmesini sağlamak için belirli denetim sınıfı uygulaması istemediği yönlendirilmiş olaylar gizlemek için kullanılır. Örneğin, bir sınıf bazı kullanıcı giriş koşulu o sınıfın bağlamında anlamı hakkında daha fazla ayrıntı içeren, kendi sınıf özel olay tetikleyebilir. Sınıf uygulamasının ardından işlenmiş olarak daha fazla genel yönlendirilmiş olay işareti. Sınıf işleyicileri genellikle eklenir yönlendirilmesi için çağrılmaz, etkinliklerin nerede paylaşılan olay verilerini zaten işaretlendi, ancak alışılmadık durumlar için de mevcuttur bir <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> yönlendirilmiş olaylar olduğunda bile çağırmak için sınıf işleyicileri kaydeder imzası işlenmiş olarak işaretlenmiş.  
  
### <a name="class-handler-virtuals"></a>İşleyici sanalları sınıfı  
 Özellikle temel öğeler gibi bazı öğeleri <xref:System.Windows.UIElement>, sunmaya boş "üzerinde * olay" ve "OnPreview\*olay" Genel yönlendirilmiş olaylar listelerine karşılık gelen sanal yöntemler. Bu yönlendirilmiş olayı işleyicisi sınıfı uygulamak için bu sanal yöntemleri geçersiz kılınabilir. Her örneğin kendi sınıf işleyicisi olayını kullanarak yönlendirilmiş olarak temel öğe sınıfları sanal yöntemler bu kaydedin <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> daha önce açıklandığı gibi. Açık\*her türü için özel başlatma statik oluşturucularda gerek kalmadan olayları yönlendirilmiş olay sanal yöntemler olun, sınıf için ilgili işleme uygulamak çok daha kolaydır. Örneğin, sınıf için işleme ekleyebilirsiniz <xref:System.Windows.UIElement.DragEnter> herhangi bir olay <xref:System.Windows.UIElement> türetilmiş sınıf geçersiz kılarak <xref:System.Windows.UIElement.OnDragEnter%2A> sanal yöntem. Geçersiz kılma içinde gönderilmiş bir olayı işleme, diğer olay, örnek veya bu eylemlerin herhangi bir birleşimini öğesi özellikleri değişebilir sınıfı özgü mantığı başlatmak. İşlenen olayı işaretlemek olsa bile bu geçersiz kılmaları temel uygulamada genellikle çağırmanız gerekir. Sanal yöntemin taban sınıfa olduğundan taban uygulamasını çağırma önemle tavsiye edilir. Temel uygulamaları temelde her sanal çağırma standart korumalı sanal desenini değiştirir ve bir sınıf hiyerarşisindeki tüm sınıflar için sınıf işleyicileri aslına sınıfı yönlendirilmiş olay işleme için yerel bir benzer mekanizması parallels en çok türetilen sınıf işleyicisi'ile başlayan ve temel sınıf işleyicisine devam herhangi belirli örneği üzerinde çağrılır. Sınıfınıza işleme mantığı temel sınıfını değiştirmek için bilinçli bir gereksinimi varsa yalnızca temel uygulama çağrı atlarsanız. Yoksa, önce veya sonra geçersiz kılma kodunuzu temel uygulamayı çağırması uygulamanızın niteliğine bağlı olacaktır.  
  
#### <a name="input-event-class-handling"></a>Giriş olayı işleme sınıfı  
 Sınıfı işleyici sanal yöntemler sağlayacak şekilde yalnızca işlenen nerede paylaşılan olay verisi olmayan zaten işaretlenmiş durumda çağrılan tüm kaydedilir. Ayrıca, giriş olayları için benzersiz bir şekilde, tünel oluşturma ve tırmanma sürümleri genellikle sırayla ve olay verileri paylaşın. Bu, burada bir tünel sürümü ve diğer tırmanma sürüm giriş olaylarını sınıf işleyicileri için bir verilen çifti hemen işlenen olayı işaretlemek istemeyebilirsiniz kapsar. Tünel sınıf işlenen olay işaretlemek için sanal bir yöntem işleme uygularsanız, (her iki tünel veya tırmanma olay için herhangi bir normal olarak kayıtlı örnek işleyicileri önleme yanı sıra çağrılmasını tırmanma işleyicisi sınıfı engeller çağrılan).  
  
 Örnek dinleyiciler, sınıf bir düğümde işleme tamamlandıktan sonra kabul edilir.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>İşlenen bile olayları işaretlendiğinde başlatan örneği işleyicileri ekleme  
 <xref:System.Windows.UIElement.AddHandler%2A> Sağlayan bir olay yönlendirme işleme öğesinde eriştiğinde başka bir işleyici zaten, işaretlemek için olay verilerini ayarladı bile olay sistem tarafından çağrılacak işleyicileri eklemenizi sağlayan belirli bir aşırı yükleme yöntemi işlenmiş olarak olay. Bu genellikle yapılmaz. Genel olarak, tüm alanları bile birden çok bitiş sonuçları İstenen öğe ağacında, nerede işlendiğini bağımsız olarak, bir olay tarafından etkisinde uygulama kodu ayarlamak için işleyiciler yazılabilir. Ayrıca, genellikle yoktur, bu olaya yanıt gereken yalnızca bir öğe ve uygun uygulama mantığı oldu. Ancak `handledEventsToo` aşırı yükleme, olağanüstü durumlar burada diğer öğesinde bir öğe ağacı veya denetim birleştirme zaten bir olay işlenen olarak işaretlendi, ancak diğer öğeleri daha yüksek veya düşük öğe ağacında (yol) bağlı olarak hala kullanılabilir çağrılan kendi işleyicileri olmasını istiyor.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Olaylar işlenmemiş olarak işaretlemek ne zaman işlenen  
 Genellikle, işlenmiş olarak işaretlenmiş yönlendirilmiş olaylar işlenmemiş işaretli olmamalıdır (<xref:System.Windows.RoutedEventArgs.Handled%2A> döndürülmek `false`) bile üzerinde hareket işleyicileri tarafından `handledEventsToo`. Ancak, bazı giriş olayları, üst düzey olay konumunda bir ağaç ve başka bir konumda alt düzey olay ortaya çıktığında, binebilir üst düzey ve alt düzey olay temsilleri olabilir. Örneğin, burada bir alt öğesi dinleyen bir üst düzey anahtar olayına gibi bir durum düşünün <xref:System.Windows.UIElement.TextInput> bir üst öğe gibi alt düzey bir olayı dinleyen sırada <xref:System.Windows.UIElement.KeyDown>. Üst öğenin alt düzey olayı işleyen, üst düzey olay olayı işlemek için ilk fırsattır sezgisel sahip olması da alt öğede gizlenebilir.  
  
 Bu durumda hem üst öğeler ve alt öğeleri için alt düzey olay işleyicileri eklemek gerekli olabilir. Alt öğesi işleyici uygulama alt düzey olay, üst öğesi işleyici uygulama yanıt fırsatı ayarlama böylece daha fazla öğe ağacında (yanı sıra üst düzey olay) yukarı yeniden işlenmemiş olabilir işlenmiş olarak işaretleyebilirsiniz. Bu durumda oldukça nadir olmalıdır.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Denetim birleştirme için kasıtlı olarak gizleme giriş olayları  
 Yönlendirilmiş olay için sınıf işleme kullanıldığı ana senaryo giriş olayları ve bileşik denetimler içindir. Birden çok pratik denetimleri veya denetim temel sınıfları oluşan tanımına göre bir bileşik denetimdir. Denetimin Yazar genellikle tüm olası giriş olaylarını katıştırma isteyen her bileşenleri, tüm denetim tekil olay kaynağı olarak bildirmek üzere oluşturabileceğini. Bazı durumlarda olayların bileşenleri tamamen gizlemek ya da daha fazla bilgi taşır ya da daha belirli bir davranış gösterir ve bileşen tarafından tanımlanan bir olay yerine denetim yazarı isteyebilir. Bileşen yazarlardan hemen görünür olan kurallı örnek nasıl bir [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> tüm düğmeler olduğunu sezgisel olaya sonunda çözülecektir herhangi bir fare olay işleme: bir <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay.  
  
 <xref:System.Windows.Controls.Button> Temel sınıfı (<xref:System.Windows.Controls.Primitives.ButtonBase>) öğesinden türetilen <xref:System.Windows.Controls.Control> hangi sırayla türetilir <xref:System.Windows.FrameworkElement> ve <xref:System.Windows.UIElement>ve denetim giriş işleme kullanılabilir gereken olay altyapıyı çoğunu <xref:System.Windows.UIElement> düzeyi. Özellikle, <xref:System.Windows.UIElement> genel işler <xref:System.Windows.Input.Mouse> sınırlarının içinde fare imlecini isabet sınaması işlemek ve farklı olayların en yaygın sağlayan olaylar düğme eylemleri gibi <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement> Ayrıca, boş bir sanal sağlar <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> için önceden kaydettiğiniz sınıfı işleyici olarak <xref:System.Windows.UIElement.MouseLeftButtonDown>, ve <xref:System.Windows.Controls.Primitives.ButtonBase> onu geçersiz kılar. Benzer şekilde, <xref:System.Windows.Controls.Primitives.ButtonBase> kullanan sınıf işleyicileri <xref:System.Windows.UIElement.MouseLeftButtonUp>. Uygulamaları geçirilen olay verileri, geçersiz kılmalarda işaretlemek <xref:System.Windows.RoutedEventArgs> örnek olarak ayarlanmasıyla <xref:System.Windows.RoutedEventArgs.Handled%2A> için `true`, ve aynı olay verileri ne diğer sınıf işleyicileri yol geri kalanı boyunca devam eder ve Ayrıca örnek işleyicileri veya olay ayarlayıcılar için. Ayrıca, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> geçersiz kılma sonraki yükseltmek <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay. Çoğu dinleyiciler için sonuç olacak <xref:System.Windows.UIElement.MouseLeftButtonDown> ve <xref:System.Windows.UIElement.MouseLeftButtonUp> olayları "yok" ve bunun yerine değiştirilir <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, bunu bu olay kaynaklı olduğunu doğru bir düğme ve olmayan bazı biliniyor olduğundan daha fazla anlamı tutan bir olay Bileşik parçası düğmesinin veya başka bir öğeden tamamen.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Denetimleri gizleme olay etrafında çalışma  
 Bazen bu olay gizleme davranışını tek denetimleri içinde olay işleme mantığı uygulamanız için bazı genel amaçları ile engelleyebilir. Örneğin, herhangi bir nedenden dolayı uygulamanız için bir işleyici sahip <xref:System.Windows.UIElement.MouseLeftButtonDown> uygulama kök öğe bulunan, size herhangi bir düğme fare tıklatın değil çağıracaktır fark etmesi <xref:System.Windows.UIElement.MouseLeftButtonDown> veya <xref:System.Windows.UIElement.MouseLeftButtonUp> kök düzeyinde işleyicileri. Olay gerçekten yukarı Kabarcık (yeniden olay yollar gerçek anlamda Sonlandırılmamış ancak işlenmiş işaretlenmiş sonra yönlendirilmiş olay sistemi işleyicisi çağırma davranışları değiştirir). Yönlendirilmiş olay düğmesi erişildiğinde <xref:System.Windows.Controls.Primitives.ButtonBase> sınıfı işleme işaretlenmiş <xref:System.Windows.UIElement.MouseLeftButtonDown> yerine onlardan çünkü işlenen <xref:System.Windows.Controls.Primitives.ButtonBase.Click> daha anlamlı bir olayla. Bu nedenle, herhangi bir standart <xref:System.Windows.UIElement.MouseLeftButtonDown> yol daha fazla işleyicisini değil çağrılabilir. Bu durumda İşleyicileriniz çağrıldığı emin olmak için kullanabileceğiniz iki teknik vardır.  
  
 Kasıtlı olarak kullanarak işleyici eklemek için ilk tekniktir `handledEventsToo` imzası <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Bu yaklaşımın bir sınırlama bir olay işleyicisi eklemek için bu teknik yalnızca kod biçimlendirme yerine, mümkün olmasıdır. Olay işleyicisi adı ile bir olay öznitelik değeri olarak belirtme basit söz dizimi [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] bu davranışı etkinleştirmez.  
  
 İkinci yöntem yalnızca giriş olayları yönlendirilmiş olay tünel ve tırmanma sürümlerini nereden eşleştirilmiş durumda çalışır. Bu yönlendirilmiş olaylar için bunun yerine Önizleme/tünel eşdeğer işleyicileri yönlendirilmiş olay ekleyebilirsiniz. Bu yönlendirilmiş olayı işleme kodunu button sınıfı, uygulamanın öğe ağacında bazı üst öğe düzeyinde işleyicisinin bağlı pek fazla ıntercept değil şekilde kökünden başlayarak rota üzerinden tünel. Bu yaklaşımı kullanın, işlenen herhangi bir Önizleme olay işaretleme hakkında dikkatli olun. İle verilen örneğin <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> olay olarak işaretliyse, kök öğe işlenen <xref:System.Windows.RoutedEventArgs.Handled%2A> gerçekten bastırır işleyici uygulamasında <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay. Bu genellikle istenen davranışı değil.  
  
## <a name="see-also"></a>Ayrıca bkz.

- <xref:System.Windows.EventManager>
- [Önizleme Olayları](preview-events.md)
- [Özel Yönlendirilmiş Olay Oluşturma](how-to-create-a-custom-routed-event.md)
- [Yönlendirilmiş Olaylara Genel Bakış](routed-events-overview.md)

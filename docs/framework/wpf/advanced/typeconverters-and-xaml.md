---
title: TypeConverters ve XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: ec6eaadae1dd7a7db84538c24e396a14db1a65a4
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/18/2019
ms.locfileid: "59164997"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="6e973-102">TypeConverters ve XAML</span><span class="sxs-lookup"><span data-stu-id="6e973-102">TypeConverters and XAML</span></span>
<span data-ttu-id="6e973-103">Bu konu, genel XAML dil özelliği olarak dizeden tür dönüştürme amacı tanıtır.</span><span class="sxs-lookup"><span data-stu-id="6e973-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="6e973-104">.NET Framework'teki <xref:System.ComponentModel.TypeConverter> sınıfı XAML öznitelik kullanımı bir özellik değeri olarak kullanılabilecek özel bir yönetilen sınıf uygulamasını bir parçası olarak belirli bir amaca hizmet.</span><span class="sxs-lookup"><span data-stu-id="6e973-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="6e973-105">Özel bir sınıf yazma ve XAML ayarlanabilir öznitelik değeri olarak kullanılabilmesi için bir sınıfın örneklerini istiyorsanız uygulamak ihtiyacınız olabilecek bir <xref:System.ComponentModel.TypeConverterAttribute> sınıfınıza, özel bir yazma <xref:System.ComponentModel.TypeConverter> sınıfı veya her ikisini de.</span><span class="sxs-lookup"><span data-stu-id="6e973-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="6e973-106">Tür dönüştürme kavramları</span><span class="sxs-lookup"><span data-stu-id="6e973-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="6e973-107">XAML ve dize değerleri</span><span class="sxs-lookup"><span data-stu-id="6e973-107">XAML and String Values</span></span>  
 <span data-ttu-id="6e973-108">Bir XAML dosyasında bir öznitelik değeri ayarladığınızda, ilk değeri bir dize içinde salt metin türüdür.</span><span class="sxs-lookup"><span data-stu-id="6e973-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="6e973-109">Hatta diğer ilkel gibi <xref:System.Double> başlangıçta metin dizelerdir XAML işlemci için.</span><span class="sxs-lookup"><span data-stu-id="6e973-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="6e973-110">XAML işlemci bir öznitelik değeri işlemek için iki parça bilgi gerekir.</span><span class="sxs-lookup"><span data-stu-id="6e973-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="6e973-111">Bilgi ilk parçasını ayarlanan özelliğin bir değer türüdür.</span><span class="sxs-lookup"><span data-stu-id="6e973-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="6e973-112">XAML içinde işlenir ve bir öznitelik değeri tanımlayan herhangi bir dize olmalıdır sonuçta dönüştürülecek veya o türün değerine çözümlendi.</span><span class="sxs-lookup"><span data-stu-id="6e973-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="6e973-113">Değer (örneğin, sayısal bir değer) XAML ayrıştırıcı tarafından anlaşılan basit bir tür ise, dize doğrudan dönüştürme denenir.</span><span class="sxs-lookup"><span data-stu-id="6e973-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="6e973-114">Bir sabit listesi değeri ise, dize, numaralandırma, adlandırılmış bir sabit bir adı eşleşme olup olmadığını denetlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6e973-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="6e973-115">Değer ne ayrıştırıcı anlaşılan bir temel ya da bir numaralandırma sonra söz konusu türü ise sağlayabilir veya bir dönüştürülmüş dizesine dayalı bir değer türü örneği olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6e973-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="6e973-116">Bu, bir tür dönüştürücüsü sınıfı belirterek gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="6e973-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="6e973-117">Tür dönüştürücüsünü etkili bir şekilde kod içinde .NET kodda çağırır XAML senaryosu için hem de başka bir sınıf değerlerini sağlamak için bir yardımcı sınıftır.</span><span class="sxs-lookup"><span data-stu-id="6e973-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="6e973-118">XAML içinde mevcut türü dönüştürme davranışını kullanarak</span><span class="sxs-lookup"><span data-stu-id="6e973-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="6e973-119">Temel XAML kavramları, aşinalık bağlı olarak, zaten türü dönüştürme davranışını temel uygulama XAML fark etmeden kullanıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="6e973-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="6e973-120">Örneğin, WPF türünde bir değer alan özellikleri yüzlerce tanımlar <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="6e973-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="6e973-121">A <xref:System.Windows.Point> iki boyutlu bir koordinat alanında bir koordinat açıklayan bir değerdir ve aslında iki önemli özellikleri vardır: <xref:System.Windows.Point.X%2A> ve <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e973-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="6e973-122">XAML içinde bir noktaya belirttiğinizde, (genellikle bir virgül) sınırlayıcı bir dize olarak arasında belirtmeden <xref:System.Windows.Point.X%2A> ve <xref:System.Windows.Point.Y%2A> sağladığınız değerler.</span><span class="sxs-lookup"><span data-stu-id="6e973-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="6e973-123">Örneğin: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`</span><span class="sxs-lookup"><span data-stu-id="6e973-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="6e973-124">Bu basit tür bile <xref:System.Windows.Point> ve basit kullanımını XAML içinde bir tür dönüştürücüsü içerir.</span><span class="sxs-lookup"><span data-stu-id="6e973-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="6e973-125">Bu durumda, sınıf, <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="6e973-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="6e973-126">Tür dönüştürücü <xref:System.Windows.Point> Süren tüm özellikleri biçimlendirme kullanımları sınıf düzeyinde ölçeklendirerek tanımlanan <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="6e973-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="6e973-127">Bir tür dönüştürücüsü Burada, aşağıdakiler gerekir. daha önce gösterilen aynı örneği için çok daha ayrıntılı biçimlendirmesini:</span><span class="sxs-lookup"><span data-stu-id="6e973-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="6e973-128">Tür dönüştürme dize veya daha ayrıntılı bir eşdeğer sözdizimi kullanmak için genellikle bir kodlama stili bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="6e973-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="6e973-129">XAML araçları akışınız, değerlerin nasıl ayarlanacağı da etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="6e973-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="6e973-130">Bazı XAML araçları gidiş dönüş Tasarımcı görünümleri ya da kendi seri hale getirme mekanizması için daha kolay olduğundan, en ayrıntılı form biçimlendirme yayma eğilimindedir.</span><span class="sxs-lookup"><span data-stu-id="6e973-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="6e973-131">Var olan tür dönüştürücüleri genellikle bulunması WPF ve .NET Framework türleri üzerinde bir sınıf (ya da özellik) uygulanan bir varlığını denetleyerek <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="6e973-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="6e973-132">Bu öznitelik, XAML amacıyla hem de büyük olasılıkla diğer amaçlar için bu türü değerlerinin destekleyen tür dönüştürücüsünü sınıfı adını vereceğiz.</span><span class="sxs-lookup"><span data-stu-id="6e973-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="6e973-133">Tür dönüştürücüleri ve İşaretleme uzantıları</span><span class="sxs-lookup"><span data-stu-id="6e973-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="6e973-134">İşaretleme uzantıları ve tür dönüştürücüleri XAML işlemci davranışı ve uygulanacak olan senaryoları açısından dikgen rolleri doldurun.</span><span class="sxs-lookup"><span data-stu-id="6e973-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="6e973-135">Bağlam için işaretleme uzantısı kullanımları kullanılabilir olsa da, burada bir değerdir genellikle bir işaretleme uzantısı sağlar. özellikleri türü dönüştürme davranışını işaretleme uzantısı uygulamalarında işaretlenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="6e973-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="6e973-136">Diğer bir deyişle, bile bir işaretleme uzantısı bir metin dizesi olarak döndürür, `ProvideValue` çıkışı, belirli özellik ya da özellik değeri türü uygulanan olarak bu dize türü dönüştürme davranışını değil çağrılır, genellikle, bir işaretleme uzantısı amacı işlemidir bir dize ve ilgili herhangi bir tür dönüştürücüsü olmadan bir nesne döndürür.</span><span class="sxs-lookup"><span data-stu-id="6e973-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="6e973-137">İşaretleme uzantısı yerine bir tür dönüştürücüsü gerekli olduğu bir yaygın durum zaten var. bir nesneye bir başvuru sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="6e973-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="6e973-138">En iyi durum bilgisi olmayan bir tür dönüştürücüsü yalnızca istenen olmayabilir yeni bir örneği oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="6e973-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="6e973-139">Biçimlendirme uzantıları hakkında daha fazla bilgi için bkz. [biçimlendirme uzantıları ve WPF XAML](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="6e973-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="6e973-140">Yerel tür dönüştürücüleri</span><span class="sxs-lookup"><span data-stu-id="6e973-140">Native Type Converters</span></span>  
 <span data-ttu-id="6e973-141">WPF ve .NET Framework uygulamasında XAML ayrıştırıcı, henüz genel temel olarak zorlayıcı olabilir türleri değil, yerel bir tür dönüştürme işleme sahip bazı türleri vardır.</span><span class="sxs-lookup"><span data-stu-id="6e973-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="6e973-142">Böyle bir türü örneğidir <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="6e973-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="6e973-143">Bunun nedeni, .NET Framework mimarisini nasıl çalıştığını temel alır: türü <xref:System.DateTime> mscorlib, .NET en temel kitaplığında tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="6e973-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="6e973-144"><xref:System.DateTime> bir bağımlılık tanıtan başka bir bütünleştirilmiş koddan gelen bir öznitelik ile öznitelikli izin verilmiyor (<xref:System.ComponentModel.TypeConverterAttribute> sisteminden alınmıştır) normal türü dönüştürücü bulma mekanizmasından'öznitelik atanıyor tarafından desteklenebilmesi için.</span><span class="sxs-lookup"><span data-stu-id="6e973-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="6e973-145">Bunun yerine, XAML ayrıştırıcı gibi yerel işlenmesi gereken türlerinin bir listesi vardır ve bunlar true temelleri nasıl işlendiği için benzer şekilde işler.</span><span class="sxs-lookup"><span data-stu-id="6e973-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="6e973-146">(Durumunda <xref:System.DateTime> bu bir çağrı içerir <xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="6e973-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="6e973-147">Tür dönüştürücü uygulama</span><span class="sxs-lookup"><span data-stu-id="6e973-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="6e973-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="6e973-148">TypeConverter</span></span>  
 <span data-ttu-id="6e973-149">İçinde <xref:System.Windows.Point> sınıfı daha önce verilen örnek <xref:System.Windows.PointConverter> bahsedilen.</span><span class="sxs-lookup"><span data-stu-id="6e973-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="6e973-150">XAML .NET uygulamaları için XAML amaçlarıyla kullanılan tüm tür dönüştürücüleri temel sınıfından türetilir sınıflardır <xref:System.ComponentModel.TypeConverter>.</span><span class="sxs-lookup"><span data-stu-id="6e973-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="6e973-151"><xref:System.ComponentModel.TypeConverter> Sınıfı XAML varlığını önünde .NET Framework sürümleri içinde vardı; kendi özgün kullanımlarından dize dönüştürme için görsel tasarımcılar özelliği iletişim kutularında sağlamak için.</span><span class="sxs-lookup"><span data-stu-id="6e973-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="6e973-152">XAML, rolü için <xref:System.ComponentModel.TypeConverter> öznitelik dize ayrıştırma ve büyük olasılıkla bir dize halinde geri belirli nesne özelliği çalışma zamanı değerini işleme-dize ve dize öğesinden dönüştürme için temel sınıfı olan içerecek şekilde genişletilmiş özniteliği olarak seri hale getirme.</span><span class="sxs-lookup"><span data-stu-id="6e973-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="6e973-153"><xref:System.ComponentModel.TypeConverter> ve dizeleri XAML işleme amacıyla bu nesnelerden dönüştürme için uygun olan dört üyeleri tanımlar:</span><span class="sxs-lookup"><span data-stu-id="6e973-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="6e973-154">Bu en önemli yöntemdir <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e973-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="6e973-155">Bu yöntem, Giriş dizesinin gerekli nesne türüne dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="6e973-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="6e973-156">NET olarak söylemek gerekirse, <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> yönteminin çok geniş bir tür Dönüştürücüsü'nın hedeflenen hedef türüne dönüştürün ve bu nedenle çalışma zamanı dönüştürmeleri destekleyen gibi ancak XAML amacıyla XAML genişletmek amacıyla hizmet uygulanmasını işleyebilen kod yolu olan bir <xref:System.String> önemli giriş.</span><span class="sxs-lookup"><span data-stu-id="6e973-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="6e973-157">Sonraki en önemli yöntemdir <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e973-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="6e973-158">(Örneğin, XAML dosyası olarak kaydedilir) bir uygulama için bir biçimlendirme gösterimi dönüştürülür varsa, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> biçimlendirme gösterimi üretmek için sorumludur.</span><span class="sxs-lookup"><span data-stu-id="6e973-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="6e973-159">XAML için önemli kod yolu geçirdiğinizde bu durumda olduğu bir `destinationType` , <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="6e973-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="6e973-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> ve <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> yeteneklerini hizmet sorgu oluştururken kullanılan destek yöntemleri <xref:System.ComponentModel.TypeConverter> uygulaması.</span><span class="sxs-lookup"><span data-stu-id="6e973-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="6e973-161">Döndürmek için bu yöntemleri uygulamalıdır `true` , türe özgü durumda, dönüştürücü eşdeğer dönüştürme yöntemleri destekler.</span><span class="sxs-lookup"><span data-stu-id="6e973-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="6e973-162">XAML amacıyla, bu genellikle anlamına gelir <xref:System.String> türü.</span><span class="sxs-lookup"><span data-stu-id="6e973-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="6e973-163">Kültür bilgilerini ve XAML için tür dönüştürücüleri</span><span class="sxs-lookup"><span data-stu-id="6e973-163">Culture Information and Type Converters for XAML</span></span>  
 <span data-ttu-id="6e973-164">Her <xref:System.ComponentModel.TypeConverter> uygulama bir dönüştürme için geçerli bir dize nelerden kendi yorumlama sahip ve ayrıca kullanın veya parametre olarak geçirilen türü açıklaması yoksay.</span><span class="sxs-lookup"><span data-stu-id="6e973-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="6e973-165">Kültür ve XAML tür dönüştürme ile ilgili önemli bir husus vardır.</span><span class="sxs-lookup"><span data-stu-id="6e973-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="6e973-166">Yerelleştirilebilir Dize öznitelik değerleri kullanılarak, tamamen XAML tarafından desteklenir.</span><span class="sxs-lookup"><span data-stu-id="6e973-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="6e973-167">Ancak, belirli bir kültürün gereksinimleri ile dönüştürücü giriş türü desteklenmediğinden bu yerelleştirilebilir dize kullanarak XAML öznitelik değerleri için tür dönüştürücüleri mutlaka sabit dil ayrıştırma davranışı hatalarıyla ilgili olduğundan, kullanarak `en-US` kültür.</span><span class="sxs-lookup"><span data-stu-id="6e973-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="6e973-168">Bu kısıtlama tasarım nedenleri hakkında daha fazla bilgi için XAML dil belirtimi danışmalıdır ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525)).</span><span class="sxs-lookup"><span data-stu-id="6e973-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525)).</span></span>  
  
 <span data-ttu-id="6e973-169">Burada kültür bir sorun olabilir örneğin, bazı kültürlerde sayılar için ondalık ayırıcı olarak virgül kullanın.</span><span class="sxs-lookup"><span data-stu-id="6e973-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="6e973-170">Bu, ayırıcı olarak virgül WPF XAML tür dönüştürücüleri çoğunu içeren davranış birbiriyle çakışır (Geçmiş Etkileyenler gibi ortak X bağlı olarak, Y form veya virgülle ayrılmış listeleri).</span><span class="sxs-lookup"><span data-stu-id="6e973-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="6e973-171">Bir kültür çevreleyen XAML içinde bile geçirme (ayar `Language` veya `xml:lang` için `sl-SI` kültür, virgül, ondalık bu şekilde kullanımları bir kültür örneği) sorunu çözmez.</span><span class="sxs-lookup"><span data-stu-id="6e973-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="6e973-172">ConvertFrom uygulama</span><span class="sxs-lookup"><span data-stu-id="6e973-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="6e973-173">Olarak kullanılabilir bir <xref:System.ComponentModel.TypeConverter> XAML, destekleyen bir uygulama <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> yöntemi Bu dönüştürücü için bir dize olarak kabul etmelisiniz `value` parametresi.</span><span class="sxs-lookup"><span data-stu-id="6e973-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="6e973-174">Dize geçerli biçimlendirmek ve tarafından dönüştürülebilir olup olmadığını <xref:System.ComponentModel.TypeConverter> uygulama sonra döndürülen nesne bir özellik tarafından beklenen türe dönüştürme desteklemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="6e973-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="6e973-175">Aksi takdirde, <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> uygulama döndürmelidir `null`.</span><span class="sxs-lookup"><span data-stu-id="6e973-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="6e973-176">Her <xref:System.ComponentModel.TypeConverter> uygulama bir dönüştürme için geçerli bir dize nelerden kendi yorumlama sahip ve ayrıca kullanın veya parametre olarak geçirilen tür açıklaması veya kültür bağlamı yoksay.</span><span class="sxs-lookup"><span data-stu-id="6e973-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="6e973-177">Ancak, işleme WPF XAML değerleri türü açıklaması içeriği tüm durumlarda geçebilir değil ve kültüre göre de geçirmemesi `xml:lang`.</span><span class="sxs-lookup"><span data-stu-id="6e973-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6e973-178">Küme ayracı karakterleri özellikle kullanmayın {, dize biçiminiz olası öğesi olarak.</span><span class="sxs-lookup"><span data-stu-id="6e973-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="6e973-179">Bu karakterler, giriş ve çıkış bir işaretleme uzantısı sırası olarak ayrılmıştır.</span><span class="sxs-lookup"><span data-stu-id="6e973-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="6e973-180">ConvertTo uygulama</span><span class="sxs-lookup"><span data-stu-id="6e973-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="6e973-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> Potansiyel olarak seri hale getirme desteği için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6e973-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="6e973-182">Serileştirme desteğini <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> özel türünüzü ve kendi türü için dönüştürücü mutlak bir gereksinim değildir.</span><span class="sxs-lookup"><span data-stu-id="6e973-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="6e973-183">Ancak, bir denetimi uygulamak veya tasarım sınıfınızın veya özellikleri bir parçası serileştirilmesi kullanarak, uygulamalıdır <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e973-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="6e973-184">Olarak kullanılabilir bir <xref:System.ComponentModel.TypeConverter> XAML, destekleyen bir uygulama <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> yöntemi Bu dönüştürücü için kabul etmelisiniz desteklenmekte türü (veya bir değer) örneği olarak `value` parametresi.</span><span class="sxs-lookup"><span data-stu-id="6e973-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="6e973-185">Zaman `destinationType` parametre türüdür <xref:System.String>, döndürülen nesne olarak yayınlanması gereken sonra <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="6e973-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="6e973-186">Döndürülen dize bir seri hale getirilmiş değerini temsil etmelidir `value`.</span><span class="sxs-lookup"><span data-stu-id="6e973-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="6e973-187">İdeal olarak, seçtiğiniz serileştirme biçimi bu dize geçirilmiş aynı değeri oluşturma yeteneği olmalıdır <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> önemli bilgi kaybı olmadan aynı dönüştürücü uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="6e973-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="6e973-188">Değeri serileştirilemez veya seri hale getirme, dönüştürücü desteklemiyor <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> uygulama döndürmelidir `null`ve bu durumda bir özel durum oluşturmasına izin verilir.</span><span class="sxs-lookup"><span data-stu-id="6e973-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="6e973-189">Ancak özel durumlar ise bir parçası olarak bu dönüştürme kullanılacak yükleyememesine raporlamalıdır, <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> uygulama böylece ile denetimi en iyi <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> ilk özel durumları engellemek için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="6e973-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="6e973-190">Varsa `destinationType` parametresi türü değil <xref:System.String>, kendi dönüştürücü işleme seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e973-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="6e973-191">Genellikle, işleme, hangi basemost temel uygulamaya geri <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> belirli bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="6e973-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="6e973-192">CanConvertTo uygulama</span><span class="sxs-lookup"><span data-stu-id="6e973-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="6e973-193"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> Uygulamasına dönmesi gerektiğini `true` için `destinationType` türü <xref:System.String>ve aksi için temel uygulama erteleyin.</span><span class="sxs-lookup"><span data-stu-id="6e973-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="6e973-194">CanConvertFrom uygulama</span><span class="sxs-lookup"><span data-stu-id="6e973-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="6e973-195"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> Uygulamasına dönmesi gerektiğini `true` için `sourceType` türü <xref:System.String>ve aksi için temel uygulama erteleyin.</span><span class="sxs-lookup"><span data-stu-id="6e973-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="6e973-196">TypeConverterAttribute uygulanıyor</span><span class="sxs-lookup"><span data-stu-id="6e973-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="6e973-197">Sırayla olarak görev yapan kullanılmak üzere kendi özel tür dönüştürücü için tür dönüştürücüsünü bir XAML işlemcisi tarafından özel bir sınıf için uygulamalısınız [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> sınıf tanımı.</span><span class="sxs-lookup"><span data-stu-id="6e973-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="6e973-198"><xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> Özniteliğiyle belirtin, özel bir tür dönüştürücüsü türü adı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="6e973-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="6e973-199">Bu özniteliği uygulandı, ile XAML işlemci değerleri nerede özellik türü, özel bir sınıf türünü kullanan işlediğinde, bu giriş dizeleri ve nesne örneği döndürür.</span><span class="sxs-lookup"><span data-stu-id="6e973-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="6e973-200">Özellik başına temelinde bir tür dönüştürücüsü de sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e973-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="6e973-201">Uygulama yerine bir [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> isteğe bağlı olarak sınıf tanımının bir özellik tanımı için geçerlidir (ana tanım değil `get` / `set` içindeki uygulamaları).</span><span class="sxs-lookup"><span data-stu-id="6e973-201">Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="6e973-202">Özelliğin türü, özel bir tür dönüştürücüsü tarafından işlenen türüyle eşleşmelidir.</span><span class="sxs-lookup"><span data-stu-id="6e973-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="6e973-203">Bu özniteliği uygulandı, ile bir XAMLprocessor bu özellik değerlerini işlediğinde, bu işlem giriş dizesi ve nesne örneği döndürür.</span><span class="sxs-lookup"><span data-stu-id="6e973-203">With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="6e973-204">Özellik başına türü dönüştürücü özellik türü Microsoft .NET Framework veya sınıf tanımı kontrol ve uygulanamıyor burada bazı diğer kitaplığı kullanmayı tercih ederseniz özellikle kullanışlı bir tekniktir bir <xref:System.ComponentModel.TypeConverterAttribute> vardır.</span><span class="sxs-lookup"><span data-stu-id="6e973-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6e973-205">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="6e973-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="6e973-206">XAML'ye Genel Bakış (WPF)</span><span class="sxs-lookup"><span data-stu-id="6e973-206">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="6e973-207">İşaretleme Uzantıları ve WPF XAML</span><span class="sxs-lookup"><span data-stu-id="6e973-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="6e973-208">Ayrıntılı XAML Sözdizimi</span><span class="sxs-lookup"><span data-stu-id="6e973-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)

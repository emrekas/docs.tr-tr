---
title: WPF için XAML ve Özel Sınıflar
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: c429df440f87110a9059b8f9c40cdf273952f581
ms.sourcegitcommit: 30a83efb57c468da74e9e218de26cf88d3254597
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/20/2019
ms.locfileid: "68364116"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="1761b-102">WPF için XAML ve Özel Sınıflar</span><span class="sxs-lookup"><span data-stu-id="1761b-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="1761b-103">Çerçeveler 'de [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] uygulanan xaml, herhangi [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] bir dilde özel bir sınıf veya yapı tanımlama özelliğini destekler ve sonra XAML biçimlendirmesi kullanarak bu sınıfa erişebilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-103">XAML as implemented in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] frameworks supports the ability to define a custom class or structure in any [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language, and then access that class using XAML markup.</span></span> <span data-ttu-id="1761b-104">Genellikle özel türleri bir xaml ad [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]alanı ön ekine eşleyerek, tanımlı türler ve özel türlerinizin aynısını aynı biçimlendirme dosyası içinde kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1761b-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="1761b-105">Bu konu, bir özel sınıfın XAML öğesi olarak kullanılabilmesi için karşılaması gereken gereksinimleri tartışır.</span><span class="sxs-lookup"><span data-stu-id="1761b-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="1761b-106">Uygulamalarda veya derlemelerde özel sınıflar</span><span class="sxs-lookup"><span data-stu-id="1761b-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="1761b-107">XAML 'de kullanılan özel sınıflar iki farklı şekilde tanımlanabilir: arka plan kodu veya birincil [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] uygulamayı üreten diğer kod içinde ya da sınıf kitaplığı olarak kullanılan çalıştırılabilir veya dll gibi ayrı bir derlemede sınıf olarak.</span><span class="sxs-lookup"><span data-stu-id="1761b-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="1761b-108">Bu yaklaşımların her biri belirli avantajlar ve dezavantajlara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1761b-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="1761b-109">Bir sınıf kitaplığı oluşturmanın avantajı, bu tür özel sınıfların birçok farklı uygulama genelinde paylaşılabilmesi olabilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="1761b-110">Ayrı bir kitaplık Ayrıca uygulamaların sürüm oluşturma sorunlarının daha kolay denetimini kolaylaştırır ve hedeflenen sınıf kullanımının XAML sayfasında kök öğe olduğu bir sınıfı oluşturmayı basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="1761b-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="1761b-111">Uygulamada özel sınıflar tanımlamanın avantajı, bu tekniğin görece hafif olması ve ana uygulama yürütülebilirinin ötesinde ayrı derlemeler tanılarken karşılaşılan dağıtım ve test sorunlarını en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="1761b-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="1761b-112">Aynı veya farklı derlemede tanımlanmış olup olmadığı, özel sınıfların XAML 'de öğe olarak kullanılabilmesi için CLR ad alanı ve XML ad alanı arasında eşlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="1761b-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="1761b-113">Bkz. [WPF XAML Için xaml ad alanları ve ad alanı eşlemesi](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="1761b-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="1761b-114">XAML öğesi olarak özel bir sınıf için gereksinimler</span><span class="sxs-lookup"><span data-stu-id="1761b-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="1761b-115">Bir nesne öğesi olarak örneklenebilir olması için, sınıfınızın aşağıdaki gereksinimleri karşılaması gerekir:</span><span class="sxs-lookup"><span data-stu-id="1761b-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="1761b-116">Özel sınıfınız ortak olmalıdır ve varsayılan (parametresiz) bir ortak oluşturucuyu desteklemelidir.</span><span class="sxs-lookup"><span data-stu-id="1761b-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="1761b-117">(Yapılar hakkında notlar için aşağıdaki bölüme bakın.)</span><span class="sxs-lookup"><span data-stu-id="1761b-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="1761b-118">Özel sınıfınız iç içe geçmiş bir sınıf olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="1761b-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="1761b-119">İç içe geçmiş sınıflar ve genel CLR kullanımı sözdiziminde "nokta" Ekli özellikler gibi diğer [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ve/veya xaml özellikleriyle karışır.</span><span class="sxs-lookup"><span data-stu-id="1761b-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="1761b-120">Nesne tanımınız, nesne öğesi söz dizimini etkinleştirmeye ek olarak, bu nesneyi değer türü olarak alan diğer tüm ortak özellikler için özellik öğesi söz dizimini da etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="1761b-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="1761b-121">Bunun nedeni, nesnenin artık bir nesne öğesi olarak örneklenebilir ve bu tür bir özelliğin özellik öğesi değerini doldurabilirler.</span><span class="sxs-lookup"><span data-stu-id="1761b-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="1761b-122">Yapılar</span><span class="sxs-lookup"><span data-stu-id="1761b-122">Structures</span></span>  
 <span data-ttu-id="1761b-123">Özel türler olarak tanımladığınız yapılar, içindeki [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xaml 'de her zaman oluşturulabilir. Bunun nedeni, derleyicilerin tüm özellik değerlerini varsayılan değerlerine Başlatan bir yapı için örtük olarak parametresiz bir Oluşturucu oluşturmaktır. [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]</span><span class="sxs-lookup"><span data-stu-id="1761b-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="1761b-124">Bazı durumlarda, varsayılan oluşturma davranışı ve/veya bir yapı için nesne öğesi kullanımı istenmez.</span><span class="sxs-lookup"><span data-stu-id="1761b-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="1761b-125">Bunun nedeni, yapının değerler ve işlev kavramsal olarak kavramsal olarak doldurulmasının amaçlandığı, burada içerilen değerlerin birbirini dışlamalı yorumlamalar olabileceği ve bu nedenle özelliklerinden hiçbirinin ayarlanamaz olması olabilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="1761b-126">Bu tür bir yapıya <xref:System.Windows.GridLength> örnekolarakyerverilir.[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</span><span class="sxs-lookup"><span data-stu-id="1761b-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="1761b-127">Genellikle, bu tür yapılar, değerlerin öznitelik biçiminde ifade edileceği, örneğin farklı yorumlamalar veya yapı değerlerinin modlarını oluşturan dize kuralları kullanılarak bir tür dönüştürücüsü uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="1761b-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="1761b-128">Yapı Ayrıca, parametresiz bir Oluşturucu aracılığıyla kod oluşturma için benzer davranışları kullanıma sunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1761b-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="1761b-129">XAML öznitelikleri olarak özel bir sınıfın özellikleri için gereksinimler</span><span class="sxs-lookup"><span data-stu-id="1761b-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="1761b-130">Özellikler bir değere göre bir türe (ilkel gibi) başvurmalıdır veya parametresiz bir oluşturucuya ya da XAML işlemcisinin erişebileceği ayrılmış bir tür dönüştürücüde bulunan tür için bir sınıf kullanır.</span><span class="sxs-lookup"><span data-stu-id="1761b-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="1761b-131">CLR xaml uygulamasında XAML işlemcileri, dil temel temelleri için yerel destek aracılığıyla veya ' nin <xref:System.ComponentModel.TypeConverterAttribute> , bir tür veya bir üyeye geçiş türü tanımlarında bir uygulama aracılığıyla bu tür dönüştürücüleri bulur</span><span class="sxs-lookup"><span data-stu-id="1761b-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="1761b-132">Alternatif olarak, özelliği bir soyut sınıf türüne veya arabirimine başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="1761b-133">Soyut sınıflar veya arabirimler için, XAML ayrıştırma beklentisi, özellik değerinin arabirimini uygulayan pratik sınıf örnekleriyle veya soyut sınıftan türetilen türlerin örneklerinin doldurulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="1761b-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="1761b-134">Özellikler soyut bir sınıfta bildirilemez, ancak yalnızca soyut sınıftan türetilmiş pratik sınıflarda ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="1761b-135">Bunun nedeni, sınıf için nesne öğesinin oluşturulması sınıfında Ortak parametresiz bir Oluşturucu gerektirmesidir.</span><span class="sxs-lookup"><span data-stu-id="1761b-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="1761b-136">TypeConverter etkin öznitelik sözdizimi</span><span class="sxs-lookup"><span data-stu-id="1761b-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="1761b-137">Sınıf düzeyinde adanmış, öznitelikli tür dönüştürücüsü sağlarsanız, uygulanan tür dönüştürmesi, bu türü örneklemesi gereken herhangi bir özellik için öznitelik sözdizimini sağlar.</span><span class="sxs-lookup"><span data-stu-id="1761b-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="1761b-138">Tür dönüştürücüsü nesnenin nesne öğesi kullanımını etkinleştirmez; Bu tür için yalnızca parametresiz bir oluşturucunun varlığı, nesne öğesi kullanımını mümkün.</span><span class="sxs-lookup"><span data-stu-id="1761b-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="1761b-139">Bu nedenle, türün kendisi de nesne öğesi sözdizimini desteklemediği takdirde tür dönüştürücüsü etkin olan özellikler genellikle özellik sözdiziminde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="1761b-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="1761b-140">Bunun özel durumu, bir özellik öğesi söz dizimini belirtebileceğiniz, ancak Property öğesinin bir dize içermesi olabilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="1761b-141">Bu kullanım aslında bir öznitelik sözdizimi kullanımına eşdeğerdir ve öznitelik değerinin daha sağlam bir boşluk işlemesi olması gerekmediği takdirde bu kullanım yaygın değildir.</span><span class="sxs-lookup"><span data-stu-id="1761b-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="1761b-142">Örneğin, aşağıdaki bir dize alan ve öznitelik kullanım eşdeğerini olan bir özellik öğesi kullanımdır:</span><span class="sxs-lookup"><span data-stu-id="1761b-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="1761b-143">Öznitelik sözdizimine izin verilen özelliklerin örnekleri, ancak xaml aracılığıyla nesne öğesi içeren özellik öğesi sözdizimine izin verilmez, <xref:System.Windows.Input.Cursor> türü alan çeşitli özelliklerdir.</span><span class="sxs-lookup"><span data-stu-id="1761b-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="1761b-144">Sınıf adanmış bir tür dönüştürücüye <xref:System.Windows.Input.CursorConverter>sahiptir, ancak <xref:System.Windows.FrameworkElement.Cursor%2A> parametresiz bir Oluşturucu sunmaz, bu nedenle özellik yalnızca gerçek <xref:System.Windows.Input.Cursor> tür bir başvuru türü olsa bile öznitelik sözdizimi aracılığıyla ayarlanabilir. <xref:System.Windows.Input.Cursor></span><span class="sxs-lookup"><span data-stu-id="1761b-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="1761b-145">Özellik başına tür dönüştürücüler</span><span class="sxs-lookup"><span data-stu-id="1761b-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="1761b-146">Alternatif olarak, özelliğinin kendisi de özellik düzeyinde bir tür dönüştürücüsü bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="1761b-147">Bu, özelliğin gelen dize değerlerini uygun türe göre bir <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> işlem girişi olarak işleyerek bir "Mini dil" özelliği sunar.</span><span class="sxs-lookup"><span data-stu-id="1761b-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="1761b-148">Genellikle bu bir kullanışlı erişimci sağlamak için yapılır ve XAML 'de bir özelliği ayarlamayı etkinleştirmek için tek bir yöntem olarak değildir.</span><span class="sxs-lookup"><span data-stu-id="1761b-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="1761b-149">Ancak, parametresiz bir Oluşturucu ya da öznitelikli tür dönüştürücüsü içermeyen mevcut [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] türleri kullanmak istediğiniz öznitelikler için tür dönüştürücülerinin kullanılması da mümkündür.</span><span class="sxs-lookup"><span data-stu-id="1761b-149">However, it is also possible to use type converters for attributes where you want to use existing [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="1761b-150">API örnekleri, <xref:System.Globalization.CultureInfo> türü alan bazı özelliklerdir. [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</span><span class="sxs-lookup"><span data-stu-id="1761b-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="1761b-151">Bu durumda [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , Framework <xref:System.Globalization.CultureInfo> 'ün önceki sürümlerinde kullanılan uyumluluk ve geçiş senaryolarına daha iyi adres sağlamak için mevcut Microsoft .NET çerçeve türünü kullandınız, ancak türgereklidesteğisağlamadı<xref:System.Globalization.CultureInfo> oluşturucular veya tür düzeyi tür dönüştürme doğrudan XAML özellik değeri olarak kullanılabilir olacak.</span><span class="sxs-lookup"><span data-stu-id="1761b-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="1761b-152">XAML kullanımına sahip bir özelliği kullanıma sunışınızda, özellikle bir denetim yazarlýşınızda, bu özelliği bir bağımlılık özelliği ile yedeklemeyi kesin bir şekilde dikkate almanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1761b-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="1761b-153">Bu, yedekleme kullanarak [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.DependencyProperty> performansı iyileştirebilmeniz için XAML işlemcisinin mevcut uygulamasını kullanıyorsanız özellikle doğrudur.</span><span class="sxs-lookup"><span data-stu-id="1761b-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="1761b-154">Bağımlılık özelliği, özelliği için kullanıcıların XAML erişilebilir bir özelliği bekleecek şekilde özellik sistem özelliklerini kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="1761b-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="1761b-155">Bu, animasyon, veri bağlama ve stil desteği gibi özellikleri içerir.</span><span class="sxs-lookup"><span data-stu-id="1761b-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="1761b-156">Daha fazla bilgi için bkz. [Özel bağımlılık özellikleri](custom-dependency-properties.md) ve [XAML yükleme ve bağımlılık özellikleri](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="1761b-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="1761b-157">Tür dönüştürücüsü yazma ve Attributing</span><span class="sxs-lookup"><span data-stu-id="1761b-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="1761b-158">Bazen Özellik türü için tür dönüştürmesi sağlamak üzere <xref:System.ComponentModel.TypeConverter> özel bir türetilmiş sınıf yazmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1761b-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="1761b-159">' Dan türeme ve xaml kullanımlarını destekleyebilen bir tür dönüştürücüsü oluşturma ve <xref:System.ComponentModel.TypeConverterAttribute>' nin nasıl uygulanacağı hakkında yönergeler için bkz. [TypeConverters ve xaml](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="1761b-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="1761b-160">Özel bir sınıfın olaylarında XAML olay Işleyicisi öznitelik sözdizimi için gereksinimler</span><span class="sxs-lookup"><span data-stu-id="1761b-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="1761b-161">Olay olarak [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] kullanılabilmesi için, olay parametresiz oluşturucuyu destekleyen bir sınıfta veya türetilmiş sınıflarda olaya erişilebilen bir soyut sınıfta, olay genel bir olay olarak kullanıma sunulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1761b-161">To be usable as a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="1761b-162">Yönlendirilmiş olay olarak kolayca kullanılabilmesi için, olaylarınız [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] `add` `remove` , [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] olay imzası için işleyicileri ekleyip kaldırarak ve bu işleyicileri <xref:System.Windows.UIElement.AddHandler%2A> ve<xref:System.Windows.UIElement.RemoveHandler%2A> yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="1761b-162">In order to be used conveniently as a routed event, your [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event should implement explicit `add` and `remove` methods, which add and remove handlers for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="1761b-163">Bu yöntemler, etkinliğin eklendiği örnekteki yönlendirilmiş olay işleyicisi deposuna işleyicileri ekler veya kaldırır.</span><span class="sxs-lookup"><span data-stu-id="1761b-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1761b-164">Kullanarak <xref:System.Windows.UIElement.AddHandler%2A>doğrudan yönlendirilmiş olaylar için işleyicileri kaydetmek mümkündür ve bilerek yönlendirilmiş olayı sunan bir [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] olay tanımlamaz.</span><span class="sxs-lookup"><span data-stu-id="1761b-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that exposes the routed event.</span></span> <span data-ttu-id="1761b-165">Bu, genel olarak önerilmez çünkü olay, işleyicileri eklemek için XAML öznitelik sözdizimini etkinleştirmeyecektir ve elde edilen sınıfınız bu türün özelliklerine daha az saydam bir XAML görünümü sunacaktır.</span><span class="sxs-lookup"><span data-stu-id="1761b-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="1761b-166">Koleksiyon özellikleri yazılıyor</span><span class="sxs-lookup"><span data-stu-id="1761b-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="1761b-167">Koleksiyon türü alan özellikler, koleksiyona eklenen nesneleri belirtmenizi sağlayan bir XAML sözdizimine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1761b-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="1761b-168">Bu sözdiziminin iki önemli özelliği vardır.</span><span class="sxs-lookup"><span data-stu-id="1761b-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="1761b-169">Koleksiyon nesnesi olan nesnenin nesne öğesi sözdiziminde belirtilmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="1761b-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="1761b-170">Bir koleksiyon türü alan XAML 'de bir özellik belirttiğinizde, bu koleksiyon türünün varlığı örtük bir şekilde gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="1761b-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="1761b-171">Biçimlendirme içindeki koleksiyon özelliğinin alt öğeleri, koleksiyonun üyesi olacak şekilde işlenir.</span><span class="sxs-lookup"><span data-stu-id="1761b-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="1761b-172">Normalde, bir koleksiyonun üyelerine yönelik kod erişimi `Add`, veya gibi bir dizin oluşturucu aracılığıyla veya gibi liste/sözlük yöntemleri aracılığıyla gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="1761b-173">Ancak XAML sözdizimi yöntemleri veya dizin oluşturucuyu desteklemez (özel durum: XAML 2009, yöntemleri destekleyebilir, ancak XAML 2009 kullanmak olası WPF kullanımlarını kısıtlar; bkz. [XAML 2009 dil özellikleri](../../xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="1761b-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="1761b-174">Koleksiyonlar bir öğe ağacı oluşturmak için çok yaygın bir gereksinimdir ve bu koleksiyonları bildirime dayalı XAML 'de doldurmanız için bir yol gerekir.</span><span class="sxs-lookup"><span data-stu-id="1761b-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="1761b-175">Bu nedenle, bir koleksiyon özelliğinin alt öğeleri, koleksiyon özelliği tür değeri olan koleksiyona eklenerek işlenir.</span><span class="sxs-lookup"><span data-stu-id="1761b-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="1761b-176">.NET Framework XAML Hizmetleri uygulamasını ve böylece WPF XAML işlemcisi, bir koleksiyon özelliğini oluşturan için aşağıdaki tanımı kullanır.</span><span class="sxs-lookup"><span data-stu-id="1761b-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="1761b-177">Özelliğin özellik türü aşağıdakilerden birini gerçekleştirmelidir:</span><span class="sxs-lookup"><span data-stu-id="1761b-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="1761b-178">Uygular <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="1761b-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="1761b-179">Ya <xref:System.Collections.IDictionary> da genel eşdeğerini (<xref:System.Collections.Generic.IDictionary%602>) uygular.</span><span class="sxs-lookup"><span data-stu-id="1761b-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="1761b-180">Türetiliyor (XAML içindeki diziler hakkında daha fazla bilgi için bkz. [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).) <xref:System.Array></span><span class="sxs-lookup"><span data-stu-id="1761b-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="1761b-181">Uygular <xref:System.Windows.Markup.IAddChild> (tarafından [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]tanımlanan bir arabirim).</span><span class="sxs-lookup"><span data-stu-id="1761b-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="1761b-182">CLR 'deki bu türlerin her biri, nesne `Add` grafiğini oluştururken temel koleksiyona öğe eklemek için XAML işlemcisi tarafından kullanılan bir yöntemine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1761b-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1761b-183">Genel `List` ve `Dictionary` arabirimler [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (<xref:System.Collections.Generic.IList%601> ve ),XAMLişlemcisitarafındankoleksiyonalgılamaiçindesteklenmez.<xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="1761b-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="1761b-184"><xref:System.Collections.Generic.List%601> Ancak doğrudan uyguladığından veya <xref:System.Collections.IList> <xref:System.Collections.Generic.Dictionary%602> bir temel sınıf <xref:System.Collections.IDictionary> olarak, doğrudan uyguladığı için sınıfını temel sınıf olarak kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1761b-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="1761b-185">Bir koleksiyonu alan bir özellik bildirdiğinizde, bu özellik değerinin türün yeni örneklerinde nasıl başlatıldığıyla ilgili dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="1761b-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="1761b-186">Özelliği bir bağımlılık özelliği olarak uygulamadıysanız, özelliğin koleksiyon türü oluşturucusunu çağıran bir yedekleme alanı kullanması yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="1761b-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="1761b-187">Eğer Eğer özelliği bir bağımlılık özelliği ise, koleksiyon özelliğini varsayılan tür oluşturucusunun bir parçası olarak başlatmak gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="1761b-188">Bunun nedeni, bağımlılık özelliğinin meta verilerden varsayılan değerini almaması ve genellikle bir koleksiyon özelliğinin başlangıçtaki değerinin statik, paylaşılan bir koleksiyon olmasını istemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="1761b-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="1761b-189">Her bir kapsayan tür örneği için bir koleksiyon örneği olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1761b-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="1761b-190">Daha fazla bilgi için bkz. [Özel bağımlılık özellikleri](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="1761b-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="1761b-191">Koleksiyon özelliği için özel bir koleksiyon türü uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1761b-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="1761b-192">Örtük koleksiyon özelliği işlemi nedeniyle, özel koleksiyon türünün XAML 'de örtük olarak kullanılabilmesi için parametresiz bir Oluşturucu sağlamasına gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="1761b-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="1761b-193">Ancak, isteğe bağlı olarak, koleksiyon türü için parametresiz bir Oluşturucu sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1761b-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="1761b-194">Bu bir Wora yöntemi olabilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="1761b-195">Parametresiz bir Oluşturucu sağlamadığınız sürece, koleksiyonu açıkça bir nesne öğesi olarak bildiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="1761b-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="1761b-196">Bazı biçimlendirme yazarları, biçimlendirme stiliyle bağımsız olarak açık toplamayı görmeyi tercih edebilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="1761b-197">Ayrıca, parametresiz bir Oluşturucu, koleksiyon türünü bir özellik değeri olarak kullanan yeni nesneler oluşturduğunuzda başlatma gereksinimlerini basitleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="1761b-198">XAML Içerik özelliklerini bildirme</span><span class="sxs-lookup"><span data-stu-id="1761b-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="1761b-199">XAML dili, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] içerik özelliği kavramını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="1761b-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="1761b-200">Nesne sözdiziminde kullanılabilir olan her sınıf tam olarak bir XAML içerik özelliğine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="1761b-201">Sınıfınız için xaml içerik özelliği <xref:System.Windows.Markup.ContentPropertyAttribute> olarak bir özelliği bildirmek üzere, sınıf tanımının parçası olarak uygulayın.</span><span class="sxs-lookup"><span data-stu-id="1761b-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="1761b-202">Hedeflenen xaml içerik özelliğinin adını özniteliğinde olarak <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> belirtin.</span><span class="sxs-lookup"><span data-stu-id="1761b-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="1761b-203">Özelliği, gibi bir yansıma yapısı <xref:System.Reflection.PropertyInfo>olarak değil, ada göre bir dize olarak belirtilir.</span><span class="sxs-lookup"><span data-stu-id="1761b-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="1761b-204">XAML içerik özelliği olarak bir koleksiyon özelliği belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1761b-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="1761b-205">Bu, nesne öğesinin bir veya daha fazla alt öğesine sahip olması ve herhangi bir araya eklenen koleksiyon nesnesi öğesi ya da Özellik öğesi etiketleri olmadan bu özelliğin kullanılmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="1761b-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="1761b-206">Bu öğeler daha sonra XAML içerik özelliği için değer olarak değerlendirilir ve yedekleme koleksiyonu örneğine eklenir.</span><span class="sxs-lookup"><span data-stu-id="1761b-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="1761b-207">Bazı var olan XAML içerik özellikleri, öğesinin `Object`Özellik türünü kullanır.</span><span class="sxs-lookup"><span data-stu-id="1761b-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="1761b-208">Bu, bir <xref:System.String> xaml içerik özelliğinin, ve gibi basit değerler alıp tek bir başvuru nesne değeri alınmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="1761b-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="1761b-209">Bu modeli izlerseniz, tipiniz tür belirlemekten ve olası türlerin işlenmesinden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="1761b-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="1761b-210">Bir <xref:System.Object> içerik türünün tipik nedeni, nesne içeriğini bir dize olarak (varsayılan bir sunum işlemi alır) ya da varsayılan olmayan bir sunumu belirten nesne içeriği eklemenin gelişmiş bir yolu veya ek veriler.</span><span class="sxs-lookup"><span data-stu-id="1761b-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="1761b-211">XAML serileştirme</span><span class="sxs-lookup"><span data-stu-id="1761b-211">Serializing XAML</span></span>  
 <span data-ttu-id="1761b-212">Bir denetim yazarı gibi belirli senaryolarda, XAML 'de örneklenebilir herhangi bir nesne gösteriminin de eşdeğer XAML biçimlendirmesine geri serileştirilmesine emin olmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1761b-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="1761b-213">Serileştirme gereksinimleri bu konuda açıklanmamaktadır.</span><span class="sxs-lookup"><span data-stu-id="1761b-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="1761b-214">Bkz. [Denetim yazma genel bakış](../controls/control-authoring-overview.md) ve [öğe ağacı ve serileştirme](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="1761b-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1761b-215">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="1761b-215">See also</span></span>

- [<span data-ttu-id="1761b-216">XAML'ye Genel Bakış (WPF)</span><span class="sxs-lookup"><span data-stu-id="1761b-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="1761b-217">Özel Bağımlılık Özellikleri</span><span class="sxs-lookup"><span data-stu-id="1761b-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="1761b-218">Denetim Yazımına Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="1761b-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="1761b-219">Temel Öğelere Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="1761b-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="1761b-220">XAML Yükleme ve Bağımlılık Özellikleri</span><span class="sxs-lookup"><span data-stu-id="1761b-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)

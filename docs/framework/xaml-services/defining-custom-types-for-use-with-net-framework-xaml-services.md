---
title: .NET Framework XAML Hizmetlerinde Kullanılacak Özel Türleri Tanımlama
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: be9c0e26574a15279ce89af2c7862abaa8713360
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61971957"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="62890-102">.NET Framework XAML Hizmetlerinde Kullanılacak Özel Türleri Tanımlama</span><span class="sxs-lookup"><span data-stu-id="62890-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="62890-103">İş nesneler özel türleri tanımlama ya da bir bağımlılık belirli çerçeveler sahip olmayan türleri izleyebilirsiniz XAML için bazı en iyi yöntemler vardır.</span><span class="sxs-lookup"><span data-stu-id="62890-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="62890-104">Bu uygulamaları izlerseniz, .NET Framework XAML hizmetlerinde ve XAML okuyucular ve yazıcılar XAML türünüz XAML özelliklerini bulabilir ve XAML tür sistemi kullanarak XAML düğüm akış uygun gösterimi verin.</span><span class="sxs-lookup"><span data-stu-id="62890-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="62890-105">Bu konu için tür tanımları, üye tanımları ve CLR türleri veya üyeleri öznitelik atanıyor en iyi uygulamaları açıklar.</span><span class="sxs-lookup"><span data-stu-id="62890-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="62890-106">Oluşturucu desenler ve XAML için tür tanımları</span><span class="sxs-lookup"><span data-stu-id="62890-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="62890-107">Bir XAML nesne öğesi olarak örneği için özel bir sınıf aşağıdaki gereksinimleri karşılamalıdır:</span><span class="sxs-lookup"><span data-stu-id="62890-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="62890-108">Özel bir sınıf, ortak olmalıdır ve bir varsayılan (parametresiz) ortak oluşturucu kullanıma açmalıdır.</span><span class="sxs-lookup"><span data-stu-id="62890-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="62890-109">(Aşağıdaki bölümde yapıları ile ilgili notlar için bkz.)</span><span class="sxs-lookup"><span data-stu-id="62890-109">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="62890-110">Özel bir sınıf, iç içe geçmiş bir sınıf olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="62890-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="62890-111">Tam ad yolunda "dot" ekstra sınıf ad alanı bölme belirsiz hale getirir ve iliştirilmiş özellikler gibi diğer XAML özelliklerle uğratır.</span><span class="sxs-lookup"><span data-stu-id="62890-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="62890-112">Bir nesne bir nesne öğesi olarak oluşturulabilir, oluşturulan nesne nesnesi olarak temel alan herhangi bir özelliği özellik öğesi biçiminin doldurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="62890-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="62890-113">Yine de bir değer dönüştürücü etkinleştirirseniz, bu ölçütleri karşılamayan türleri için nesne değerleri sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="62890-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="62890-114">Daha fazla bilgi için [tür dönüştürücüleri ve İşaretleme uzantıları için XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="62890-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="62890-115">Yapılar</span><span class="sxs-lookup"><span data-stu-id="62890-115">Structures</span></span>  
 <span data-ttu-id="62890-116">Yapıları her zaman XAML içinde CLR tanımı tarafından oluşturulması olanağına sahip olursunuz.</span><span class="sxs-lookup"><span data-stu-id="62890-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="62890-117">Bu durum, CLR derleyici örtük olarak bir yapı için varsayılan bir oluşturucu oluşturur çünkü.</span><span class="sxs-lookup"><span data-stu-id="62890-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="62890-118">Bu oluşturucu, tüm özellik değerlerini varsayılanlarına başlatır.</span><span class="sxs-lookup"><span data-stu-id="62890-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="62890-119">Bazı durumlarda, bir yapı için varsayılan yapı davranış arzu değil.</span><span class="sxs-lookup"><span data-stu-id="62890-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="62890-120">Bu yapı, değerleri ve işlevi bir birleşimi olarak kavramsal olarak doldurmak için tasarlandığından olabilir.</span><span class="sxs-lookup"><span data-stu-id="62890-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="62890-121">Bir birleşimi olarak içerdiği değerlerin birbirini dışlayan yorumlaması olabilir ve bu nedenle, özelliklerini hiçbiri ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="62890-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="62890-122">Böyle bir yapı içinde WPF sözlüğü örneğidir <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="62890-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="62890-123">Böylece değerleri öznitelik formunda yapısı değerlerinin modları ve farklı ınterpretations oluşturma dize kurallarını kullanarak ifade edilebilir bir tür dönüştürücüsü gibi yapıları uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="62890-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="62890-124">Yapısı, varsayılan olmayan bir oluşturucu aracılığıyla kod oluşturma için benzer bir davranış da sunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="62890-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="62890-125">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="62890-125">Interfaces</span></span>  
 <span data-ttu-id="62890-126">Arabirimleri, temel alınan üye türleri olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="62890-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="62890-127">XAML tür sistemi atanabilir listenin denetler ve değeri olarak sağlanan nesne arabirimine atanabilir bekliyor.</span><span class="sxs-lookup"><span data-stu-id="62890-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="62890-128">XAML yapı gereksinimleri ilgili atanabilir bir tür desteklediği sürece, arabirimi XAML türü olarak nasıl sunulmalıdır konsepti yoktur.</span><span class="sxs-lookup"><span data-stu-id="62890-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="62890-129">Fabrika yöntemleri</span><span class="sxs-lookup"><span data-stu-id="62890-129">Factory Methods</span></span>  
 <span data-ttu-id="62890-130">Fabrika yöntemleri bir XAML 2009 özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="62890-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="62890-131">Bunlar, nesneler varsayılan oluşturucular olmalıdır XAML ilkesini değiştirin.</span><span class="sxs-lookup"><span data-stu-id="62890-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="62890-132">Bu konu başlığında, Fabrika yöntemleri belgelenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="62890-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="62890-133">Bkz: [x: FactoryMethod yönergesi](x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="62890-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="62890-134">Numaralandırmalar</span><span class="sxs-lookup"><span data-stu-id="62890-134">Enumerations</span></span>  
 <span data-ttu-id="62890-135">Numaralandırmaların XAML yerel tür dönüştürme davranışı.</span><span class="sxs-lookup"><span data-stu-id="62890-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="62890-136">XAML içinde belirtilen numaralandırma sabit adları, temel alınan numaralandırma türüne göre çözümlenir ve bir XAML nesne yazıcısı numaralandırma değerini döndürür.</span><span class="sxs-lookup"><span data-stu-id="62890-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="62890-137">XAML ile numaralandırmalar bayrakları stili kullanım desteği <xref:System.FlagsAttribute> uygulanır.</span><span class="sxs-lookup"><span data-stu-id="62890-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="62890-138">Daha fazla bilgi için [içinde XAML söz dizimi ayrıntı](../wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="62890-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="62890-139">([İçinde XAML söz dizimi ayrıntı](../wpf/advanced/xaml-syntax-in-detail.md) WPF izleyiciler için yazılmıştır ancak çoğu bu konu başlığı altındaki bilgiler, ilgili belirli bir uygulama çerçevesine özgü olmayan XAML.)</span><span class="sxs-lookup"><span data-stu-id="62890-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="62890-140">Üye tanımları</span><span class="sxs-lookup"><span data-stu-id="62890-140">Member Definitions</span></span>  
 <span data-ttu-id="62890-141">Tür üyeleri için XAML kullanım tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="62890-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="62890-142">Bu işlem, bu türdeki XAML kullanılabilir olsa bile, XAML kullanılabilir üyeler tanımlayan türler için de mümkündür.</span><span class="sxs-lookup"><span data-stu-id="62890-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="62890-143">Bu, CLR devralma nedeniyle mümkün olur.</span><span class="sxs-lookup"><span data-stu-id="62890-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="62890-144">Üye devralınan tür XAML kullanım türü olarak destekler ve üye, temel alınan türü için XAML kullanım destekler veya bir yerel XAML sözdizimi sürece bu XAML kullanılabilir bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="62890-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="62890-145">Özellikler</span><span class="sxs-lookup"><span data-stu-id="62890-145">Properties</span></span>  
 <span data-ttu-id="62890-146">Özellikleri tipik CLR kullanarak genel bir CLR özelliği olarak tanımlarsanız `get` ve `set` erişimci desenleri ve uygun dilde keywording, XAML tür sistemi rapor özelliği uygun bilgilerle bir üyesi olarak sağlanan için <xref:System.Xaml.XamlMember> özellikleri gibi <xref:System.Xaml.XamlMember.IsReadPublic%2A> ve <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="62890-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="62890-147">Belirli özellikler, bir metin söz dizimi uygulayarak etkinleştirebilir <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="62890-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="62890-148">Daha fazla bilgi için [tür dönüştürücüleri ve İşaretleme uzantıları için XAML](type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="62890-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="62890-149">Bir metin sözdizimi veya yerel XAML dönüştürme ve biçimlendirme uzantısı kullanımı, bir özelliğin türünü gibi daha fazla yöneltme olmaması (<xref:System.Xaml.XamlMember.TargetType%2A> XAML içinde tür sistemi) bir örnek t düşünerek bir XAML nesne yazıcısı geri olmalıdır Hedef türü bir CLR türü.</span><span class="sxs-lookup"><span data-stu-id="62890-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="62890-150">XAML 2009 kullanıyorsanız [x: Reference işaretleme uzantısı](x-reference-markup-extension.md) önceki konuları karşılanmazsa değerlerini sağlamak için kullanılabilir; ancak, bu tür tanımı sorunu daha kullanım sorunu daha fazla bilgi.</span><span class="sxs-lookup"><span data-stu-id="62890-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="62890-151">Olaylar</span><span class="sxs-lookup"><span data-stu-id="62890-151">Events</span></span>  
 <span data-ttu-id="62890-152">Olaylar genel bir CLR olay olarak tanımlarsanız, XAML tür sistemi olay sahip bir üye olarak bildirebilirsiniz <xref:System.Xaml.XamlMember.IsEvent%2A> olarak `true`.</span><span class="sxs-lookup"><span data-stu-id="62890-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="62890-153">Olay işleyicileri bağlama .NET Framework XAML hizmetlerinde özellikleri kapsamında değildir; Bu, uygulamaları ve belirli çerçeveleri ile bırakılır.</span><span class="sxs-lookup"><span data-stu-id="62890-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="62890-154">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="62890-154">Methods</span></span>  
 <span data-ttu-id="62890-155">Satır içi kod yöntemleri için bir varsayılan XAML özelliği değil.</span><span class="sxs-lookup"><span data-stu-id="62890-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="62890-156">Çoğu durumda doğrudan yöntem üyeleri XAML başvuru değildir ve XAML yöntemleri yalnızca belirli XAML desenleri için destek sağlamak için rolüdür.</span><span class="sxs-lookup"><span data-stu-id="62890-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="62890-157">[x: FactoryMethod yönergesi](x-factorymethod-directive.md) bir özel durumdur.</span><span class="sxs-lookup"><span data-stu-id="62890-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="62890-158">Alanlar</span><span class="sxs-lookup"><span data-stu-id="62890-158">Fields</span></span>  
 <span data-ttu-id="62890-159">CLR tasarım yönergeleri statik olmayan alanları önleyin.</span><span class="sxs-lookup"><span data-stu-id="62890-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="62890-160">Statik alanlar için statik alan değerlerini erişebileceğiniz yalnızca aracılığıyla [x: Static işaretleme uzantısı](x-static-markup-extension.md); bu durumda, özel bir alan için kullanıma sunmak için CLR tanımındaki herhangi bir şey yapmakta olduğunuz değil [x: Static](x-static-markup-extension.md) kullanımları.</span><span class="sxs-lookup"><span data-stu-id="62890-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="62890-161">İliştirilebilir üyeleri</span><span class="sxs-lookup"><span data-stu-id="62890-161">Attachable Members</span></span>  
 <span data-ttu-id="62890-162">İliştirilebilir üyeleri için XAML, bir erişimci yöntemi deseni tanımlayan bir türe göre aracılığıyla sunulur.</span><span class="sxs-lookup"><span data-stu-id="62890-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="62890-163">Tanımlama türü XAML-kullanışlı bir nesne olarak olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="62890-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="62890-164">Aslında, bir hizmet sınıfı, rol bildirmek için yaygın bir düzen olduğunu iliştirilebilir üye kendi ve ilgili davranışları uygulayın, ancak kullanıcı Arabirimi gösterimi gibi diğer bir işlev hizmet.</span><span class="sxs-lookup"><span data-stu-id="62890-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="62890-165">Aşağıdaki bölümler, yer tutucu *PropertyName* iliştirilebilir, üyenin adını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="62890-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="62890-166">Bu ad geçerli [XamlName Dilbilgisi](xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="62890-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="62890-167">Bu desenleri ve bir türün diğer yöntemleri arasındaki ad çakışmalarının dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="62890-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="62890-168">Desenlerden biriyle eşleşen bir üye zaten varsa, amacınız değildi olsa bile, bir iliştirilebilir üye kullanım yol XAML işlemcisi tarafından yorumlanabilir.</span><span class="sxs-lookup"><span data-stu-id="62890-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="62890-169">GetPropertyName erişimcisi</span><span class="sxs-lookup"><span data-stu-id="62890-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="62890-170">İmzası `Get` *PropertyName* erişimcisi olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="62890-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="62890-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="62890-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
- <span data-ttu-id="62890-172">`target` Nesnesi, uygulamanızdaki daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="62890-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="62890-173">İliştirilebilir üyelik kullanımını kapsamını belirlemek için kullanabilirsiniz; hedeflenen Kapsamınız dışında kullanımları, ardından bir XAML ayrıştırma hatası ortaya çıkmış geçersiz dönüştürme özel durumlar.</span><span class="sxs-lookup"><span data-stu-id="62890-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="62890-174">Parametre adı `target` bir gereksinim değildir, ancak adlı `target` çoğu uygulamalarında kural tarafından.</span><span class="sxs-lookup"><span data-stu-id="62890-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
- <span data-ttu-id="62890-175">Dönüş değeri, uygulamanızda daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="62890-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="62890-176">Desteklemek için bir <xref:System.ComponentModel.TypeConverter> öznitelik kullanımı iliştirilebilir üyesi için etkin metin sözdizimi geçerli <xref:System.ComponentModel.TypeConverterAttribute> için `Get` *PropertyName* erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="62890-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="62890-177">Uygulama `get` yerine `set` nonintuitive; görünebilir ancak bu kavramı destekler, seri hale getirilebilir salt okunur iliştirilebilir üyesi, olan Tasarımcı senaryolarda yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="62890-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="62890-178">SetPropertyName erişimcisi</span><span class="sxs-lookup"><span data-stu-id="62890-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="62890-179">Küme için imza*PropertyName* erişimcisi olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="62890-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="62890-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="62890-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
- <span data-ttu-id="62890-181">`target` Nesne belirtilebilir, uygulamanızda aynı mantığı ve sonuçları daha belirli bir tür olarak önceki bölümde açıklandığı gibi.</span><span class="sxs-lookup"><span data-stu-id="62890-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
- <span data-ttu-id="62890-182">`value` Nesnesi, uygulamanızdaki daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="62890-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="62890-183">Bu yöntem değeri öznitelik formunda genellikle XAML kullanım gelen giriş olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="62890-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="62890-184">Öznitelik formunda olmalıdır değer dönüştürücü metin söz dizimi desteğini ve şirket özniteliğini `Get` *PropertyName* erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="62890-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="62890-185">İliştirilebilir üye depoları</span><span class="sxs-lookup"><span data-stu-id="62890-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="62890-186">Erişimci metotlarını genellikle bir nesne grafiğine iliştirilebilir üye değerlerinin yerleştirileceği veya Nesne grafiğini değerleri almak ve bunları düzgün bir şekilde serileştirmek için bir yol sağlamak yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="62890-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="62890-187">Bu işlevselliği sağlayacak şekilde `target` önceki erişimci imzalarında nesneleri değerleri depolayabilen özelliğine sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="62890-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="62890-188">Depolama mekanizmasını tutarlı iliştirilebilir üye üye listesinde olduğu hedeflere iliştirilebilir bir üyesidir iliştirilebilir üye ilkesine sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="62890-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="62890-189">.NET framework XAML hizmetlerinde iliştirilebilir üye API'ler aracılığıyla depolayan bir uygulama teknik sağlar <xref:System.Xaml.IAttachedPropertyStore> ve <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="62890-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="62890-190"><xref:System.Xaml.IAttachedPropertyStore> Mağaza uygulamasını bulmak için XAML yazarlar tarafından kullanılır ve olan tür uygulanması gereken `target` erişimcileri.</span><span class="sxs-lookup"><span data-stu-id="62890-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="62890-191">Statik <xref:System.Xaml.AttachablePropertyServices> API'leri erişimcileri gövdesi içinde kullanılır ve iliştirilebilir üyesi tarafından bakın, <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="62890-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="62890-192">XAML ilişkili CLR öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="62890-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="62890-193">Doğru türleri, üyeleri ve derlemeleri öznitelik atanıyor, .NET Framework XAML hizmetlerinde XAML tür sistem bilgileri rapor sırada önemlidir.</span><span class="sxs-lookup"><span data-stu-id="62890-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="62890-194">Bu, türlerinizi .NET Framework XAML Hizmetleri XAML okuyucular ve yazıcılar XAML doğrudan göre XAML sistemleri ile kullanmak istiyorsanız veya tanımlayın veya bu XAML okuyucular ve yazıcılar XAML tabanlı ve XAML kullanan bir framework kullanıyorsanız geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="62890-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="62890-195">XAML özel türlerinizi desteği ile ilgili her XAML ile ilgili bir öznitelik listesi için bkz. [özel türler ve Kitaplıkar için CLR öznitelikleri XAML-Related](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="62890-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="62890-196">Kullanım</span><span class="sxs-lookup"><span data-stu-id="62890-196">Usage</span></span>  
 <span data-ttu-id="62890-197">Özel türleri kullanım, biçimlendirme Yazar özel türü içeren derlemeyi ve CLR ad alanı için bir önek gerekir eşlemenizi gerektirir.</span><span class="sxs-lookup"><span data-stu-id="62890-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="62890-198">Bu yordam, bu konudaki belgelenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="62890-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="62890-199">Erişim düzeyi</span><span class="sxs-lookup"><span data-stu-id="62890-199">Access Level</span></span>  
 <span data-ttu-id="62890-200">XAML yükleme ve türleri oluşturmak için bir yol sağlayan bir `internal` erişim düzeyi.</span><span class="sxs-lookup"><span data-stu-id="62890-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="62890-201">Bu özellik, kullanıcı kodu kendi türlerini tanımlayın ve ardından bu sınıflardan de aynı kullanıcı kod kapsamı parçası biçimlendirme örneği sağlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="62890-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="62890-202">Kullanıcı kodu tanımlar zaman wpf'den bir örnek olduğuna bir <xref:System.Windows.Controls.UserControl> bir kullanıcı Arabirimi davranışı yeniden düzenlemenin yolu, ancak değil destekleyici sınıf ile bildirerek örtük herhangi bir olası uzantı mekanizması bir parçası olarak hedeflenen `public` erişim düzeyi.</span><span class="sxs-lookup"><span data-stu-id="62890-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="62890-203">Böyle bir <xref:System.Windows.Controls.UserControl> ile bildirilen `internal` erişmeye içinden, başvurulan bir XAML türü olarak aynı derlemenin yedekleme kod derlenir.</span><span class="sxs-lookup"><span data-stu-id="62890-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="62890-204">XAML tam güven altında yükler ve kullanan bir uygulama için <xref:System.Xaml.XamlObjectWriter>, sınıflarla yüklenirken `internal` erişim düzeyi her zaman etkindir.</span><span class="sxs-lookup"><span data-stu-id="62890-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="62890-205">Kısmi güven altında XAML yükleyen bir uygulama için erişim düzeyi özellikleri kullanarak denetleyebilirsiniz <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="62890-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="62890-206">Ayrıca, (örneğin, WPF şablonu sistemi) erteleme mekanizmaları herhangi bir erişim düzeyi izinleri yayar ve bunları korumak için son çalışma zamanı değerlendirmeleri olması gerekir; Bu geçirerek dahili olarak işlenir <xref:System.Xaml.Permissions.XamlAccessLevel> bilgileri.</span><span class="sxs-lookup"><span data-stu-id="62890-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="62890-207">WPF uygulaması</span><span class="sxs-lookup"><span data-stu-id="62890-207">WPF Implementation</span></span>  
 <span data-ttu-id="62890-208">WPF XAML kullanan bir kısmi güven erişim modeli kısmi güven altında BAML yüklenirse, erişimin sınırlı olduğu <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> BAML kaynağı derleme.</span><span class="sxs-lookup"><span data-stu-id="62890-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="62890-209">WPF erteleme için kullandığı <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> erişim düzeyi bilgileri geçirmek için bir mekanizma olarak.</span><span class="sxs-lookup"><span data-stu-id="62890-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="62890-210">WPF XAML terminolojisinde, bir *iç tür* başvuruda bulunan bir XAML de içeren aynı derleme tarafından tanımlanan bir tür.</span><span class="sxs-lookup"><span data-stu-id="62890-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="62890-211">Böyle bir türü derleme kasıtlı olarak atlar XAML ad alanı eşlenebilir bir eşleme, örneğin, bir kısmını = `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="62890-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="62890-212">BAML iç tür başvuruyorsa ve türü olduğunu `internal` erişim düzeyi, bu işlem oluşturur. bir `GeneratedInternalTypeHelper` derleme için sınıf.</span><span class="sxs-lookup"><span data-stu-id="62890-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="62890-213">Kaçınmak istiyorsanız `GeneratedInternalTypeHelper`, ya da kullanmalısınız `public` erişim düzeyi, veya ayrı bir derleme içine ilgili sınıfı faktörü ve bu derlemeye bağımlı olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="62890-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="62890-214">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="62890-214">See also</span></span>

- [<span data-ttu-id="62890-215">Özel Türler ve Kitaplıklar İçin XAML İlişkili CLR Öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="62890-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="62890-216">XAML Hizmetleri</span><span class="sxs-lookup"><span data-stu-id="62890-216">XAML Services</span></span>](index.md)

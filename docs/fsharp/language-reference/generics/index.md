---
title: Genel Türler
description: Nasıl kullanacağınızı öğrenin F# genel işlevler ve çeşitli türleri ile kod yinelenen olmadan çalışan kod yazmanızı sağlayan tür.
ms.date: 05/16/2016
ms.openlocfilehash: e30b00343e48d3a8abd51f62c003ba0d1984db18
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/15/2019
ms.locfileid: "65641861"
---
# <a name="generics"></a><span data-ttu-id="1b8b0-103">Genel Türler</span><span class="sxs-lookup"><span data-stu-id="1b8b0-103">Generics</span></span>

<span data-ttu-id="1b8b0-104">F#işlev değerleri, yöntemler, özellikler ve sınıflar gibi toplama türleri kaydeder ve ayrılmış birleşimler olabilir *genel*.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="1b8b0-105">Genel yapılar genellikle genel yapısı, kullanıcı tarafından sağlanan en az bir tür parametresi içerir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="1b8b0-106">Genel işlevler ve türleri çeşitli türleri ile kod her türü için yinelenen olmadan çalışan kod yazmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="1b8b0-107">Kodunuzu genel yapma, basit olabilir F#, genellikle kodunuzu örtük olarak genel olarak derleyicinin tür çıkarımı ve otomatik Genelleştirme düzenekleri tarafından algılanır.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>

## <a name="syntax"></a><span data-ttu-id="1b8b0-108">Sözdizimi</span><span class="sxs-lookup"><span data-stu-id="1b8b0-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="1b8b0-109">Açıklamalar</span><span class="sxs-lookup"><span data-stu-id="1b8b0-109">Remarks</span></span>

<span data-ttu-id="1b8b0-110">Bir açık genel işlev veya tür bildirimi genel olmayan işlev veya tür, işlev veya tür adından sonra köşeli parantez içinde tür parametreleri belirtimi (ve kullanım) dışında benzer.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="1b8b0-111">Bildirimleri genellikle örtük olarak geneldir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="1b8b0-112">Tam olarak bir işlev veya türü oluşturmak için kullanılan her parametresinin türü belirtmezseniz derleyici her parametre, değer ve değişkeni yazdığınız kodun türünü çıkarsamak çalışır.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="1b8b0-113">Daha fazla bilgi için [tür çıkarımı](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="1b8b0-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="1b8b0-114">Kod tür veya işlev için parametre türlerini aksi kısıtlamaz, işlev veya türü örtük olarak genel olur.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="1b8b0-115">Bu işlem adlı *otomatik Genelleştirme*.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="1b8b0-116">Otomatik Genelleştirme üzerinde bazı limitler mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="1b8b0-117">Örneğin, varsa F# derleyici, genel bir yapı için türlerini çıkarması oluşturamıyor, derleyici adlı bir kısıtlamaya başvuran hata raporları *değer kısıtlaması*.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="1b8b0-118">Bu durumda, bazı tür ek açıklamaları eklemeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="1b8b0-119">Otomatik Genelleştirme ve değer kısıtlama ve sorunu çözmek için kodunuzu değiştirme hakkında daha fazla bilgi için bkz. [otomatik Genelleştirme](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="1b8b0-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="1b8b0-120">Önceki sözdiziminde, *tür parametreleri* ne tür olabilir. daha fazla sınırlayan isteğe bağlı olarak bir kısıtlama yan tümcesi ile tek tırnak işareti ile başlayan her biri bir virgülle ayrılmış listesi bilinmeyen türleri temsil eden parametreleri Bu tür parametresi için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="1b8b0-121">Kısıtlama yan tümceleri çeşitli türleri ve kısıtlamalar hakkında diğer bilgiler için sözdizimi için bkz [kısıtlamaları](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="1b8b0-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="1b8b0-122">*Tür tanımı* sözdiziminde genel olmayan bir tür için tür tanımı ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="1b8b0-123">İsteğe bağlı bir sınıf türü için Oluşturucu parametreleri içeren `as` yan tümcesi, eşit sembol, kayıt alanlarını `inherit` yan tümcesi, ayrılmış bir birleşim seçenekleri `let` ve `do` bağlamaları, üye tanımları ve diğer her şey genel olmayan tür tanımında izin verilir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="1b8b0-124">Diğer sözdizimi öğeleri genel olmayan işlevleri ve türleri için aynıdır.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="1b8b0-125">Örneğin, *nesne tanımlayıcısı* içeren nesneyi temsil eden bir tanımlayıcıdır.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="1b8b0-126">Özellikler, alanlar ve oluşturucular daha kapsayan türdeki genel olamaz.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="1b8b0-127">Ayrıca, değerleri bir modülde genel olamaz.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-127">Also, values in a module cannot be generic.</span></span>

## <a name="implicitly-generic-constructs"></a><span data-ttu-id="1b8b0-128">Örtük olarak genel yapılar</span><span class="sxs-lookup"><span data-stu-id="1b8b0-128">Implicitly Generic Constructs</span></span>

<span data-ttu-id="1b8b0-129">Zaman F# derleyici, kodunuzdaki türleri algılar, otomatik olarak genel genel herhangi bir işlev değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="1b8b0-130">Bir tür gibi bir parametre türü, açıkça belirtirseniz otomatik Genelleştirme engeller.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="1b8b0-131">Aşağıdaki kod örneğinde, `makeList` olsa da ne parametrelerini açıkça genel olarak bildirilen geneldir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="1b8b0-132">İşlev imzası olmasını algılanır `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="1b8b0-133">Unutmayın `a` ve `b` Bu örnekte, aynı türe sahip için algılanır.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="1b8b0-134">Bunlar bir listede birlikte eklenir ve tüm öğeleri aynı türde olmalıdır çünkü budur.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="1b8b0-135">Ayrıca bir işlev bir parametre türü bir genel tür parametresi olduğunu belirtmek için bir tür ek açıklaması içinde tek tırnak işareti sözdizimi kullanılarak genel yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="1b8b0-136">Aşağıdaki kodda, `function1` türü parametreleri olarak bu şekilde, parametrelerini bildirilen için geneldir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]

## <a name="explicitly-generic-constructs"></a><span data-ttu-id="1b8b0-137">Açıkça genel yapılar</span><span class="sxs-lookup"><span data-stu-id="1b8b0-137">Explicitly Generic Constructs</span></span>

<span data-ttu-id="1b8b0-138">Ayrıca bir işlevi köşeli parantez içinde tür parametrelerinden biri açıkça bildirerek genel yapabilirsiniz (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="1b8b0-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="1b8b0-139">Aşağıdaki kod bunu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]

## <a name="using-generic-constructs"></a><span data-ttu-id="1b8b0-140">Genel oluşturur</span><span class="sxs-lookup"><span data-stu-id="1b8b0-140">Using Generic Constructs</span></span>

<span data-ttu-id="1b8b0-141">Genel işlevleri veya yöntemleri kullandığınızda, tür bağımsız değişkenlerini belirtmek olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="1b8b0-142">Derleyicinin tür çıkarımı uygun tür bağımsız değişkenlerini çıkarsamak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="1b8b0-143">Hala bir belirsizlik ise, tür bağımsız değişkenleri köşeli parantez içinde birden çok tür bağımsız değişkenleri virgülle ayırarak sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="1b8b0-144">Aşağıdaki kod, önceki bölümde tanımlanan işlevlerin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]

> [!NOTE]
> <span data-ttu-id="1b8b0-145">Ada göre bir genel türe başvurmak amacıyla iki yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="1b8b0-146">Örneğin, `list<int>` ve `int list` genel bir türe başvurmak için kullanabileceğiniz iki yöntemdir `list` tek tür bağımsız değişkeni olan `int`.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="1b8b0-147">İkinci form genel yalnızca yerleşik ile kullanılan F# gibi türleri `list` ve `option`.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="1b8b0-148">Birden çok tür bağımsız değişkeni varsa, söz dizimi normalde kullandığınız `Dictionary<int, string>` söz dizimi de kullanabilirsiniz, ancak `(int, string) Dictionary`.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="1b8b0-149">Joker karakter tür bağımsız değişkenleri olarak</span><span class="sxs-lookup"><span data-stu-id="1b8b0-149">Wildcards as Type Arguments</span></span>

<span data-ttu-id="1b8b0-150">Tür bağımsız değişkeni derleyici tarafından çıkarılmamalıdır belirtmek için alt çizgi veya joker karakter sembolünü kullanabilirsiniz (`_`), yerine adlandırılmış tür bağımsız değişkeni.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="1b8b0-151">Bu aşağıdaki kod gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]

## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="1b8b0-152">Sınırlamalar genel türler ve İşlevler</span><span class="sxs-lookup"><span data-stu-id="1b8b0-152">Constraints in Generic Types and Functions</span></span>

<span data-ttu-id="1b8b0-153">Genel tür veya işlev tanımı, genel tür parametresinde kullanılabilir olduğu bilinen yapıları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="1b8b0-154">Bu, derleme zamanında işlevi ve yöntem çağrılarının doğrulamayı etkinleştirmek için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="1b8b0-155">Kendi tür parametreleri açıkça bildirirseniz, derleyici belirli yöntemleri ve işlevleri mevcut olduğunu bildirmek için bir genel tür parametresi açık bir kısıtlaması uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="1b8b0-156">Ancak, izin verirseniz F# derleyici, genel parametre türlerini çıkarması sizin için uygun kısıtlamaları belirler.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="1b8b0-157">Daha fazla bilgi için [kısıtlamaları](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="1b8b0-157">For more information, see [Constraints](constraints.md).</span></span>

## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="1b8b0-158">Statik Olarak Çözümlenmiş Tür Parametreleri</span><span class="sxs-lookup"><span data-stu-id="1b8b0-158">Statically Resolved Type Parameters</span></span>

<span data-ttu-id="1b8b0-159">İki tür kullanılabilir tür parametrelerinin F# programlar.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="1b8b0-160">İlk tür önceki bölümlerde açıklanan genel tür parametreleri olan.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="1b8b0-161">Tür parametresini ilk bu tür, Visual Basic ve C# gibi dillerde kullanılan genel tür parametreleri eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="1b8b0-162">Başka bir tür parametresi tür özeldir F# ve şeklinde adlandırılan bir *statik olarak çözümlenmiş tür parametresi*.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="1b8b0-163">Bu yapılar hakkında daha fazla bilgi için bkz. [statik olarak çözümlenmiş tür Parametreleri'nde](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="1b8b0-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>

## <a name="examples"></a><span data-ttu-id="1b8b0-164">Örnekler</span><span class="sxs-lookup"><span data-stu-id="1b8b0-164">Examples</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]

## <a name="see-also"></a><span data-ttu-id="1b8b0-165">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="1b8b0-165">See also</span></span>

- [<span data-ttu-id="1b8b0-166">Dil Başvurusu</span><span class="sxs-lookup"><span data-stu-id="1b8b0-166">Language Reference</span></span>](../index.md)
- [<span data-ttu-id="1b8b0-167">Türler</span><span class="sxs-lookup"><span data-stu-id="1b8b0-167">Types</span></span>](../fsharp-types.md)
- [<span data-ttu-id="1b8b0-168">Statik Olarak Çözümlenmiş Tür Parametreleri</span><span class="sxs-lookup"><span data-stu-id="1b8b0-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)
- [<span data-ttu-id="1b8b0-169">.NET Framework'teki genel türler</span><span class="sxs-lookup"><span data-stu-id="1b8b0-169">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)
- [<span data-ttu-id="1b8b0-170">Otomatik Genelleştirme</span><span class="sxs-lookup"><span data-stu-id="1b8b0-170">Automatic Generalization</span></span>](automatic-generalization.md)
- [<span data-ttu-id="1b8b0-171">Kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="1b8b0-171">Constraints</span></span>](constraints.md)

---
title: Genel Türler
description: Kod tekrarlamadan farklı F# türlerle çalışacak kod yazmanızı sağlayan genel işlevleri ve türleri nasıl kullanacağınızı öğrenin.
ms.date: 05/16/2016
ms.openlocfilehash: 47eed0b8e074cfb591e6d8e2c382b9ea6a6e97f0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630617"
---
# <a name="generics"></a><span data-ttu-id="5ad31-103">Genel Türler</span><span class="sxs-lookup"><span data-stu-id="5ad31-103">Generics</span></span>

<span data-ttu-id="5ad31-104">F#işlev değerleri, Yöntemler, Özellikler ve sınıflar, kayıtlar ve ayırt edici birleşimler gibi toplama türleri *genel*olabilir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="5ad31-105">Genel yapılar, genellikle genel yapının kullanıcısı tarafından sağlanan en az bir tür parametresi içerir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="5ad31-106">Genel işlevler ve türler, her tür için kodu tekrarlamadan çeşitli türlerle birlikte çalışarak kod yazmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ad31-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="5ad31-107">Kodunuzun genel olması F#, genellikle kodunuzun tür çıkarımı ve otomatik Genelleştirme mekanizmaları tarafından genel olarak açıkça çıkarsandığı için, kodunuzun genel hale getirilmesi basit olabilir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>

## <a name="syntax"></a><span data-ttu-id="5ad31-108">Sözdizimi</span><span class="sxs-lookup"><span data-stu-id="5ad31-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="5ad31-109">Açıklamalar</span><span class="sxs-lookup"><span data-stu-id="5ad31-109">Remarks</span></span>

<span data-ttu-id="5ad31-110">Açık bir genel işlevin veya türün bildirimi, tür parametrelerinin belirtimi (ve kullanımı) dışında, işlev veya tür adından sonra açılı ayraçlar olarak genel olmayan bir işlev veya türden çok benzer.</span><span class="sxs-lookup"><span data-stu-id="5ad31-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="5ad31-111">Bildirimler genellikle dolaylı olarak geneldir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="5ad31-112">Bir işlev veya tür oluşturmak için kullanılan her parametrenin türünü tam olarak belirtmezseniz, derleyici her bir parametre, değer ve değişkenin türünü yazdığınız koddan çıkarmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="5ad31-113">Daha fazla bilgi için bkz. [tür çıkarımı](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="5ad31-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="5ad31-114">Tür veya işlevinizin kodu başka türlü parametre türlerini sınırlandırmadığından, işlev veya tür örtülü olarak geneldir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="5ad31-115">Bu işlem *Otomatik Genelleştirme*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="5ad31-116">Otomatik Genelleştirme üzerinde bazı sınırlar vardır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="5ad31-117">Örneğin, F# derleyici genel bir yapının türlerini çıkarsanamıyor, derleyici *değer kısıtlaması*adlı bir kısıtlamaya başvuran bir hata bildirir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="5ad31-118">Bu durumda bazı tür ek açıklamalarını eklemeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="5ad31-119">Otomatik Genelleştirme ve değer kısıtlaması hakkında daha fazla bilgi ve sorunu gidermek için kodunuzun nasıl değiştirileceği hakkında daha fazla bilgi için bkz. [Otomatik Genelleştirme](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="5ad31-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="5ad31-120">Önceki sözdiziminde, *tür parametreleri* , her biri tek tırnak işaretiyle başlayan ve isteğe bağlı olarak, bu tür için kullanılabilecek türleri daha fazla sınırlayan bir kısıtlama yan tümcesi içeren, virgülle ayrılmış parametrelerin bir listesidir. parametresinin.</span><span class="sxs-lookup"><span data-stu-id="5ad31-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="5ad31-121">Çeşitli türlerdeki kısıtlama yan tümcelerinin sözdizimi ve kısıtlamalar hakkında diğer bilgiler için bkz. [kısıtlamalar](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="5ad31-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="5ad31-122">Söz diziminde *tür tanımı* genel olmayan bir türün tür tanımıyla aynıdır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="5ad31-123">Bir sınıf türü için Oluşturucu `as` parametrelerini, isteğe bağlı bir yan tümceyi, eşittir sembolünü, kayıt alanlarını `inherit` , yan tümcesini, ayrılmış `let` bir Union için seçimleri, ve `do` bağlamaları, üye tanımlarını içerir ve genel olmayan tür tanımında izin verilen başka bir şey.</span><span class="sxs-lookup"><span data-stu-id="5ad31-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="5ad31-124">Diğer sözdizimi öğeleri, genel olmayan işlevler ve türler için olanlarla aynıdır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="5ad31-125">Örneğin, *nesne tanımlayıcısı* kapsayan nesnenin kendisini temsil eden bir tanıtıcıdır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="5ad31-126">Özellikler, alanlar ve oluşturucular kapsayan türden daha genel olamaz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="5ad31-127">Ayrıca, modüldeki değerler genel olamaz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-127">Also, values in a module cannot be generic.</span></span>

## <a name="implicitly-generic-constructs"></a><span data-ttu-id="5ad31-128">Örtük genel yapılar</span><span class="sxs-lookup"><span data-stu-id="5ad31-128">Implicitly Generic Constructs</span></span>

<span data-ttu-id="5ad31-129">F# Derleyici kodunuzda türleri kodaldığında, genel olarak genel olabilecek tüm işlevleri otomatik olarak değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="5ad31-130">Parametre türü gibi açıkça bir tür belirtirseniz, otomatik genelleştirmeyi engelleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="5ad31-131">Aşağıdaki kod örneğinde, `makeList` , veya parametreleri açıkça genel olarak bildirildiği halde, geneldir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="5ad31-132">İşlevin imzası olarak algılanır `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="5ad31-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="5ad31-133">Bu örnekte `a` ve `b` aynı türe sahip olacak şekilde algılanır olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5ad31-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="5ad31-134">Bunun nedeni, bir listeye birlikte dahil edilmeleri ve bir listenin tüm öğeleri aynı türde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="5ad31-135">Ayrıca bir parametre türünün genel bir tür parametresi olduğunu göstermek için bir tür ek açıklamasında tek tırnak işareti sözdizimini kullanarak bir işlevi genel hale getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="5ad31-136">Aşağıdaki kodda `function1` , parametreleri tür parametreleri olarak bu şekilde bildirildiği için geneldir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]

## <a name="explicitly-generic-constructs"></a><span data-ttu-id="5ad31-137">Açık genel yapılar</span><span class="sxs-lookup"><span data-stu-id="5ad31-137">Explicitly Generic Constructs</span></span>

<span data-ttu-id="5ad31-138">Ayrıca, tür parametrelerini açılı ayraçlar (`<type-parameter>`) içinde açıkça bildirerek bir işlevi genel hale getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="5ad31-139">Aşağıdaki kod bunu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]

## <a name="using-generic-constructs"></a><span data-ttu-id="5ad31-140">Genel yapıları kullanma</span><span class="sxs-lookup"><span data-stu-id="5ad31-140">Using Generic Constructs</span></span>

<span data-ttu-id="5ad31-141">Genel işlevleri veya yöntemleri kullandığınızda, tür bağımsız değişkenlerini belirtmeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="5ad31-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="5ad31-142">Derleyici, uygun tür bağımsız değişkenlerini çıkarması için tür çıkarımı kullanır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="5ad31-143">Hala bir belirsizlik varsa, birden fazla tür bağımsız değişkenini virgülle ayırarak, açılı ayraç içinde tür bağımsız değişkenleri sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="5ad31-144">Aşağıdaki kod, önceki bölümlerde tanımlanan işlevlerin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]

> [!NOTE]
> <span data-ttu-id="5ad31-145">Ada göre genel bir türe başvurmanın iki yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="5ad31-146">Örneğin, `list<int>` ve `int list` tek bir tür bağımsız değişkenine `int`sahip genel bir türe `list` başvurmak için iki yol vardır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="5ad31-147">İkinci form, genel olarak gibi F# `list` `option`yalnızca yerleşik türler ile kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="5ad31-148">Birden çok tür bağımsız değişkeni varsa, normalde söz dizimini `Dictionary<int, string>` kullanırsınız, ancak sözdizimini `(int, string) Dictionary`de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="5ad31-149">Tür bağımsız değişkenleri olarak joker karakterler</span><span class="sxs-lookup"><span data-stu-id="5ad31-149">Wildcards as Type Arguments</span></span>

<span data-ttu-id="5ad31-150">Derleyici tarafından bir tür bağımsız değişkeninin çıkarsanın belirtmek için, adlandırılmış tür bağımsız değişkeni yerine alt çizgi veya joker karakter sembolünü`_`() kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="5ad31-151">Bu, aşağıdaki kodda gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]

## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="5ad31-152">Genel türlerde ve Işlevlerde kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="5ad31-152">Constraints in Generic Types and Functions</span></span>

<span data-ttu-id="5ad31-153">Genel tür veya işlev tanımında, yalnızca genel tür parametresinde kullanılabilir olan bilinen yapıları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="5ad31-154">Bu, derleme zamanında işlev ve yöntem çağrılarının doğrulanmasını etkinleştirmek için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="5ad31-155">Tür parametrelerinizi açıkça bildirirseniz, derleyiciye belirli yöntemlerin ve işlevlerin kullanılabildiğini bildirmek için genel bir tür parametresine açık bir kısıtlama uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="5ad31-156">Ancak, F# derleyicinin genel parametre türlerinizi çıkarması için izin verirseniz, sizin için uygun kısıtlamaları saptacaktır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="5ad31-157">Daha fazla bilgi için bkz. [kısıtlamalar](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="5ad31-157">For more information, see [Constraints](constraints.md).</span></span>

## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="5ad31-158">Statik Olarak Çözümlenmiş Tür Parametreleri</span><span class="sxs-lookup"><span data-stu-id="5ad31-158">Statically Resolved Type Parameters</span></span>

<span data-ttu-id="5ad31-159">F# Programlarda kullanılabilecek iki tür parametre vardır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="5ad31-160">İlki, önceki bölümlerde açıklanan türün genel tür parametreleridir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="5ad31-161">Bu ilk tür parametresi, Visual Basic ve C#gibi dillerde kullanılan genel tür parametrelerine eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="5ad31-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="5ad31-162">Başka türde bir tür parametresi öğesine F# özeldir ve statik olarak çözümlenen bir *tür parametresi*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="5ad31-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="5ad31-163">Bu yapılar hakkında daha fazla bilgi için bkz. [statik çözümlenen tür parametreleri](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="5ad31-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>

## <a name="examples"></a><span data-ttu-id="5ad31-164">Örnekler</span><span class="sxs-lookup"><span data-stu-id="5ad31-164">Examples</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]

## <a name="see-also"></a><span data-ttu-id="5ad31-165">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="5ad31-165">See also</span></span>

- [<span data-ttu-id="5ad31-166">Dil Başvurusu</span><span class="sxs-lookup"><span data-stu-id="5ad31-166">Language Reference</span></span>](../index.md)
- [<span data-ttu-id="5ad31-167">Türler</span><span class="sxs-lookup"><span data-stu-id="5ad31-167">Types</span></span>](../fsharp-types.md)
- [<span data-ttu-id="5ad31-168">Statik Olarak Çözümlenmiş Tür Parametreleri</span><span class="sxs-lookup"><span data-stu-id="5ad31-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)
- [<span data-ttu-id="5ad31-169">.NET Framework genel türler</span><span class="sxs-lookup"><span data-stu-id="5ad31-169">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)
- [<span data-ttu-id="5ad31-170">Otomatik Genelleştirme</span><span class="sxs-lookup"><span data-stu-id="5ad31-170">Automatic Generalization</span></span>](automatic-generalization.md)
- [<span data-ttu-id="5ad31-171">Kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="5ad31-171">Constraints</span></span>](constraints.md)

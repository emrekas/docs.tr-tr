---
title: Değerler
description: İçindeki F# değerlerin belirli bir türe sahip miktarlar olduğunu öğrenin.
ms.date: 05/16/2016
ms.openlocfilehash: ed7a5b069a5a47aacf0cce4cfa754ded46f6e84a
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630792"
---
# <a name="values"></a><span data-ttu-id="781aa-103">Değerler</span><span class="sxs-lookup"><span data-stu-id="781aa-103">Values</span></span>

<span data-ttu-id="781aa-104">İçindeki F# değerler belirli bir türe sahip olan miktarlardır; değerler tamsayı veya kayan nokta sayıları, karakterler veya metin, listeler, sıralar, diziler, tanımlama grupları, ayırt edici birleşimler, kayıtlar, sınıf türleri veya işlev değerleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="781aa-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>

## <a name="binding-a-value"></a><span data-ttu-id="781aa-105">Değer bağlama</span><span class="sxs-lookup"><span data-stu-id="781aa-105">Binding a Value</span></span>

<span data-ttu-id="781aa-106">*Bağlama* terimi, bir adı tanımıyla ilişkilendirme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="781aa-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="781aa-107">`let` Anahtar sözcüğü, aşağıdaki örneklerde olduğu gibi bir değeri bağlar:</span><span class="sxs-lookup"><span data-stu-id="781aa-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="781aa-108">Bir değerin türü tanımdan algılanır.</span><span class="sxs-lookup"><span data-stu-id="781aa-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="781aa-109">İntegral veya kayan noktalı sayı gibi temel bir tür için, tür değişmez değer türünden belirlenir.</span><span class="sxs-lookup"><span data-stu-id="781aa-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="781aa-110">Bu nedenle, `b` önceki örnekte, derleyici `unsigned int`türünü olarak algılar, ancak derleyici türünü `a` `int`olarak algılar.</span><span class="sxs-lookup"><span data-stu-id="781aa-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="781aa-111">İşlev değerinin türü, işlev gövdesindeki dönüş değerinden belirlenir.</span><span class="sxs-lookup"><span data-stu-id="781aa-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="781aa-112">İşlev değeri türleri hakkında daha fazla bilgi için bkz. [işlevler](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="781aa-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="781aa-113">Değişmez türler hakkında daha fazla bilgi için bkz. [değişmez değerler](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="781aa-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="781aa-114">Derleyici, varsayılan olarak kullanılmayan bağlamalar hakkında tanılama vermiyor.</span><span class="sxs-lookup"><span data-stu-id="781aa-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="781aa-115">Bu iletileri almak için, proje dosyanızda veya derleyicisini çağırırken uyarı 1182 ' yı etkinleştirin (bkz `--warnon` . [derleyici seçenekleri](../compiler-options.md)altında).</span><span class="sxs-lookup"><span data-stu-id="781aa-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="781aa-116">Neden sabit?</span><span class="sxs-lookup"><span data-stu-id="781aa-116">Why Immutable?</span></span>

<span data-ttu-id="781aa-117">Sabit değerler, bir programın yürütülmesi sırasında değiştirilemeyen değerlerdir.</span><span class="sxs-lookup"><span data-stu-id="781aa-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="781aa-118">C++, Visual Basic veya C#gibi dillerde kullandıysanız, bir programın yürütülmesi sırasında yeni değerler atanabileceği değişkenler yerine, sabit değerler üzerinde en fazla değer elde eden değişken olduğunu F# fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="781aa-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="781aa-119">Değişmez veriler fonksiyonel Programlamanın önemli bir öğesidir.</span><span class="sxs-lookup"><span data-stu-id="781aa-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="781aa-120">Çok iş parçacıklı bir ortamda, birçok farklı iş parçacığı tarafından değiştirilebilen paylaşılan kesilebilir değişkenlerin yönetilmesi zordur.</span><span class="sxs-lookup"><span data-stu-id="781aa-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="781aa-121">Ayrıca, değişebilir değişkenlerle, bazı durumlarda bir değişkenin başka bir işleve geçirildiğinde değiştirilip değiştirilemeyeceğini söylemek zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="781aa-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="781aa-122">Saf işlevsel dillerde değişken yoktur ve işlevler kesinlikle matematik işlevleri olarak davranır.</span><span class="sxs-lookup"><span data-stu-id="781aa-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="781aa-123">Bir yordamsal dildeki kodun bir değeri değiştirmek için değişken atamasını kullanması durumunda, işlevsel dildeki denk kodun girdi, sabit bir işlev ve çıkış olarak farklı sabit değerler olan sabit bir değeri vardır.</span><span class="sxs-lookup"><span data-stu-id="781aa-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="781aa-124">Bu matematiksel striclük, programın davranışı hakkında daha sıkı bir yaklaşım sağlar.</span><span class="sxs-lookup"><span data-stu-id="781aa-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="781aa-125">Bu iyileştirme, derleyicilerin kodu daha kolay bir şekilde denetlemesini ve daha etkili bir şekilde iyileştirmesini sağlar ve geliştiricilerin doğru kodu anlamasına ve yazmasını kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="781aa-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="781aa-126">İşlevsel kodun, normal yordamsal koddan hata ayıklamanın daha kolay olması olasıdır.</span><span class="sxs-lookup"><span data-stu-id="781aa-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="781aa-127">F#, saf işlevsel bir dil değildir, ancak işlevsel programlamayı tam olarak destekler.</span><span class="sxs-lookup"><span data-stu-id="781aa-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="781aa-128">Bu işlemin yapılması, kodunuzun işlevsel programlama açısından önemli bir yönden yararlanmasına olanak sağladığından, sabit değerlerin kullanılması iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="781aa-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>

## <a name="mutable-variables"></a><span data-ttu-id="781aa-129">Değişebilir değişkenler</span><span class="sxs-lookup"><span data-stu-id="781aa-129">Mutable Variables</span></span>

<span data-ttu-id="781aa-130">Değiştirilebilecek bir değişken belirtmek için `mutable` anahtar sözcüğünü kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="781aa-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="781aa-131">' Deki F# kesilebilir değişkenlerin, genellikle bir tür alanı veya yerel değer olarak sınırlı bir kapsamı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="781aa-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="781aa-132">Sınırlı bir kapsama sahip kesilebilir değişkenlerin denetimi daha kolaydır ve yanlış yollarla değiştirilmesinin daha düşüktür.</span><span class="sxs-lookup"><span data-stu-id="781aa-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="781aa-133">`let` Anahtar sözcüğünü bir değer tanımladığınız şekilde kullanarak, değişebilir bir değişkene bir başlangıç değeri atayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="781aa-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="781aa-134">Bununla birlikte, aşağıdaki örnekte olduğu gibi `<-` işleci kullanarak değiştirilebilir değişkenlere daha sonra yeni değerler atayabilmeniz fark olur.</span><span class="sxs-lookup"><span data-stu-id="781aa-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="781aa-135">Oluşturucular gibi `mutable` kapanışları `'a ref` oluşturan formlar da dahil olmak üzere, işaretlenen değerler otomatik olarak bir kapanış tarafından yakalanarak yükseltilir. `seq`</span><span class="sxs-lookup"><span data-stu-id="781aa-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="781aa-136">Bu gerçekleştiğinde size bildirilmesini istiyorsanız, proje dosyanızda veya derleyicisini çağırırken uyarı 3180 ' yı etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="781aa-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>

## <a name="related-topics"></a><span data-ttu-id="781aa-137">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="781aa-137">Related Topics</span></span>

|<span data-ttu-id="781aa-138">Başlık</span><span class="sxs-lookup"><span data-stu-id="781aa-138">Title</span></span>|<span data-ttu-id="781aa-139">Açıklama</span><span class="sxs-lookup"><span data-stu-id="781aa-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="781aa-140">let Bağlamaları</span><span class="sxs-lookup"><span data-stu-id="781aa-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="781aa-141">Adları değerlere ve işlevlere bağlamak `let` için anahtar sözcüğünü kullanma hakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="781aa-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="781aa-142">İşlevler</span><span class="sxs-lookup"><span data-stu-id="781aa-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="781aa-143">İçindeki F#işlevlere genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="781aa-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="781aa-144">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="781aa-144">See also</span></span>

- [<span data-ttu-id="781aa-145">Null Değerler</span><span class="sxs-lookup"><span data-stu-id="781aa-145">Null Values</span></span>](null-Values.md)
- [<span data-ttu-id="781aa-146">F# Dili Başvurusu</span><span class="sxs-lookup"><span data-stu-id="781aa-146">F# Language Reference</span></span>](../index.md)

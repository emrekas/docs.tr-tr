---
title: Derleyici Hatası CS1612
ms.date: 07/20/2015
f1_keywords:
- CS1612
helpviewer_keywords:
- CS1612
ms.assetid: ef5db985-030a-4f15-b53f-e92c9297c6a3
ms.openlocfilehash: 2141de834a7dffb2bb519fbce0343887668f46c8
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61668893"
---
# <a name="compiler-error-cs1612"></a><span data-ttu-id="ba5e9-102">Derleyici Hatası CS1612</span><span class="sxs-lookup"><span data-stu-id="ba5e9-102">Compiler Error CS1612</span></span>
<span data-ttu-id="ba5e9-103">Bir değişken olmadığından 'expression' dönüş değeri değiştirilemiyor</span><span class="sxs-lookup"><span data-stu-id="ba5e9-103">Cannot modify the return value of 'expression' because it is not a variable</span></span>  
  
 <span data-ttu-id="ba5e9-104">Ara bir ifadenin sonucu olarak oluşturulan ancak bir değişkende depolanmayan bir değer türünü değiştirmek için girişimde bulunuldu.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-104">An attempt was made to modify a value type that is produced as the result of an intermediate expression but is not stored in a variable.</span></span> <span data-ttu-id="ba5e9-105">Aşağıdaki örnekte gösterildiği gibi genel bir koleksiyon bir yapıda doğrudan değiştirme girişimi olduğunda bu hata oluşabilir:</span><span class="sxs-lookup"><span data-stu-id="ba5e9-105">This error can occur when you attempt to directly modify a struct in a generic collection, as shown in the following example:</span></span>  
  
```csharp  
List<myStruct> list = {…};  
list[0].Name = "MyStruct42"; //CS1612  
```  
  
 <span data-ttu-id="ba5e9-106">Struct değiştirmek için önce yerel bir değişkene atayın, değişkeni değiştirmek ve değişken arka koleksiyondaki bir öğenin atayın.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-106">To modify the struct, first assign it to a local variable, modify the variable, then assign the variable back to the item in the collection.</span></span>  
  
```csharp  
List<myStruct> list = {…};  
MyStruct ms = list[0];  
ms.Name = "MyStruct42";  
list[0] = ms;  
```  
  
 <span data-ttu-id="ba5e9-107">Değer türleri üzerinde atama kopyalanır. Bu hata oluşur.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-107">This error occurs because value types are copied on assignment.</span></span> <span data-ttu-id="ba5e9-108">Bir değer türü bir özellik veya dizin aldığınızda değil nesnesine bir başvuru nesnesinin bir kopyasını hazırlanıyoruz.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-108">When you retrieve a value type from a property or indexer, you are getting a copy of the object, not a reference to the object itself.</span></span> <span data-ttu-id="ba5e9-109">Aslında yöntemleri, depolama konumları (değişken) oldukları için döndürülen kopyalama özelliği veya dizin oluşturucu tarafından depolanmaz.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-109">The copy that is returned is not stored by the property or indexer because they are actually methods, not storage locations (variables).</span></span> <span data-ttu-id="ba5e9-110">Bir değişken kopyaladığınız depolaması gereken değişiklik yapmadan önce bildirin.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-110">You must store the copy into a variable that you declare before you can modify it.</span></span>  
  
 <span data-ttu-id="ba5e9-111">Hata, çünkü bu durumda bir özellik veya dizin oluşturucu bir depolama konumu varolan bir nesneye bir başvuru döndürür. başvuru türleri için gerçekleşmez.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-111">The error does not occur with reference types because a property or indexer in that case returns a reference to an existing object, which is a storage location.</span></span>  
  
 <span data-ttu-id="ba5e9-112">Sınıfın veya yapının tanımlıyorsanız, bir yapının üyelerine erişim sağlamak için özellik bildirimini değiştirerek bu hatayı çözebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-112">If you are defining the class or struct, you can resolve this error by modifying your property declaration to provide access to the members of a struct.</span></span> <span data-ttu-id="ba5e9-113">İstemci kod yazıyorsanız, yapısı kendi örneğini oluşturarak, alanlarını değiştirerek ve ardından struct'ın tamamını geri özelliğine atama hatayı çözebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-113">If you are writing client code, you can resolve the error by creating your own instance of the struct, modifying its fields, and then assigning the entire struct back to the property.</span></span> <span data-ttu-id="ba5e9-114">Üçüncü bir alternatif olarak, bir sınıf, yapı değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-114">As a third alternative, you can change your struct to a class.</span></span>  
  
## <a name="example"></a><span data-ttu-id="ba5e9-115">Örnek</span><span class="sxs-lookup"><span data-stu-id="ba5e9-115">Example</span></span>  
 <span data-ttu-id="ba5e9-116">Aşağıdaki örnekte gösterildiği gibi bir yapı üyesi döndüren struct'ın tamamını kapsayan sınıfta bir özellik üzerinden erişmeyi denediğinde CS1612 de oluşur:</span><span class="sxs-lookup"><span data-stu-id="ba5e9-116">CS1612 also occurs when you attempt to access the member of a struct through a property on an enclosing class that is returning the entire struct, as shown in the following example:</span></span>  
  
```csharp  
// CS1612.cs  
using System;  
  
public struct MyStruct  
{  
    public int Width;  
}  
  
public class ListView  
{  
    MyStruct ms;  
    public MyStruct Size  
    {  
        get { return ms; }  
        set { ms = value; }  
    }  
}  
  
public class MyClass  
{  
    public MyClass()  
    {  
        ListView lvi;  
        lvi = new ListView();  
        lvi.Size.Width = 5; // CS1612  
  
        // You can use the following lines instead.  
        // MyStruct ms;  
        // ms.Width = 5;  
        // lvi.Size = ms;  // CS1612  
    }  
  
    public static void Main()   
    {  
        MyClass mc = new MyClass();  
        // Keep the console open in debug mode.  
        Console.WriteLine("Press any key to exit.");  
        Console.ReadKey();     
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="ba5e9-117">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="ba5e9-117">See also</span></span>

- [<span data-ttu-id="ba5e9-118">Yapılar</span><span class="sxs-lookup"><span data-stu-id="ba5e9-118">Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/structs.md)
- [<span data-ttu-id="ba5e9-119">Değer Türleri</span><span class="sxs-lookup"><span data-stu-id="ba5e9-119">Value Types</span></span>](../../../csharp/language-reference/keywords/value-types.md)
- [<span data-ttu-id="ba5e9-120">Başvuru Türleri</span><span class="sxs-lookup"><span data-stu-id="ba5e9-120">Reference Types</span></span>](../../../csharp/language-reference/keywords/reference-types.md)

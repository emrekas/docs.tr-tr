---
title: Sınıflar ve nesneler C# -Turu C# dil
description: Yeni C#? Bu sınıflar, nesneleri ve devralma bakış okuyun
ms.date: 08/10/2016
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: 36def74888f67dfa216cea7c093d80724e452c7b
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/22/2019
ms.locfileid: "59976410"
---
# <a name="classes-and-objects"></a><span data-ttu-id="01d76-104">Sınıflar ve nesneler</span><span class="sxs-lookup"><span data-stu-id="01d76-104">Classes and objects</span></span>

<span data-ttu-id="01d76-105">*Sınıflar* , en temel olan C#'s türleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="01d76-106">Bir sınıf durumu (alanlar) ve işlemleri (yöntemler ve diğer işlev üyeleri) bir araya getiren bir veri yapısı içinde tek bir birimdir.</span><span class="sxs-lookup"><span data-stu-id="01d76-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="01d76-107">Dinamik olarak oluşturulan için bir sınıf tanımı sağlar *örnekleri* olarak da bilinen, sınıfın *nesneleri*.</span><span class="sxs-lookup"><span data-stu-id="01d76-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="01d76-108">Destek sınıfları *devralma* ve *çok biçimlilik*, mekanizmaları yapabildiği *türetilmiş sınıflar* genişletmek ve uzmanlaşmış *temel sınıflar*.</span><span class="sxs-lookup"><span data-stu-id="01d76-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="01d76-109">Yeni sınıflar, sınıf bildirimi kullanarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="01d76-109">New classes are created using class declarations.</span></span> <span data-ttu-id="01d76-110">Bir sınıf bildiriminin öznitelikleri ve sınıfı değiştiricileri, sınıf, taban sınıf (belirtilmişse) ve bir sınıf tarafından uygulanan arabirimler adını belirten bir üst bilgisi ile başlar.</span><span class="sxs-lookup"><span data-stu-id="01d76-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="01d76-111">Başlık sınırlayıcılar arasında yazılan üye bildirimleri listesini içeren sınıf gövdesinin arkasından `{` ve `}`.</span><span class="sxs-lookup"><span data-stu-id="01d76-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="01d76-112">Adlı basit bir sınıf bildirimi verilmiştir `Point`:</span><span class="sxs-lookup"><span data-stu-id="01d76-112">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="01d76-113">Sınıfların örneklerini kullanılarak oluşturulur `new` yeni bir örneği için bellek ayırır, işleci örneği başlatmak için bir oluşturucu çağırır ve örneğe bir başvuru döndürür.</span><span class="sxs-lookup"><span data-stu-id="01d76-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="01d76-114">Aşağıdaki deyimleri, iki nokta nesneleri oluşturmak ve bu nesnelere başvurular iki değişken depolamak:</span><span class="sxs-lookup"><span data-stu-id="01d76-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="01d76-115">Nesnenin artık erişilebilir olduğunda otomatik olarak bir nesnenin kapladığı belleği geri kazanılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="01d76-116">Bu, gerekli veya C# nesneler açıkça serbest mümkün olur.</span><span class="sxs-lookup"><span data-stu-id="01d76-116">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="01d76-117">Üyeler</span><span class="sxs-lookup"><span data-stu-id="01d76-117">Members</span></span>

<span data-ttu-id="01d76-118">Statik üye veya örnek üyeleri bir sınıf üyeleridir.</span><span class="sxs-lookup"><span data-stu-id="01d76-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="01d76-119">Statik üyeleri sınıflarına ait ve örnek üyeleri (sınıfların örneklerini) nesnelere ait.</span><span class="sxs-lookup"><span data-stu-id="01d76-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="01d76-120">Aşağıdaki türde üye bir sınıf içeren genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="01d76-120">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="01d76-121">Sabitler</span><span class="sxs-lookup"><span data-stu-id="01d76-121">Constants</span></span>
  - <span data-ttu-id="01d76-122">Sınıf ile ilişkili olan sabit değerler</span><span class="sxs-lookup"><span data-stu-id="01d76-122">Constant values associated with the class</span></span>
* <span data-ttu-id="01d76-123">Alanlar</span><span class="sxs-lookup"><span data-stu-id="01d76-123">Fields</span></span>
  - <span data-ttu-id="01d76-124">Sınıfın değişkenleri</span><span class="sxs-lookup"><span data-stu-id="01d76-124">Variables of the class</span></span>
* <span data-ttu-id="01d76-125">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="01d76-125">Methods</span></span>
  - <span data-ttu-id="01d76-126">Sınıfı tarafından gerçekleştirilen eylemler ve hesaplamaları</span><span class="sxs-lookup"><span data-stu-id="01d76-126">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="01d76-127">Özellikler</span><span class="sxs-lookup"><span data-stu-id="01d76-127">Properties</span></span>
  - <span data-ttu-id="01d76-128">Okuma ve adlandırılmış sınıfın özelliklerini yazma ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="01d76-128">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="01d76-129">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="01d76-129">Indexers</span></span>
  - <span data-ttu-id="01d76-130">Dizin oluşturma sınıfına bir dizi gibi örnekleriyle ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="01d76-130">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="01d76-131">Olaylar</span><span class="sxs-lookup"><span data-stu-id="01d76-131">Events</span></span>
  - <span data-ttu-id="01d76-132">Sınıfı tarafından oluşturulan bildirimleri</span><span class="sxs-lookup"><span data-stu-id="01d76-132">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="01d76-133">İşleçler</span><span class="sxs-lookup"><span data-stu-id="01d76-133">Operators</span></span>
  - <span data-ttu-id="01d76-134">Dönüşümler ve sınıfı tarafından desteklenen ifade işleçleri</span><span class="sxs-lookup"><span data-stu-id="01d76-134">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="01d76-135">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="01d76-135">Constructors</span></span>
  - <span data-ttu-id="01d76-136">Sınıfın veya sınıf örneği başlatmak için gerekli eylemleri</span><span class="sxs-lookup"><span data-stu-id="01d76-136">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="01d76-137">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="01d76-137">Finalizers</span></span>
  - <span data-ttu-id="01d76-138">Sınıf örneğini kalıcı olarak atılmadan önce gerçekleştirilecek eylemler</span><span class="sxs-lookup"><span data-stu-id="01d76-138">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="01d76-139">Türler</span><span class="sxs-lookup"><span data-stu-id="01d76-139">Types</span></span>
  - <span data-ttu-id="01d76-140">Sınıfı tarafından bildirilen iç içe geçmiş türler</span><span class="sxs-lookup"><span data-stu-id="01d76-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="01d76-141">Erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="01d76-141">Accessibility</span></span>

<span data-ttu-id="01d76-142">Bir sınıfın her üyesine erişebilir üyeyi program metni bölümlerine denetleyen bir ilişkili erişilebilirlik sahiptir.</span><span class="sxs-lookup"><span data-stu-id="01d76-142">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="01d76-143">Erişilebilirlik altı olası biçimi vardır.</span><span class="sxs-lookup"><span data-stu-id="01d76-143">There are six possible forms of accessibility.</span></span> <span data-ttu-id="01d76-144">Bunlar aşağıda özetlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="01d76-144">These are summarized below.</span></span>

* `public`
  - <span data-ttu-id="01d76-145">Olmayan sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="01d76-145">Access not limited</span></span>
* `protected`
  - <span data-ttu-id="01d76-146">Bu sınıf veya sınıfların sınırlı erişim, bu sınıftan türetilen</span><span class="sxs-lookup"><span data-stu-id="01d76-146">Access limited to this class or classes derived from this class</span></span>
* `internal`
  - <span data-ttu-id="01d76-147">Geçerli derleme (.exe, .dll, vb.) için sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="01d76-147">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
  - <span data-ttu-id="01d76-148">İçeren sınıfı, kapsayan sınıftan türetilmiş sınıflar veya aynı derleme içindeki sınıf sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="01d76-148">Access limited to the containing class, classes derived from the containing class, or classes within the same assembly</span></span>
* `private`
  - <span data-ttu-id="01d76-149">Bu sınıf için sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="01d76-149">Access limited to this class</span></span>
* `private protected`
  - <span data-ttu-id="01d76-150">Aynı bütünleştirilmiş kod içinde kapsayan tür içeren sınıf veya sınıfların sınırlı erişim türetilen</span><span class="sxs-lookup"><span data-stu-id="01d76-150">Access limited to the containing class or classes derived from the containing type within the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="01d76-151">Tür parametreleri</span><span class="sxs-lookup"><span data-stu-id="01d76-151">Type parameters</span></span>

<span data-ttu-id="01d76-152">Bir sınıf tanımı, sınıf adı türü parametre adları listesini çevreleyen açılı ayraçlar ile izleyerek tür parametrelerinin kümesi belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="01d76-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="01d76-153">Tür parametreleri daha sonra sınıf bildirimi gövdesinde sınıf üyelerini tanımlamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="01d76-154">Aşağıdaki örnekte, tür parametreleri `Pair` olan `TFirst` ve `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="01d76-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="01d76-155">Tür parametreleri gerçekleştirilecek bildirildiği bir sınıf türü olarak adlandırılan bir *genel bir sınıf türü*.</span><span class="sxs-lookup"><span data-stu-id="01d76-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="01d76-156">Yapı, arabirim ve temsilci türlerinin genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-156">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="01d76-157">Genel sınıf kullanıldığında, tür bağımsız değişkenleri her tür parametreleri için sağlanmalıdır:</span><span class="sxs-lookup"><span data-stu-id="01d76-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="01d76-158">Sağlanan gibi tür bağımsız değişkenleri ile genel tür `Pair<int,string>` yukarıda adlandırılan bir *oluşturulan türü*.</span><span class="sxs-lookup"><span data-stu-id="01d76-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="01d76-159">Temel sınıflar</span><span class="sxs-lookup"><span data-stu-id="01d76-159">Base classes</span></span>

<span data-ttu-id="01d76-160">Sınıf bildiriminin bir temel sınıf, bir iki nokta üst üste ve temel sınıfın adını sınıf adı ve türü parametreleri izleyerek belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="01d76-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="01d76-161">Bir temel sınıf belirtimini atlama aynıdır türünden türetme `object`.</span><span class="sxs-lookup"><span data-stu-id="01d76-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="01d76-162">Aşağıdaki örnekte, temel sınıfını `Point3D` olduğu `Point`ve temel sınıfını `Point` olduğu `object`:</span><span class="sxs-lookup"><span data-stu-id="01d76-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="01d76-163">Bir sınıf, taban sınıfı üyelerini devralır.</span><span class="sxs-lookup"><span data-stu-id="01d76-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="01d76-164">Devralma, bir sınıf dolaylı temel sınıfı, örneği ve statik oluşturucular ve sonlandırıcılar taban sınıfın dışındaki tüm üyeleri içeren anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="01d76-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="01d76-165">Türetilmiş bir sınıf devralır bu yeni üyeler ekleyebilirsiniz, ancak devralınan bir üyeyi tanımını kaldırılamaz.</span><span class="sxs-lookup"><span data-stu-id="01d76-165">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="01d76-166">Önceki örnekte, `Point3D` devralan `x` ve `y` alanlarını `Point`ve her `Point3D` örneğini içeren üç alan `x`, `y`, ve `z`.</span><span class="sxs-lookup"><span data-stu-id="01d76-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="01d76-167">Temel sınıf türlerinden birinin bir sınıf türünden örtük bir dönüştürme yok.</span><span class="sxs-lookup"><span data-stu-id="01d76-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="01d76-168">Bu nedenle, bir sınıf türünün bir değişkeni, bu sınıfın bir örneğini veya türetilmiş bir sınıf örneği başvuruda bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-168">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="01d76-169">Örneğin, önceki bir sınıf bildirimleri, türünde bir değişken verilen `Point` ya da başvurabilirsiniz bir `Point` veya `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="01d76-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="01d76-170">Alanlar</span><span class="sxs-lookup"><span data-stu-id="01d76-170">Fields</span></span>

<span data-ttu-id="01d76-171">A *alan* bir sınıf veya bir sınıf örneği ile ilişkili bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="01d76-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="01d76-172">Statik değiştirici ile bildirilen bir alana bir statik alanı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="01d76-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="01d76-173">Statik alan tam olarak bir depolama konumunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="01d76-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="01d76-174">Bir sınıfın kaç örneklerin oluşturulduğu ne olursa olsun, yalnızca bir kopyasını statik bir alan yoktur.</span><span class="sxs-lookup"><span data-stu-id="01d76-174">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="01d76-175">Statik değiştirici bildirilen bir alan bir örnek alanıyla tanımlar.</span><span class="sxs-lookup"><span data-stu-id="01d76-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="01d76-176">Bir sınıfın her örneği, bu sınıfın tüm örnek alanları ayrı bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="01d76-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="01d76-177">Aşağıdaki örnekte, her bir örneği `Color` sınıfına sahip ayrı bir kopyasını `r`, `g`, ve `b` örnek alanları, ancak yalnızca bir kopyası `Black`, `White`, `Red`, `Green`, ve `Blue` statik alanlar:</span><span class="sxs-lookup"><span data-stu-id="01d76-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="01d76-178">Önceki örnekte gösterilen şekilde *salt okunur alanları* ile bildirilebilir bir `readonly` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="01d76-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="01d76-179">Atama bir `readonly` alan alanın bildirimin veya aynı sınıftaki bir oluşturucunun parçası olarak yalnızca oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="01d76-180">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="01d76-180">Methods</span></span>

<span data-ttu-id="01d76-181">A *yöntemi* hesaplama veya bir nesne veya sınıf tarafından gerçekleştirilen eylem uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="01d76-182">*Statik yöntemler* sınıfı üzerinden erişilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="01d76-183">*Örnek yöntemleri* sınıfının örneklerini erişilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="01d76-184">Yöntemleri listesi olabilir *parametreleri*, değerleri veya değişken başvuruları yöntemine geçirilen temsil ve *dönüş türü*, hesaplanan ve yöntem tarafından döndürülen değerin türünü belirtir.</span><span class="sxs-lookup"><span data-stu-id="01d76-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="01d76-185">Bir yöntemin dönüş türü `void` bir değer döndürmezse.</span><span class="sxs-lookup"><span data-stu-id="01d76-185">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="01d76-186">Türleri gibi yöntemleri de bir dizi yöntem çağrıldığında tür bağımsız değişkenleri belirtilmiş olmalıdır, tür parametreleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="01d76-187">Türleri, farklı tür bağımsız değişkeni genellikle bir yöntem çağrısının bağımsız değişkenlerden çıkarılan ve açıkça verilmemiş.</span><span class="sxs-lookup"><span data-stu-id="01d76-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="01d76-188">*İmza* yöntemi yöntemi bildirilmiş sınıfında benzersiz olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="01d76-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="01d76-189">Yöntemin imzası yöntem, tür parametreleri ve sayısı, değiştiriciler ve parametrelerinin türleri sayısı adını oluşur.</span><span class="sxs-lookup"><span data-stu-id="01d76-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="01d76-190">Yöntemin imzası dönüş türü içermez.</span><span class="sxs-lookup"><span data-stu-id="01d76-190">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="01d76-191">Parametreler</span><span class="sxs-lookup"><span data-stu-id="01d76-191">Parameters</span></span>

<span data-ttu-id="01d76-192">Parametre değerleri veya değişken başvuruları yöntemlere geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="01d76-193">Bir yöntem parametreleri, gerçek değerleri alma *bağımsız değişkenleri* yöntemi çağrıldığında belirtilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="01d76-194">Dört tür parametrelerinin vardır: parametreler, başvuru parametreleri, çıktı parametreleri ve parametre dizileri değeri.</span><span class="sxs-lookup"><span data-stu-id="01d76-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="01d76-195">A *değer parametresi* giriş bağımsız değişkenleri geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="01d76-196">Bir değer parametresini karşılık gelen bir yerel değişkene parametresi için geçirilen bağımsız ilk değerini alır.</span><span class="sxs-lookup"><span data-stu-id="01d76-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="01d76-197">Parametresi için geçirilen bağımsız değişken bir değer parametresini değişiklikler etkilemez.</span><span class="sxs-lookup"><span data-stu-id="01d76-197">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="01d76-198">Böylece karşılık gelen bağımsız değişken atlanırsa, varsayılan bir değer belirterek değeri parametreleri, isteğe bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="01d76-199">A *parametre başvurusunu* başvuruya göre bağımsız değişkenleri geçirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="01d76-200">Bir başvuru parametresi için geçirilen bağımsız değişken kesin bir değere sahip bir değişken olmalıdır ve yöntemin yürütülmesi sırasında aynı depolama konumu olarak bir bağımsız değişken başvuru parametresi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="01d76-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="01d76-201">Bir başvuru parametresi ile bildirilen `ref` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="01d76-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="01d76-202">Aşağıdaki örnek kullanımını gösterir `ref` parametreleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="01d76-203">Bir *çıkış parametresi* başvuruya göre bağımsız değişkenleri geçirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="01d76-204">Değeri açıkça çağıran tarafından sağlanan bağımsız değişkene atayın gerektirmeyen dışında her bir başvuru parametresi için de benzer.</span><span class="sxs-lookup"><span data-stu-id="01d76-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="01d76-205">Çıkış parametresi ile bildirilen `out` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="01d76-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="01d76-206">Aşağıdaki örnek kullanımını gösterir `out` sürümünde söz dizimini kullanarak parametreleri C# 7.</span><span class="sxs-lookup"><span data-stu-id="01d76-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="01d76-207">A *parametre dizisi* bir yönteme iletilecek bağımsız değişken bir sayı verir.</span><span class="sxs-lookup"><span data-stu-id="01d76-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="01d76-208">Bir parametre dizisi ile bildirilen `params` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="01d76-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="01d76-209">Bir yöntem yalnızca son parametresi bir parametre dizisi olabilir ve bir parametre dizisi türünde tek boyutlu dizi türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="01d76-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="01d76-210">Yazma ve WriteLine yöntemlerini <xref:System.Console?displayProperty=nameWithType> sınıfı iyi parametre dizisi kullanımı örnekleri verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="01d76-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="01d76-211">Bunlar aşağıdaki gibi bildirilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-211">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="01d76-212">Parametre dizisi, bir parametre dizisi kullanan bir yöntem içinde bir dizi türünde tam olarak normal bir parametre gibi davranır.</span><span class="sxs-lookup"><span data-stu-id="01d76-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="01d76-213">Ancak, bir parametre dizisi olan bir yöntem çağrısını içinde parametresi dizi türünde tek bir bağımsız değişken veya herhangi bir sayıda öğe türü parametre dizisi bağımsız değişkenleri geçirmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="01d76-213">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="01d76-214">İkinci durumda, bir dizi örneği otomatik olarak oluşturulur ve belirtilen bağımsız değişkenler ile başlatıldı.</span><span class="sxs-lookup"><span data-stu-id="01d76-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="01d76-215">Bu örnek</span><span class="sxs-lookup"><span data-stu-id="01d76-215">This example</span></span>

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="01d76-216">Aşağıdaki yazmaya eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="01d76-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="01d76-217">Yöntem gövdesini ve yerel değişkenler</span><span class="sxs-lookup"><span data-stu-id="01d76-217">Method body and local variables</span></span>

<span data-ttu-id="01d76-218">Bir yöntemin gövdesi yöntemi çağrıldığında çalıştırılacak deyimleri belirtir.</span><span class="sxs-lookup"><span data-stu-id="01d76-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="01d76-219">Bir yöntem gövdesi yöntemi çağırmayı için özel değişkenleri bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="01d76-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="01d76-220">Bu tür değişkenleri olarak adlandırılmasının *yerel değişkenler*.</span><span class="sxs-lookup"><span data-stu-id="01d76-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="01d76-221">Yerel bir değişken bildirimi bir tür adı, bir değişken adı ve büyük olasılıkla bir başlangıç değeri belirtir.</span><span class="sxs-lookup"><span data-stu-id="01d76-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="01d76-222">Aşağıdaki örnek, yerel bir değişken bildirir `i` bir başlangıç değeri sıfır ve yerel bir değişken ile `j` ile başlangıç değeri yok.</span><span class="sxs-lookup"><span data-stu-id="01d76-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="01d76-223">C# olarak yerel bir değişken gerektirir *kesinlikle atanan* önce değeri elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="01d76-224">Örneğin, önceki bildirimi `i` bir başlangıç değeri içermesi gerekmez, derleyici bir hata sonraki kullanımlar için rapor `i` çünkü `i` kesinlikle noktalarda program atanır değil.</span><span class="sxs-lookup"><span data-stu-id="01d76-224">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="01d76-225">Bir yöntemi kullanabilirsiniz `return` denetimi onu arayan döndürülecek deyimleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="01d76-226">Döndüren bir yöntem içinde `void`, `return` deyimleri, bir ifade belirtemez.</span><span class="sxs-lookup"><span data-stu-id="01d76-226">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="01d76-227">Void olmayan, döndüren bir yöntem içinde `return` deyimleri, dönüş değeri hesaplar bir ifade içermelidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="01d76-228">Statik ve örnek yöntemleri</span><span class="sxs-lookup"><span data-stu-id="01d76-228">Static and instance methods</span></span>

<span data-ttu-id="01d76-229">Statik bir değiştiriciyle bildirildi bir yöntem bir *statik yöntem*.</span><span class="sxs-lookup"><span data-stu-id="01d76-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="01d76-230">Statik bir yöntemi, belirli bir örneği üzerinde çalışmaz ve statik üyeler yalnızca doğrudan erişebilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-230">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="01d76-231">Statik değiştirici olmayan bir yöntem olarak bildirilen bir *örnek yöntemi*.</span><span class="sxs-lookup"><span data-stu-id="01d76-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="01d76-232">Bir örnek yöntemi belirli bir örneği üzerinde çalışır ve hem statik erişebilir ve örnek üyeler.</span><span class="sxs-lookup"><span data-stu-id="01d76-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="01d76-233">Bir örnek yöntemi çağrıldığı örnek olarak açıkça erişilebilir `this`.</span><span class="sxs-lookup"><span data-stu-id="01d76-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="01d76-234">Başvurmak için bir hata olduğunu `this` statik yöntemde.</span><span class="sxs-lookup"><span data-stu-id="01d76-234">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="01d76-235">Aşağıdaki `Entity` sınıfında statik ve örnek üyeleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="01d76-236">Her `Entity` örneği seri numarası (ve burada gösterilmez büyük olasılıkla bazı diğer bilgileri içerir).</span><span class="sxs-lookup"><span data-stu-id="01d76-236">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="01d76-237">`Entity` (Olan bir örnek yöntemi gibi) bir oluşturucu sonraki kullanılabilir seri numarasına sahip yeni örneğini başlatır.</span><span class="sxs-lookup"><span data-stu-id="01d76-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="01d76-238">Oluşturucu bir örnek üyesi olduğundan, her ikisi de erişmesine izin verilen `serialNo` örnek alan ve `nextSerialNo` statik alan.</span><span class="sxs-lookup"><span data-stu-id="01d76-238">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="01d76-239">`GetNextSerialNo` Ve `SetNextSerialNo` statik yöntemler erişebilir `nextSerialNo` statik alan, ancak bir hata için bunları doğrudan erişimini olacak `serialNo` örnek alanı.</span><span class="sxs-lookup"><span data-stu-id="01d76-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="01d76-240">Aşağıdaki örnek, varlık sınıfının kullanımı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="01d76-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="01d76-241">Unutmayın `SetNextSerialNo` ve `GetNextSerialNo` statik yöntemler, sınıf üzerinde çağrılır, ancak `GetSerialNo` sınıf örnekleri üzerinde örnek yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-241">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="01d76-242">Soyut metotlar sanal ve geçersiz kılma</span><span class="sxs-lookup"><span data-stu-id="01d76-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="01d76-243">Ne zaman bir örnek yöntemi bildirimi içeren bir `virtual` değiştiricisi, yöntem olarak kabul edilir bir *sanal yöntem*.</span><span class="sxs-lookup"><span data-stu-id="01d76-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="01d76-244">Hiçbir sanal değiştirici mevcut olduğunda, yöntemin olduğu söylenir bir *yöntemi sanal olmayan*.</span><span class="sxs-lookup"><span data-stu-id="01d76-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="01d76-245">Sanal bir yöntem çağrıldığında *çalışma zamanı tür* bu çağırma aldığı örneğini yerde çağrılacak gerçek yöntem uygulaması belirler.</span><span class="sxs-lookup"><span data-stu-id="01d76-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="01d76-246">Bir sanal olmayan bir yöntem çağrısı *derleme zamanı tür* belirleyici faktör örneğidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="01d76-247">Sanal bir yöntem olabilir *geçersiz kılınan* türetilen bir sınıfta.</span><span class="sxs-lookup"><span data-stu-id="01d76-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="01d76-248">Bir örnek yöntem bildiriminde geçersiz kılma değiştiricisini içerdiğinde, yöntemin aynı imzaya sahip devralınan sanal yöntemi geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="01d76-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="01d76-249">Bir geçersiz kılma yöntemi bildirimini sanal yöntem bildiriminde bir yöntem sunar ancak bu yöntem yeni bir uygulamasını sağlayarak mevcut devralınan sanal yöntemi uzmanlaşmış.</span><span class="sxs-lookup"><span data-stu-id="01d76-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="01d76-250">Bir *yöntemi soyut* uygulama içermeyen sanal bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="01d76-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="01d76-251">Soyut bir yöntemi soyut değiştiriciyle bildirildi ve yalnızca soyut bildirildiği bir sınıf içinde izin verilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="01d76-252">Her bir soyut olmayan türetilmiş sınıf içinde soyut bir yöntemi geçersiz kılınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="01d76-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="01d76-253">Aşağıdaki örnek, bir soyut sınıfı bildirir `Expression`, bir ifade ağacı düğümünü temsil eder ve üç türetilmiş sınıfları `Constant`, `VariableReference`, ve `Operation`, sabitler, değişken için ifade ağaç düğümleri uygulayın başvurular ve aritmetik işlemler.</span><span class="sxs-lookup"><span data-stu-id="01d76-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="01d76-254">(Bu ifade ağacı türleriyle karıştırılmamalıdır ancak, benzer).</span><span class="sxs-lookup"><span data-stu-id="01d76-254">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="01d76-255">Önceki dört sınıfları, aritmetik ifadeler modellemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="01d76-256">Örneğin, ifade bu sınıfların örnekleri kullanarak `x + 3` şu şekilde temsil edilebilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="01d76-257">`Evaluate` Yöntemi bir `Expression` örneği belirtilen ifadeyi değerlendirir ve üretmek için çağrıldığında bir `double` değeri.</span><span class="sxs-lookup"><span data-stu-id="01d76-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="01d76-258">Yöntem alır bir `Dictionary` (anahtar olarak girişlerinin) değişken adları ve değerleri (olarak girdilerinin değerlerini) içeren bir bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="01d76-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="01d76-259">Çünkü `Evaluate` soyut bir yöntem, türetilen soyut olmayan sınıflar `Expression` kılmalı `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="01d76-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="01d76-260">A `Constant`'s uygulaması `Evaluate` yalnızca saklı sabiti döndürür.</span><span class="sxs-lookup"><span data-stu-id="01d76-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="01d76-261">A `VariableReference`kullanıcının sözlük değişken adında uygulama arar ve elde edilen değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="01d76-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="01d76-262">Bir `Operation`ait uygulama ilk sol ve sağ işlenen değerlendirilir (yinelemeli olarak çağırarak kendi `Evaluate` yöntemleri) ve ardından belirli bir aritmetik işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="01d76-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="01d76-263">Aşağıdaki program kullanan `Expression` ifadeyi değerlendiren şeyde sınıfları `x * (y + 2)` farklı değerler için `x` ve `y`.</span><span class="sxs-lookup"><span data-stu-id="01d76-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="01d76-264">Yöntemi aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="01d76-264">Method overloading</span></span>

<span data-ttu-id="01d76-265">Yöntemi *aşırı yükleme* aynı sınıfta benzersiz imzaları sahip oldukları sürece aynı ada sahip birden çok yöntem izin verir.</span><span class="sxs-lookup"><span data-stu-id="01d76-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="01d76-266">Aşırı yüklenmiş yöntem çağrısından derlerken, derleyicinin kullandığı *aşırı yükleme çözümlemesi* çağrılacak belirli yöntemi belirlemek için.</span><span class="sxs-lookup"><span data-stu-id="01d76-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="01d76-267">En iyi eşleşen bağımsız değişkenler veya tek en iyi eşleşme bulunamazsa, bir hata raporları bir yöntemi aşırı yükleme çözünürlüğü bulur.</span><span class="sxs-lookup"><span data-stu-id="01d76-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="01d76-268">Aşağıdaki örnek, aşırı yükleme çözünürlüğü geçerli gösterir.</span><span class="sxs-lookup"><span data-stu-id="01d76-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="01d76-269">Her bir çağrıda yorum `UsageExample` yöntemi gösterir hangi yöntemi gerçekten çağrılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-269">The comment for each invocation in the `UsageExample` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="01d76-270">Örnekte gösterildiği gibi belirli bir yöntem her zaman tam parametre türleri bağımsız değişkenleri açıkça atama ve/veya tür bağımsız değişkenleri açıkça sağlama tarafından seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="01d76-271">Diğer işlev üyeleri</span><span class="sxs-lookup"><span data-stu-id="01d76-271">Other function members</span></span>

<span data-ttu-id="01d76-272">Yürütülebilir kod içeren bir üye olarak bilinir topluca *işlev üyeleri* bir sınıf.</span><span class="sxs-lookup"><span data-stu-id="01d76-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="01d76-273">Birincil işlev üyeleri türü olan yöntemler, önceki bölümde açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="01d76-273">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="01d76-274">Bu bölümde bir işlev üyeleri tarafından desteklenen tür açıklanmaktadır C#: Oluşturucular, özellikleri, Dizinleyicileri, olayları, işleçler ve sonlandırıcılar.</span><span class="sxs-lookup"><span data-stu-id="01d76-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="01d76-275">Adlı bir genel sınıf aşağıdaki gösterir `MyList<T>`, growable nesnelerin listesini uygular.</span><span class="sxs-lookup"><span data-stu-id="01d76-275">The following shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="01d76-276">Sınıf işlev üyeleri en yaygın tür çeşitli örneklerini içerir.</span><span class="sxs-lookup"><span data-stu-id="01d76-276">The class contains several examples of the most common kinds of function members.</span></span>

> [!NOTE]
> <span data-ttu-id="01d76-277">Bu örnekte bir `MyList` .NET standard ile aynı değil, sınıf <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="01d76-277">This example creates a `MyList` class, which is not the same as the .NET standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="01d76-278">Bu turda gerekli kavramları göstermek, ancak o sınıf için yerine geçmez.</span><span class="sxs-lookup"><span data-stu-id="01d76-278">It does illustrate the concepts needed for this tour, but is not a replacement for that class.</span></span>

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="01d76-279">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="01d76-279">Constructors</span></span>

<span data-ttu-id="01d76-280">C# örneği hem de statik oluşturucular destekler.</span><span class="sxs-lookup"><span data-stu-id="01d76-280">C# supports both instance and static constructors.</span></span> <span data-ttu-id="01d76-281">Bir *örnek oluşturucusu* uygulayan bir sınıf örneği başlatmak için gerekli eylemleri bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-281">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="01d76-282">A *statik Oluşturucu* ilk yüklendiğinde bir sınıf başlatmak için gerekli eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-282">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="01d76-283">Bir oluşturucu dönüş türü ve kapsayan sınıfı aynı ada sahip bir yöntemi gibi bildirilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-283">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="01d76-284">Statik değiştirici Oluşturucu bildirimi içeriyorsa, bir statik Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="01d76-284">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="01d76-285">Aksi takdirde, bir örnek oluşturucusu bildirir.</span><span class="sxs-lookup"><span data-stu-id="01d76-285">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="01d76-286">Örnek oluşturucuları aşırı yüklenebilir ve isteğe bağlı parametreler olabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-286">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="01d76-287">Örneğin, `MyList<T>` sınıfı bildirir, bir parametre ve süren iki örnek oluşturucuları bir `int` parametresi.</span><span class="sxs-lookup"><span data-stu-id="01d76-287">For example, the `MyList<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="01d76-288">Örnek oluşturucuları kullanarak çağrılır `new` işleci.</span><span class="sxs-lookup"><span data-stu-id="01d76-288">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="01d76-289">Aşağıdaki deyimleri iki ayırma `MyList<string>` Oluşturucusu kullanarak örneği `MyList` sınıfı ile ve isteğe bağlı bağımsız değişken olmadan.</span><span class="sxs-lookup"><span data-stu-id="01d76-289">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="01d76-290">Diğer üyeleri farklı olarak örnek oluşturucuları olmayan devralınır ve sınıfı, bu gerçekte bildirilen dışında hiçbir örnek oluşturucuları bir sınıfa sahip.</span><span class="sxs-lookup"><span data-stu-id="01d76-290">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="01d76-291">Hiçbir örnek oluşturucusu için bir sınıf sağlanırsa, sonra boş bir parametre olmadan otomatik olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="01d76-291">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="01d76-292">Özellikler</span><span class="sxs-lookup"><span data-stu-id="01d76-292">Properties</span></span>

<span data-ttu-id="01d76-293">*Özellikleri* alanları doğal bir uzantısıdır.</span><span class="sxs-lookup"><span data-stu-id="01d76-293">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="01d76-294">Her ikisi de ilişkili türlerini üyeleriyle adlı ve alanlar ve Özellikler erişmek için sözdizimi aynıdır.</span><span class="sxs-lookup"><span data-stu-id="01d76-294">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="01d76-295">Ancak, alanlar özellikleri depolama konumları belirtmek değil.</span><span class="sxs-lookup"><span data-stu-id="01d76-295">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="01d76-296">Bunun yerine, özelliklere sahip *erişimcileri* değerlerine okunabilir veya yazılabilir bırakıldığında yürütülecek deyimler belirtin.</span><span class="sxs-lookup"><span data-stu-id="01d76-296">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="01d76-297">Bildirimi bir alma erişimcisi ve/veya sınırlayıcılar arasında yazılan ayarlama erişimcisine biten dışında bir özellik gibi bir alan, bildirilmiş `{` ve `}` noktalı bitiş yerine.</span><span class="sxs-lookup"><span data-stu-id="01d76-297">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="01d76-298">Hem bir alma erişimcisi hem de ayarlama erişimcisine sahip olduğu bir özelliği bir *okuma-yazma özelliği*, yalnızca bir alma erişimcisi bir özelliği bir *salt okunur özelliği*, ve yalnızca bir set erişimcisine sahip bir özelliği bir *salt yazılır özelliği*.</span><span class="sxs-lookup"><span data-stu-id="01d76-298">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="01d76-299">Bir alma erişimcisi, dönüş değeri, özellik türü olan bir parametresiz yöntemin karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="01d76-299">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="01d76-300">Bir özellik bir ifadede başvurulduğunda dışında bir atama hedefi olarak özelliğin get erişimcisine özelliğin değerini hesaplamak için çağrılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-300">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="01d76-301">Ayarlama erişimcisine değeri ve dönüş türü olarak adlandırılan tek bir parametre ile bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="01d76-301">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="01d76-302">Ne zaman bir özelliği başvuru atama hedefi veya işleneni olarak ++ veya--, set erişimcisine yeni değer sağlayan bağımsız değişkenlerle çağrılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-302">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="01d76-303">`MyList<T>` Sınıfı bildirir iki özellik `Count` ve `Capacity`, olan salt okunur ve okuma-yazma, sırasıyla.</span><span class="sxs-lookup"><span data-stu-id="01d76-303">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="01d76-304">Bu özelliklerin kullanımı bir örnek verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="01d76-304">The following is an example of use of these properties:</span></span>

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="01d76-305">Benzer şekilde, alanlar ve yöntemler, C# örnek özelliklerini hem statik özelliklerini destekler.</span><span class="sxs-lookup"><span data-stu-id="01d76-305">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="01d76-306">Statik özellikler statik değiştiricisi ile bildirilir ve örnek özelliklerini olmadan bildirilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-306">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="01d76-307">Bir özelliğin accessor(s) sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-307">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="01d76-308">Ne zaman bir özellik bildirimi içeren bir `virtual`, `abstract`, veya `override` değiştiricisi, özellik accessor(s) için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-308">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="01d76-309">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="01d76-309">Indexers</span></span>

<span data-ttu-id="01d76-310">Bir *dizin oluşturucu* nesneleri dizisi olarak aynı şekilde dizinlenmesini sağlar bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-310">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="01d76-311">Üyenin adını bu sınırlayıcılar arasında yazılmış bir parametre listesi ardından olması dışında dizin oluşturucu bir özellik gibi bildirilir `[` ve `]`.</span><span class="sxs-lookup"><span data-stu-id="01d76-311">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="01d76-312">Parametreler, dizin oluşturucunun accessor(s) içinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-312">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="01d76-313">Benzer şekilde, özellikler, dizin oluşturucular okuma-yazma, salt okunur ve salt yazılır olabilir ve bir dizin oluşturucu accessor(s) sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-313">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="01d76-314">`MyList<T>` Sınıfı bildirir gereken tek bir okuma-yazma dizin oluşturucu bir `int` parametresi.</span><span class="sxs-lookup"><span data-stu-id="01d76-314">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="01d76-315">Dizin oluşturucunun, dizin mümkün kılar `MyList<T>` ile örnekler `int` değerleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-315">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="01d76-316">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="01d76-316">For example:</span></span>

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="01d76-317">Dizin Oluşturucular, sayı veya kendi parametre türleri farklı olduğu sürece bir sınıfın birden çok dizin oluşturucu bildirebilirsiniz anlamına gelen aşırı yüklenebilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-317">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="01d76-318">Olaylar</span><span class="sxs-lookup"><span data-stu-id="01d76-318">Events</span></span>

<span data-ttu-id="01d76-319">Bir *olay* bir sınıf veya nesne bildirimleri sağlamak için sağlayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-319">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="01d76-320">Bir olay gibi bir alan bildirimi bir event anahtar sözcüğü içerir ve türü bir temsilci türü olmalıdır bildirilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-320">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="01d76-321">(Olay soyut değil ve erişimcileri bildirmiyor sağlanan) bir olay üyesi bildiren bir sınıf içinde olay yalnızca bir temsilci türüne bir alan gibi davranır.</span><span class="sxs-lookup"><span data-stu-id="01d76-321">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="01d76-322">Olaya eklenmiş olan olay işleyicilerini temsil eden bir temsilci bir başvuru alan depolar.</span><span class="sxs-lookup"><span data-stu-id="01d76-322">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="01d76-323">Hiçbir olay işleyicileri varsa alandır `null`.</span><span class="sxs-lookup"><span data-stu-id="01d76-323">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="01d76-324">`MyList<T>` Sınıfı olarak adlandırılan tek bir olay üyesi bildirir `Changed`, yeni bir öğe listesine eklendiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="01d76-324">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="01d76-325">Değiştirilen olay tarafından gerçekleştirilen `OnChanged` hangi ilk olay olup olmadığını denetler, sanal bir yöntem `null` (hiçbir işleyicileri bulunduğunu anlamına gelir).</span><span class="sxs-lookup"><span data-stu-id="01d76-325">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="01d76-326">Olay bildirmek, kavram olay tarafından temsil edilen temsilci çağırmak için tam olarak eşittir; Bu nedenle, olayları oluşturma için hiçbir özel dil yapıları vardır.</span><span class="sxs-lookup"><span data-stu-id="01d76-326">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="01d76-327">İstemciler react ile olayları *olay işleyicileri*.</span><span class="sxs-lookup"><span data-stu-id="01d76-327">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="01d76-328">Olay işleyicileri kullanılarak eklenen `+=` işleci ve kaldırılan kullanarak `-=` işleci.</span><span class="sxs-lookup"><span data-stu-id="01d76-328">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="01d76-329">Aşağıdaki örnek bir olay işleyicisi ekler `Changed` olayı bir `MyList<string>`.</span><span class="sxs-lookup"><span data-stu-id="01d76-329">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="01d76-330">Denetim bir olay temel alınan depolamanın istenen burada Gelişmiş senaryolar için bir olay bildirimi açıkça sağlayabilir `add` ve `remove` biraz benzerdir erişimcileri `set` özellik erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="01d76-330">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="01d76-331">İşleçler</span><span class="sxs-lookup"><span data-stu-id="01d76-331">Operators</span></span>

<span data-ttu-id="01d76-332">Bir *işleci* belirli ifade işleci bir sınıfın bir örneği için uygulama ne anlama geldiğini tanımlayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-332">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="01d76-333">Üç tür işleç tanımlanabilir: Birli işleçler, ikili işleçler ve dönüştürme işleçleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-333">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="01d76-334">Tüm işleçler olarak bildirilmelidir `public` ve `static`.</span><span class="sxs-lookup"><span data-stu-id="01d76-334">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="01d76-335">`MyList<T>` Sınıfı bildirir iki işleç `operator ==` ve `operator !=`ve bu nedenle bu işleçleri için geçerli ifadeler için yeni anlamı verir `MyList` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-335">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="01d76-336">Özellikle, iki eşitlik işleçleri tanımlama `MyList<T>` örnekleri her biri kendi eşittir yöntemlerini kullanarak kapsanan nesneleri karşılaştırma olarak.</span><span class="sxs-lookup"><span data-stu-id="01d76-336">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="01d76-337">Aşağıdaki örnekte `==` karşılaştırmak için işleci `MyList<int>` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-337">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="01d76-338">İlk `Console.WriteLine` çıkarır `True` listelerini nesneleri aynı sırada aynı değerlerle aynı sayıda içerdiğinden.</span><span class="sxs-lookup"><span data-stu-id="01d76-338">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="01d76-339">Vardı `MyList<T>` tanımlanmamış `operator ==`, ilk `Console.WriteLine` çıkış `False` çünkü `a` ve `b` başvuru farklı `MyList<int>` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="01d76-339">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="01d76-340">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="01d76-340">Finalizers</span></span>

<span data-ttu-id="01d76-341">A *Sonlandırıcı* uygulayan bir sınıfın örneği sonlandırmaya gereken eylemler bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="01d76-341">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="01d76-342">Sonlandırıcı parametrelere sahip olamaz, Erişilebilirlik değiştiricilere sahip olamaz ve açıkça çağrılamaz.</span><span class="sxs-lookup"><span data-stu-id="01d76-342">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="01d76-343">Bir örneği için Sonlandırıcı çöp toplama sırasında otomatik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="01d76-343">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="01d76-344">Çöp toplayıcı nesnelerin toplamak ve sonlandırıcılar çalıştırmak ne zaman karar içinde geniş enlem izin verilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-344">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="01d76-345">Özellikle, sonlandırıcı çağrılarını zamanlamasını belirleyici değildir ve sonlandırıcılar herhangi bir iş parçacığı üzerinde çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="01d76-345">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="01d76-346">Diğer çözüm uygun olduğunda bunlar ve diğer nedenleriyle sınıfları sonlandırıcılar uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="01d76-346">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="01d76-347">`using` Deyim nesnesi yok etme için daha iyi bir yaklaşım sağlar.</span><span class="sxs-lookup"><span data-stu-id="01d76-347">The `using` statement provides a better approach to object destruction.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="01d76-348">[Önceki](statements.md)
> [İleri](structs.md)</span><span class="sxs-lookup"><span data-stu-id="01d76-348">[Previous](statements.md)
[Next](structs.md)</span></span>

---
title: Güvenli ve verimli yazma C# kod
description: Son geliştirmeler C# dil performansını daha önce güvenli olmayan kod ile ilişkili doğrulanabilir bir güvenli kod yazmak etkinleştirin.
ms.date: 10/23/2018
ms.custom: mvc
ms.openlocfilehash: 73ad7a84d2ad47f0e0242825d250247ffb39928e
ms.sourcegitcommit: 34593b4d0be779699d38a9949d6aec11561657ec
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/11/2019
ms.locfileid: "66832940"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="253c8-103">Güvenli ve verimli yazma C# kod</span><span class="sxs-lookup"><span data-stu-id="253c8-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="253c8-104">Yeni Özellikler C# daha iyi performans ile doğrulanabilir güvenli kod yazmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="253c8-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="253c8-105">Bu teknikler özenle uygularsanız, daha az senaryoları güvenli olmayan kod gerektirir.</span><span class="sxs-lookup"><span data-stu-id="253c8-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="253c8-106">Bu özellikler başvuruları değer türleri için yöntem bağımsız değişkenleri ve yöntemi olarak kullanmak üzere kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="253c8-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="253c8-107">Güvenli bir şekilde işiniz bittiğinde, bu teknikler kopyalama türlerin en aza indirin.</span><span class="sxs-lookup"><span data-stu-id="253c8-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="253c8-108">Değer türleri kullanarak ayırmaları ve çöp toplama geçişleri sayısını en aza indirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="253c8-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="253c8-109">Bu makaledeki örnek kodun çoğu eklenen özellikler kullanıyor C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="253c8-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="253c8-110">Bu özellikleri kullanmak için projenizi kullanmak üzere yapılandırma C# 7.2 veya üzeri.</span><span class="sxs-lookup"><span data-stu-id="253c8-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="253c8-111">Dil sürümü hakkında daha fazla bilgi için bkz. [dil sürümü yapılandırma](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="253c8-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="253c8-112">Bu makalede, verimli kaynak yönetimi teknikleri odaklanır.</span><span class="sxs-lookup"><span data-stu-id="253c8-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="253c8-113">Bunlar genellikle yığın ayırmaları önlemek değer türleri kullanmanın avantajlarından biri.</span><span class="sxs-lookup"><span data-stu-id="253c8-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="253c8-114">Olumsuz yönüyse, değere göre kopyalanana ' dir.</span><span class="sxs-lookup"><span data-stu-id="253c8-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="253c8-115">Bu bir tradeoff, büyük miktarlarda veri çalışan algoritmalar iyileştirmek zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="253c8-115">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="253c8-116">Yeni dil özellikleri C# 7.2 başvuruları değer türleri kullanarak güvenli verimli kod etkinleştirme mekanizmaları sağlar.</span><span class="sxs-lookup"><span data-stu-id="253c8-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="253c8-117">Bu özellikler hem ayırmaların en aza indirmek ve kopyalama işlemlerini akıllıca kullanın.</span><span class="sxs-lookup"><span data-stu-id="253c8-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="253c8-118">Bu makalede, bu yeni özellikleri keşfediyor.</span><span class="sxs-lookup"><span data-stu-id="253c8-118">This article explores those new features.</span></span>

<span data-ttu-id="253c8-119">Bu makalede, aşağıdaki kaynak yönetimi teknikleri üzerinde odaklanır:</span><span class="sxs-lookup"><span data-stu-id="253c8-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="253c8-120">Bildirme bir [ `readonly struct` ](language-reference/keywords/readonly.md#readonly-struct-example) tür olduğunu ifade **değişmez** ve kopya kullanırken kaydetmek için derleyiciyi etkinleştirir [ `in` ](language-reference/keywords/in-parameter-modifier.md) parametreleri.</span><span class="sxs-lookup"><span data-stu-id="253c8-120">Declare a [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) to express that a type is **immutable** and enables the compiler to save copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="253c8-121">Kullanım bir [ `ref readonly` ](language-reference/keywords/ref.md#reference-return-values) dönüş değeri, dönüş bir `struct` büyük <xref:System.IntPtr.Size?displayProperty=nameWithType> ve depolama yaşam süresi değerini döndüren yöntemi büyüktür.</span><span class="sxs-lookup"><span data-stu-id="253c8-121">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="253c8-122">Zaman boyutu bir `readonly struct` daha büyük <xref:System.IntPtr.Size?displayProperty=nameWithType>, olarak geçmelidir bir `in` Performans nedeniyle parametresi.</span><span class="sxs-lookup"><span data-stu-id="253c8-122">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="253c8-123">Hiçbir zaman geçmesi bir `struct` olarak bir `in` parametresi ile bildirildiği sürece `readonly` değiştiricisi performansını olumsuz etkileyebilir ve belirsiz bir davranışa neden.</span><span class="sxs-lookup"><span data-stu-id="253c8-123">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier because it may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="253c8-124">Kullanım bir [ `ref struct` ](language-reference/keywords/ref.md#ref-struct-types), veya bir `readonly ref struct` gibi <xref:System.Span%601> veya <xref:System.ReadOnlySpan%601> bayt dizisi olarak bellek ile çalışmak için.</span><span class="sxs-lookup"><span data-stu-id="253c8-124">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="253c8-125">Bu teknikler, iki rakip hedefleri ile dengelemek için zorlama **başvuruları** ve **değerleri**.</span><span class="sxs-lookup"><span data-stu-id="253c8-125">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="253c8-126">Değişkenler [başvuru türleri](programming-guide/types/index.md#reference-types) bellekteki konumu başvuru tutun.</span><span class="sxs-lookup"><span data-stu-id="253c8-126">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="253c8-127">Değişkenler [değer türleri](programming-guide/types/index.md#value-types) doğrudan değerleri içerir.</span><span class="sxs-lookup"><span data-stu-id="253c8-127">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="253c8-128">Bu farklılıklar, bellek kaynakları yönetmek için önemli olan temel farklılıklar vurgulayın.</span><span class="sxs-lookup"><span data-stu-id="253c8-128">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="253c8-129">**Değer türleri** genellikle bir yönteme geçildiğinde kopyaladığınız veya bir yöntemin döndürdüğü.</span><span class="sxs-lookup"><span data-stu-id="253c8-129">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="253c8-130">Değerini kopyalayarak bu davranışı içerir `this` bir değer türünün üyesi çağırırken.</span><span class="sxs-lookup"><span data-stu-id="253c8-130">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="253c8-131">Kopyanın maliyet türü boyutunu ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="253c8-131">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="253c8-132">**Başvuru türleri** yönetilen yığında ayrılır.</span><span class="sxs-lookup"><span data-stu-id="253c8-132">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="253c8-133">Her yeni nesne ayırma gerektirir ve daha sonra yeniden gerekir.</span><span class="sxs-lookup"><span data-stu-id="253c8-133">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="253c8-134">Bu işlemler uzun sürer.</span><span class="sxs-lookup"><span data-stu-id="253c8-134">Both these operations take time.</span></span> <span data-ttu-id="253c8-135">Bir başvuru türü bağımsız değişken olarak bir yönteme ya da bir yönteminden döndürülen başvuru kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="253c8-135">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="253c8-136">Bu makalede, bu önerileri açıklayan 3B poınt yapısı aşağıdaki örnek kavramını kullanır:</span><span class="sxs-lookup"><span data-stu-id="253c8-136">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="253c8-137">Bu kavram, farklı uygulamalar farklı örnekleri kullanın.</span><span class="sxs-lookup"><span data-stu-id="253c8-137">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="253c8-138">Salt okunur yapılar için değişmez değer türleri bildirme</span><span class="sxs-lookup"><span data-stu-id="253c8-138">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="253c8-139">Bildirme bir `struct` kullanarak `readonly` değiştiricisi derleyici amacınızla sabit bir tür oluşturmak üzere olduğunu bildirir.</span><span class="sxs-lookup"><span data-stu-id="253c8-139">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="253c8-140">Derleyici, aşağıdaki kurallar ile tasarım kararı uygular:</span><span class="sxs-lookup"><span data-stu-id="253c8-140">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="253c8-141">Tüm alanı üyeleri olmalıdır `readonly`</span><span class="sxs-lookup"><span data-stu-id="253c8-141">All field members must be `readonly`</span></span>
- <span data-ttu-id="253c8-142">Tüm özellikler, otomatik uygulanan özellikler dahil olmak üzere salt okunur olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="253c8-142">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="253c8-143">Bu iki kuralın hiçbir üye emin olmak yeterli bir `readonly struct` bu yapı durumunu değiştirir.</span><span class="sxs-lookup"><span data-stu-id="253c8-143">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="253c8-144">`struct` Sabittir.</span><span class="sxs-lookup"><span data-stu-id="253c8-144">The `struct` is immutable.</span></span> <span data-ttu-id="253c8-145">`Point3D` Yapısı aşağıdaki örnekte gösterildiği gibi bir sabit yapısı açıklanabilir:</span><span class="sxs-lookup"><span data-stu-id="253c8-145">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="253c8-146">Bu öneri, bir değişmez değer türü oluşturmak için tasarım amacınızla olduğunda izleyin.</span><span class="sxs-lookup"><span data-stu-id="253c8-146">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="253c8-147">Herhangi bir performans artışıyla avantaj ' dir.</span><span class="sxs-lookup"><span data-stu-id="253c8-147">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="253c8-148">`readonly struct` Tasarım amacınızla açıkça ifade eder.</span><span class="sxs-lookup"><span data-stu-id="253c8-148">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="253c8-149">Kullanım `ref readonly return` mümkün olduğunda büyük yapıları için deyimleri</span><span class="sxs-lookup"><span data-stu-id="253c8-149">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="253c8-150">Döndürülen değer döndüren yöntemin yerel değilken, başvuruya göre değerler döndürmesine.</span><span class="sxs-lookup"><span data-stu-id="253c8-150">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="253c8-151">Başvuruya göre döndüren anlamına gelir yalnızca başvurunun kopyalandığı yapısı.</span><span class="sxs-lookup"><span data-stu-id="253c8-151">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="253c8-152">Aşağıdaki örnekte, `Origin` özelliğini kullanamaz bir `ref` döndürülen değer yerel bir değişken olduğundan döndürür:</span><span class="sxs-lookup"><span data-stu-id="253c8-152">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="253c8-153">Ancak, döndürülen değer, bir statik üye olduğundan aşağıdaki özellik tanımı başvuruya göre döndürülebilir:</span><span class="sxs-lookup"><span data-stu-id="253c8-153">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="253c8-154">Çağıranlar değeri döndürmelidir. Bu nedenle kaynağı değiştirmek istemediğiniz `readonly ref`:</span><span class="sxs-lookup"><span data-stu-id="253c8-154">You don't want callers modifying the origin, so you should return the value by `readonly ref`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="253c8-155">Döndüren `ref readonly` daha büyük yapılar kopyalama kaydedin ve değiştirilemezlik, iç veri üyeleri koruma sağlar.</span><span class="sxs-lookup"><span data-stu-id="253c8-155">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="253c8-156">Çağıran sitede, Arayanların kullanma seçimi yapın `Origin` özelliği olarak bir `readonly ref` ya da bir değer olarak:</span><span class="sxs-lookup"><span data-stu-id="253c8-156">At the call site, callers make the choice to use the `Origin` property as a `readonly ref` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="253c8-157">Önceki kodda ilk atama bir kopyasını oluşturur `Origin` sabit ve kopyalama atar.</span><span class="sxs-lookup"><span data-stu-id="253c8-157">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="253c8-158">İkinci bir başvuru atar.</span><span class="sxs-lookup"><span data-stu-id="253c8-158">The second assigns a reference.</span></span> <span data-ttu-id="253c8-159">Dikkat `readonly` değiştiricisi değişkenin bildirimi bir parçası olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="253c8-159">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="253c8-160">Başvurduğu başvurusu değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="253c8-160">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="253c8-161">Bunu denediğinizde bir derleme zamanı hatasına neden.</span><span class="sxs-lookup"><span data-stu-id="253c8-161">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="253c8-162">`readonly` Değiştiricisi beyanı gerekli `originReference`.</span><span class="sxs-lookup"><span data-stu-id="253c8-162">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="253c8-163">Derleyici, çağırana başvurusu değiştirilemez zorlar.</span><span class="sxs-lookup"><span data-stu-id="253c8-163">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="253c8-164">Denemeleri değeri doğrudan atamak için bir derleme zamanı hatası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="253c8-164">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="253c8-165">Ancak, derleyici, herhangi bir üye yöntemi yapı durumunu değiştirirse bilemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="253c8-165">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="253c8-166">Nesne değişiklik olmadığından emin olmak için derleyici bir kopyasını oluşturur ve bu kopyayı kullanarak başvuruları üye arar.</span><span class="sxs-lookup"><span data-stu-id="253c8-166">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="253c8-167">Herhangi bir değişiklik için savunma kopyası var.</span><span class="sxs-lookup"><span data-stu-id="253c8-167">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="253c8-168">Uygulama `in` değiştiriciyi `readonly struct` parametreleri büyük `System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="253c8-168">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="253c8-169">`in` Anahtar sözcüğü tamamlar varolan `ref` ve `out` başvuruya göre bağımsız değişkenleri geçirmek için anahtar sözcükler.</span><span class="sxs-lookup"><span data-stu-id="253c8-169">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="253c8-170">`in` Anahtar sözcüğü, bağımsız değişkenini başvuruya göre geçirme belirtir, ancak çağrılan yöntem değerini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="253c8-170">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="253c8-171">Bu ayrıca, tasarım hedefi ifade etmek için tam bir kelime sağlar.</span><span class="sxs-lookup"><span data-stu-id="253c8-171">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="253c8-172">Değer türleri Yöntem imzasında aşağıdaki değiştiriciler hiçbirini belirtmezseniz, çağrılan bir yönteme geçildiğinde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="253c8-172">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="253c8-173">Bu değiştiriciler, her bir değişken kopyalama önleme başvuruyla geçirilir belirtir.</span><span class="sxs-lookup"><span data-stu-id="253c8-173">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="253c8-174">Her değiştiricisi, farklı bir hedefi ifade eder:</span><span class="sxs-lookup"><span data-stu-id="253c8-174">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="253c8-175">`out`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini ayarlar.</span><span class="sxs-lookup"><span data-stu-id="253c8-175">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="253c8-176">`ref`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkeninin değerini ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="253c8-176">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="253c8-177">`in`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkeninin değerini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="253c8-177">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="253c8-178">Ekleme `in` başvuruya göre bağımsız değişken geçirin ve gereksiz şekilde kopyalamama olanağı, başvuruya göre bağımsız değişkenleri geçirmek için tasarım amacınızla bildirmek üzere değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="253c8-178">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="253c8-179">Bu bağımsız değişken olarak kullanılan nesneyi değiştirmek istemediğiniz.</span><span class="sxs-lookup"><span data-stu-id="253c8-179">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="253c8-180">Bu yöntem genellikle daha büyük bir salt okunur değer türleri için performansı geliştirir <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="253c8-180">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="253c8-181">Basit türleri için (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` ve `bool`, ve `enum` türleri), tüm olası performans artışı düşüktür.</span><span class="sxs-lookup"><span data-stu-id="253c8-181">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="253c8-182">Aslında, performans geçişi tarafından başvuru türleri için küçük kullanarak düşebilir <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="253c8-182">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="253c8-183">Aşağıdaki kod örneği, 3B alanda iki nokta arasındaki uzaklığı hesaplar bir yöntemin gösterir.</span><span class="sxs-lookup"><span data-stu-id="253c8-183">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="253c8-184">Her üç çiftten içeren iki yapıları bağımsız değişkenler.</span><span class="sxs-lookup"><span data-stu-id="253c8-184">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="253c8-185">Bir çift 8 bayt olduğundan her bağımsız değişken 24 bayttır.</span><span class="sxs-lookup"><span data-stu-id="253c8-185">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="253c8-186">Belirterek `in` değiştiricisi, geçirdiğiniz bir 4 baytlık veya o bağımsız değişkenlerle 8 baytlık başvuru makine mimarisine bağlı olarak.</span><span class="sxs-lookup"><span data-stu-id="253c8-186">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="253c8-187">Boyutu fark küçüktür, ancak uygulamanız bu yöntemi kullanarak birçok farklı değerler sıkı bir döngüde çağırdığında toplar.</span><span class="sxs-lookup"><span data-stu-id="253c8-187">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="253c8-188">`in` Değiştiricisi destekleyici `out` ve `ref` başka yöntemler de.</span><span class="sxs-lookup"><span data-stu-id="253c8-188">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="253c8-189">Yalnızca içinde varken, farklı bir yöntem aşırı yüklemeleri oluşturulamıyor `in`, `out`, veya `ref`.</span><span class="sxs-lookup"><span data-stu-id="253c8-189">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="253c8-190">Bu yeni kurallar her zaman için tanımlanmış aynı davranışı genişletmek `out` ve `ref` parametreleri.</span><span class="sxs-lookup"><span data-stu-id="253c8-190">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="253c8-191">Gibi `out` ve `ref` değiştiriciler, değer türleri değildir çünkü Kutulu `in` değiştiricisi uygulanır.</span><span class="sxs-lookup"><span data-stu-id="253c8-191">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="253c8-192">`in` Değiştiricisi parametre almayan herhangi bir üyeye uygulanan: yöntemleri, temsilciler, lambda ifadeleri, yerel İşlevler, Dizinleyicileri, işleçleri.</span><span class="sxs-lookup"><span data-stu-id="253c8-192">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="253c8-193">Başka bir özelliği `in` parametreleri olduğundan, değişmez değerler veya sabit bağımsız değişkeni için kullanabilir, bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="253c8-193">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="253c8-194">Ayrıca, farklı bir `ref` veya `out` parametresi, geçerli gerekmeyen `in` çağrı sitesinde değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="253c8-194">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="253c8-195">Aşağıdaki kod çağırmanın iki örnek gösterir `CalculateDistance` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="253c8-195">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="253c8-196">İlk iki yerel değişkenini başvuruya göre geçirilen kullanır.</span><span class="sxs-lookup"><span data-stu-id="253c8-196">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="253c8-197">İkinci yöntem çağrısının bir parçası olarak oluşturulan geçici bir değişken içerir.</span><span class="sxs-lookup"><span data-stu-id="253c8-197">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="253c8-198">Derleyici salt okunur doğasını zorlar birkaç şekilde bir `in` bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="253c8-198">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="253c8-199">İlk olarak çağrılan yöntem doğrudan atayamazsınız bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="253c8-199">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="253c8-200">Herhangi bir alan için doğrudan atanamaz bir `in` değeri olduğunda parametresi bir `struct` türü.</span><span class="sxs-lookup"><span data-stu-id="253c8-200">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="253c8-201">Ayrıca, geçirilemez bir `in` kullanarak herhangi bir yöntem için parametre `ref` veya `out` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="253c8-201">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="253c8-202">Bu kurallar herhangi bir alan için geçerli bir `in` parametre, sağlanan alan bir `struct` türü ve parametre bir `struct` türü.</span><span class="sxs-lookup"><span data-stu-id="253c8-202">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="253c8-203">Üye erişimi tüm düzeylerinde türleri birden çok üye erişimi katmanı sağlanan bu kurallar aslında uygulanmasını `structs`.</span><span class="sxs-lookup"><span data-stu-id="253c8-203">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="253c8-204">Derleyici, zorlar `struct` türleri olarak geçirildi `in` bağımsız değişkenleri ve bunların `struct` üyesi olan diğer yöntemlerinin bağımsız değişkenleri olarak kullanılan salt okunur değişkenler.</span><span class="sxs-lookup"><span data-stu-id="253c8-204">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="253c8-205">Kullanımını `in` parametrelerinden olası performans maliyetini kopyalarının kaçının.</span><span class="sxs-lookup"><span data-stu-id="253c8-205">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="253c8-206">Bu, herhangi bir yöntem çağrısının semantiği değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="253c8-206">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="253c8-207">Bu nedenle, belirtmeniz gerekmez `in` çağrı sitesinde değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="253c8-207">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="253c8-208">Atlama `in` değiştiricisi çağrı sitesinde bildirir derleyici bağımsız değişkeni aşağıdaki nedenlerle bir kopyasını yapma izni:</span><span class="sxs-lookup"><span data-stu-id="253c8-208">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="253c8-209">Örtük bir dönüştürme ancak olmayan bir kimlik dönüştürme bağımsız değişken türü parametre türü vardır.</span><span class="sxs-lookup"><span data-stu-id="253c8-209">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="253c8-210">Bağımsız değişken ifade ancak bilinen depolama değişkeni yok.</span><span class="sxs-lookup"><span data-stu-id="253c8-210">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="253c8-211">Mevcut bir aşırı yükleme olan varlığı veya yokluğu ile farklı `in`.</span><span class="sxs-lookup"><span data-stu-id="253c8-211">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="253c8-212">Bu durumda, değere göre aşırı daha iyi bir eşleşmedir.</span><span class="sxs-lookup"><span data-stu-id="253c8-212">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="253c8-213">Bu kurallar, mevcut kodu salt okunur başvuru bağımsız değişkenleri kullanın güncelleştirmelerden yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="253c8-213">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="253c8-214">Çağrılan yöntemde, değer parametreleri kullanan herhangi bir örnek yöntemi çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="253c8-214">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="253c8-215">Bu durumlarda, bir kopyasını `in` parametre oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="253c8-215">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="253c8-216">Derleyici için geçici değişken oluşturabilir çünkü `in` parametresi varsayılan değerler için belirtebilirsiniz `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="253c8-216">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="253c8-217">Aşağıdaki kod, ikinci noktası için varsayılan değer olarak (noktası 0,0) kaynak belirtir:</span><span class="sxs-lookup"><span data-stu-id="253c8-217">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="253c8-218">Salt okunur bağımsız değişkenleri başvuruya göre geçiren zorlamak için bu seçeneği belirtin `in` çağrı sitesinde aşağıdaki kodda gösterildiği gibi bağımsız değişkenlerde değiştiricisi:</span><span class="sxs-lookup"><span data-stu-id="253c8-218">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="253c8-219">Bu davranışı benimsemeye kolaylaştırır `in` parametreleri zaman içinde büyük kod tabanlarında nerede performans artışı mümkündür.</span><span class="sxs-lookup"><span data-stu-id="253c8-219">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="253c8-220">Eklediğiniz `in` değiştirici yöntem imzaları için ilk.</span><span class="sxs-lookup"><span data-stu-id="253c8-220">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="253c8-221">Daha sonra ekleyebilirsiniz `in` değiştiricisi, çağrı siteleri ve oluşturma `readonly struct` savunma kopyası oluşturmaktan kaçınmak derleyicinin etkinleştirmek için türleri `in` daha fazla konumda parametreleri.</span><span class="sxs-lookup"><span data-stu-id="253c8-221">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="253c8-222">`in` Parametresi ataması, de başvuru türleri veya sayısal değerleri ile kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="253c8-222">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="253c8-223">Ancak, varsa minimum avantajlarından her iki durumda değildir.</span><span class="sxs-lookup"><span data-stu-id="253c8-223">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="never-use-mutable-structs-as-in-in-argument"></a><span data-ttu-id="253c8-224">Mutable yapılar gibi kullanmamanız `in` bağımsız değişken</span><span class="sxs-lookup"><span data-stu-id="253c8-224">Never use mutable structs as in `in` argument</span></span>

<span data-ttu-id="253c8-225">Yukarıda açıklanan teknikleri, başvurular döndüren ve başvuruya göre değerler geçirerek kopyaları önlemek açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="253c8-225">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="253c8-226">Bağımsız değişken türü olarak bildirilmemişse, bu teknikler en iyi şekilde çalıştığı `readonly struct` türleri.</span><span class="sxs-lookup"><span data-stu-id="253c8-226">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="253c8-227">Aksi halde, derleyici oluşturmalısınız **savunma kopyası** herhangi bir bağımsız değişken salt okunur durumunu uygulamak, birçok durumda.</span><span class="sxs-lookup"><span data-stu-id="253c8-227">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="253c8-228">3B bir başlangıç noktasından uzaklığı hesaplar aşağıdaki örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="253c8-228">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="253c8-229">`Point3D` Yapısıdır *değil* salt okunur yapı.</span><span class="sxs-lookup"><span data-stu-id="253c8-229">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="253c8-230">Bu yöntemin gövdesinde altı farklı özellik erişim çağrıları vardır.</span><span class="sxs-lookup"><span data-stu-id="253c8-230">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="253c8-231">İlk incelemesi üzerinde bu erişimi güvenli olduğunu düşündük.</span><span class="sxs-lookup"><span data-stu-id="253c8-231">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="253c8-232">Sonuçta bir `get` erişimci nesne durumunu değiştirme olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="253c8-232">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="253c8-233">Ancak, zorlayan dil kural yoktur.</span><span class="sxs-lookup"><span data-stu-id="253c8-233">But there's no language rule that enforces that.</span></span> <span data-ttu-id="253c8-234">Bu genel bir kural olur.</span><span class="sxs-lookup"><span data-stu-id="253c8-234">It's only a common convention.</span></span> <span data-ttu-id="253c8-235">Her türlü uygulayabileceğine bir `get` iç durumu değiştirildiğinde erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="253c8-235">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="253c8-236">Bazı dil garanti derleyici herhangi bir üyenin çağırmadan önce bağımsız değişkenin bir geçici kopya oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="253c8-236">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member.</span></span> <span data-ttu-id="253c8-237">Geçici depolama yığında oluşturulur, bağımsız değişken değerlerini geçici depolama alanına kopyalanır ve değer her üye erişimi yığını kopyalanır `this` bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="253c8-237">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="253c8-238">Çoğu durumda, bu kopya yeterince bu geçişi değere göre daha hızlı geçişi tarafından salt okunur başvuru bağımsız değişken türü olmadığı durumlarda performans zarar bir `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="253c8-238">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct`.</span></span>

<span data-ttu-id="253c8-239">Bunun yerine, uzaklık hesaplama sabit yapısı kullanıyorsa `ReadonlyPoint3D`, geçici nesneler gerekmiyor:</span><span class="sxs-lookup"><span data-stu-id="253c8-239">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects are not needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="253c8-240">Üyeleri çağırdığınızda derleyici daha verimli kod oluşturur bir `readonly struct`: `this` Başvuru, alıcı bir kopyasını yerine, her zaman bir `in` parametresine geçirilen başvuruyla üye yöntemi.</span><span class="sxs-lookup"><span data-stu-id="253c8-240">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="253c8-241">Bu iyileştirme kaydeder kullandığınızda kopyalama bir `readonly struct` olarak bir `in` bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="253c8-241">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="253c8-242">Boş değer atanabilir değer türü olarak geçirmeniz değil bir `in` bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="253c8-242">You should not pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="253c8-243"><xref:System.Nullable%601> Türü salt okunur yapı bildirilmedi.</span><span class="sxs-lookup"><span data-stu-id="253c8-243">The <xref:System.Nullable%601> type is not declared as a read-only struct.</span></span> <span data-ttu-id="253c8-244">Anlamına gelir derleyici herhangi bir boş değer atanabilen değer türü bağımsız değişken için savunma kopya oluşturması gerektiğini kullanarak bir yönteme geçirilen `in` parametreyi bildirimde değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="253c8-244">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="253c8-245">Kullanarak performans farklarını gösteren bir örnek program gördüğünüz [Benchmark.net](https://www.nuget.org/packages/BenchmarkDotNet/) de bizim [örnekleri depomuzdan](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) GitHub üzerinde.</span><span class="sxs-lookup"><span data-stu-id="253c8-245">You can see an example program that demonstrates the performance differences using [Benchmark.net](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="253c8-246">Değere ve başvuruya göre değişmez bir yapı geçirme ile değere ve başvuruya göre değişebilir yapı geçirme ile karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="253c8-246">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="253c8-247">Hızlı Başvuru ile geçişi ve sabit yapı kullanılır.</span><span class="sxs-lookup"><span data-stu-id="253c8-247">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="253c8-248">Kullanım `ref struct` blokları veya bellek ile tek bir yığın çerçevesi üzerinde çalışmak için türleri</span><span class="sxs-lookup"><span data-stu-id="253c8-248">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="253c8-249">Tek yığın çerçevesi için kısıtlı bir değer türünün bildirimi olanağı ilgili dil özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="253c8-249">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="253c8-250">Bu kısıtlama, çeşitli iyileştirmeler yapmak için derleyici sağlar.</span><span class="sxs-lookup"><span data-stu-id="253c8-250">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="253c8-251">Bu özellik için birincil motivasyon olan <xref:System.Span%601> ve ilişkili yapıları.</span><span class="sxs-lookup"><span data-stu-id="253c8-251">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="253c8-252">Bu geliştirmeler performans iyileştirmeleri yeni kullanarak elde edersiniz ve güncelleştirilmiş .NET API kullanımını <xref:System.Span%601> türü.</span><span class="sxs-lookup"><span data-stu-id="253c8-252">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="253c8-253">Kullanılarak oluşturulan bellek ile çalışmaya benzer gereksinimlerine sahip olabilir [ `stackalloc` ](language-reference/operators/stackalloc.md) veya Interop API'leri bellekten kullanırken.</span><span class="sxs-lookup"><span data-stu-id="253c8-253">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="253c8-254">Kendi tanımlayabilirsiniz `ref struct` türleri bu ihtiyaçları için.</span><span class="sxs-lookup"><span data-stu-id="253c8-254">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="253c8-255">`readonly ref struct` Türü</span><span class="sxs-lookup"><span data-stu-id="253c8-255">`readonly ref struct` type</span></span>

<span data-ttu-id="253c8-256">Bir yapı olarak bildirme `readonly ref` avantajları ve kısıtlamaları birleştirir `ref struct` ve `readonly struct` bildirimleri.</span><span class="sxs-lookup"><span data-stu-id="253c8-256">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="253c8-257">Tek yığın çerçevesi için salt okunur aralık tarafından kullanılan bellek sınırlıdır ve salt okunur aralık tarafından kullanılan bellek değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="253c8-257">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="253c8-258">Sonuçlar</span><span class="sxs-lookup"><span data-stu-id="253c8-258">Conclusions</span></span>

<span data-ttu-id="253c8-259">Değer türleri kullanarak ayırma işlemlerinin sayısını en aza indirir:</span><span class="sxs-lookup"><span data-stu-id="253c8-259">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="253c8-260">Değer türleri için depolama, yerel değişkenleri ve yöntem bağımsız değişkenleri için ayrılan yığınıdır.</span><span class="sxs-lookup"><span data-stu-id="253c8-260">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="253c8-261">Depolama alanı diğer nesne üyeleri değer türleri için ayrı bir ayırma olarak değil o nesnenin bir parçası olarak ayrılır.</span><span class="sxs-lookup"><span data-stu-id="253c8-261">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="253c8-262">Değer türü için depolama dönüş değeri ayrılan yığın.</span><span class="sxs-lookup"><span data-stu-id="253c8-262">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="253c8-263">Başvuru türleri aynı bu durumlarda ile karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="253c8-263">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="253c8-264">Yığın yerel değişkenleri ve yöntem bağımsız değişkenleri için ayrılan depolama başvuru türleri için var.</span><span class="sxs-lookup"><span data-stu-id="253c8-264">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="253c8-265">Yığında başvuru depolanır.</span><span class="sxs-lookup"><span data-stu-id="253c8-265">The reference is stored on the stack.</span></span>
- <span data-ttu-id="253c8-266">Diğer nesne üyeleri başvuru türleri için depolama ayrı olarak yığında ayrılır.</span><span class="sxs-lookup"><span data-stu-id="253c8-266">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="253c8-267">Başvuru içeren bir nesne depolar.</span><span class="sxs-lookup"><span data-stu-id="253c8-267">The containing object stores the reference.</span></span>
- <span data-ttu-id="253c8-268">Başvuru türü için depolama dönüş değeri ayrılan yığın.</span><span class="sxs-lookup"><span data-stu-id="253c8-268">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="253c8-269">Yığında başvuru depolama depolanır.</span><span class="sxs-lookup"><span data-stu-id="253c8-269">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="253c8-270">Ayırmaları en aza ödünler.</span><span class="sxs-lookup"><span data-stu-id="253c8-270">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="253c8-271">Daha fazla bellek kopyalama zaman boyutu `struct` başvuru boyutundan büyük.</span><span class="sxs-lookup"><span data-stu-id="253c8-271">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="253c8-272">Başvuru, genellikle 64 bit veya 32 bit olduğundan ve hedef makine CPU üzerinde bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="253c8-272">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="253c8-273">Bu bileşim genellikle en az düzeyde performans etkisi olur.</span><span class="sxs-lookup"><span data-stu-id="253c8-273">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="253c8-274">Ancak, büyük yapılar veya daha büyük koleksiyonlar için performans etkisini artar.</span><span class="sxs-lookup"><span data-stu-id="253c8-274">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="253c8-275">Etkisi sıkı döngüler ve programlar için etkin yolları büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="253c8-275">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="253c8-276">Bu geliştirmeler C# dil performans kritik algoritmaları burada bellek ayırmaları en aza indirmek için gerekli performansı ulaşmada önemli bir etken tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="253c8-276">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="253c8-277">Yazdığınız kod bu özellikleri sık kullanmadığınız bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="253c8-277">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="253c8-278">Ancak, bu geliştirmeler, .NET uyarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="253c8-278">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="253c8-279">Giderek daha fazla API yaparken bu özelliklerini kullanmak, uygulamalarınızın performansını artırma görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="253c8-279">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="253c8-280">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="253c8-280">See also</span></span>

- [<span data-ttu-id="253c8-281">ref anahtar sözcüğü</span><span class="sxs-lookup"><span data-stu-id="253c8-281">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="253c8-282">Ref dönüşler ve ref yerel ayarlar</span><span class="sxs-lookup"><span data-stu-id="253c8-282">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)

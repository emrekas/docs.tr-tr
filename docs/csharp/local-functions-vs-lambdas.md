---
title: Lambda ifadeleri ve yerel işlevler
description: Yerel işlevler lambda ifadeleri daha iyi bir seçim neden olabiliyor öğrenin.
ms.date: 06/27/2016
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 17ad1e8782adbf9e0f892d72849e58ef9c5ddce1
ms.sourcegitcommit: 16aefeb2d265e69c0d80967580365fabf0c5d39a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/16/2019
ms.locfileid: "58125778"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="c7e81-103">Lambda ifadeleri karşılaştırma yerel işlevler</span><span class="sxs-lookup"><span data-stu-id="c7e81-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="c7e81-104">İlk bakışta [yerel işlevler](programming-guide/classes-and-structs/local-functions.md) ve [lambda ifadeleri](./programming-guide/statements-expressions-operators/lambda-expressions.md) çok benzer.</span><span class="sxs-lookup"><span data-stu-id="c7e81-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="c7e81-105">Çoğu durumda, lambda ifadeleri ve yerel işlevleri kullanma arasında seçim, stil ve kişisel tercihinize bir konudur.</span><span class="sxs-lookup"><span data-stu-id="c7e81-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="c7e81-106">Ancak, birini veya diğerini farkında olmanız gereken kullanabileceğiniz gerçek farklar vardır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="c7e81-107">Yerel işlev ve lambda ifadesi uygulamaları Faktöriyel algoritmasının arasındaki farklar inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="c7e81-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="c7e81-108">İlk yerel bir işlevi kullanarak sürüm:</span><span class="sxs-lookup"><span data-stu-id="c7e81-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="c7e81-109">Bu uygulamayı lambda ifadelerini kullanan bir sürüm ile karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="c7e81-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="c7e81-110">Yerel işlevler adlarına sahip.</span><span class="sxs-lookup"><span data-stu-id="c7e81-110">The local functions have names.</span></span> <span data-ttu-id="c7e81-111">Lambda ifadeleri olan değişkenlere eklendiklerinde anonim yöntemler olan `Func` veya `Action` türleri.</span><span class="sxs-lookup"><span data-stu-id="c7e81-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="c7e81-112">Yerel bir işlev bildirdiğinizde, bağımsız değişken türleri ve dönüş türü, işlev bildirimi parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="c7e81-113">Lambda gövdesi bir parçası olmak yerine ifade, bağımsız değişken türleri ve dönüş türü, lambda ifadesinin değişken türü bildirimi parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="c7e81-114">Bu iki fark NET kod oluşturulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e81-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="c7e81-115">Yerel İşlevler, lambda ifadeleri daha kesin atama için farklı kuralları vardır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="c7e81-116">Yerel işlev bildirimi kapsam içinde olduğu herhangi bir kod konumdan başvurulabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e81-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="c7e81-117">Bir temsilci değişkenine bir lambda ifadesi bu erişileceği (veya lambda ifadesi başvuran temsilci adlı önce.) atanmalıdır Lambda ifadesi kullanarak sürüm bildirmeli ve lambda ifadesi başlatmak, bildirim `nthFactorial` kendisini tanımlayan önce.</span><span class="sxs-lookup"><span data-stu-id="c7e81-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="c7e81-118">Bunu yapmazsanız sonuçlanıyor başvuran bir derleme zamanı hatası `nthFactorial` atayarak önce.</span><span class="sxs-lookup"><span data-stu-id="c7e81-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="c7e81-119">Bu farklılıklar, yinelemeli algoritmalar yerel işlevler kullanarak oluşturmak daha kolay anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="c7e81-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="c7e81-120">Bildirme ve kendi kendini çağıran yerel bir fonksiyon tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="c7e81-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="c7e81-121">Lambda ifadeleri gerekir bildirilmiş ve aynı lambda ifadesi başvuran bir gövde yeniden atanan kullanılabilmesi için öncelikle bir varsayılan değer atanır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="c7e81-122">Belirli atama onayına kuralları, yerel bir işlev veya lambda ifadesi tarafından yakalanan tüm değişkenleri de etkiler.</span><span class="sxs-lookup"><span data-stu-id="c7e81-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="c7e81-123">Hem yerel işlevler hem de lambda ifadesi kuralları isteğe bağlı yerel işlev veya lambda ifadesi bir temsilciye dönüştürüldüğünde yakalanan tüm değişkenlere kesinlikle noktada atanır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="c7e81-124">Lambda ifadeleri, bildirildikleri temsilcileri dönüştürülür farktır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="c7e81-125">Yerel işlevler yalnızca temsilci olarak kullanıldığında temsilciler dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="c7e81-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="c7e81-126">Yerel bir işlevi bildirmek ve gibi bir yöntem çağırarak yalnızca başvuru, bir temsilciye dönüştürülmez.</span><span class="sxs-lookup"><span data-stu-id="c7e81-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="c7e81-127">Bu kural, kapsayan kapsamı uygun bir konumda yerel bir işlevi bildirmek sağlar.</span><span class="sxs-lookup"><span data-stu-id="c7e81-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="c7e81-128">Yerel işlevler üst yönteminin sonunda tüm dönüş deyimleri sonra bildirmek için yaygındır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="c7e81-129">Üçüncü olarak, derleyici kesinlikle kapsayan kapsam içinde yakalanan değişkenlere atamak yerel işlevler sağlayan statik analiz gerçekleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e81-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="c7e81-130">Bu örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="c7e81-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="c7e81-131">Derleyici, belirleyebilirsiniz `LocalFunction` kesinlikle atar `y` çağrıldığında.</span><span class="sxs-lookup"><span data-stu-id="c7e81-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="c7e81-132">Çünkü `LocalFunction` önce çağrılır `return` deyimi `y` kesinlikle atanmıştır `return` deyimi.</span><span class="sxs-lookup"><span data-stu-id="c7e81-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="c7e81-133">Örnek analysis sağlayan analiz dördüncü fark sağlar.</span><span class="sxs-lookup"><span data-stu-id="c7e81-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="c7e81-134">Kullanımları bağlı olarak, her zaman lambda ifadeleri için gerekli olan yığın ayırmaları yerel işlevler önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e81-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="c7e81-135">Yerel bir işlev hiçbir zaman bir temsilciye dönüştürülmüş ve diğer lambdalar veya temsilciye dönüştürülmüş yerel işlevler tarafından yakalanan yerel işlev tarafından yakalanan değişkenler hiçbiri, derleyicinin yığın ayırmaları önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e81-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="c7e81-136">Bu zaman uyumsuz örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="c7e81-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="c7e81-137">Bu bir lambda ifadesi için kapatma içeren `address`, `index` ve `name` değişkenleri.</span><span class="sxs-lookup"><span data-stu-id="c7e81-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="c7e81-138">Yerel işlevler söz konusu olduğunda, kapanış uygulayan nesnenin olabilir bir `struct` türü.</span><span class="sxs-lookup"><span data-stu-id="c7e81-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="c7e81-139">Bu yapı türü, yerel bir işlev başvurusu tarafından geçirilir.</span><span class="sxs-lookup"><span data-stu-id="c7e81-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="c7e81-140">Bu fark, uygulama üzerinde bir ayırma kaydeder.</span><span class="sxs-lookup"><span data-stu-id="c7e81-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="c7e81-141">Lambda ifadeleri için gerekli örnek oluşturma, zaman açısından kritik kod yolları bir performans faktör olabilecek ek bellek ayırmaları anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="c7e81-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="c7e81-142">Yerel işlevler bu yüküne tabi değildir.</span><span class="sxs-lookup"><span data-stu-id="c7e81-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="c7e81-143">Yukarıdaki örnekte, 2, lambda ifadesi sürümden daha az ayırmaları yerel işlevler sürümüyle vardır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e81-144">Bu yöntem yerel işlev denk bir sınıf Kapatılmak üzere de kullanır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="c7e81-145">Bir yerel işlevin kabini olarak uygulanıp bir `class` veya `struct` bir uygulama ayrıntısı olduğunu.</span><span class="sxs-lookup"><span data-stu-id="c7e81-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="c7e81-146">Yerel bir işlev kullanabilir bir `struct` bir lambda her zaman kullanır ancak bir `class`.</span><span class="sxs-lookup"><span data-stu-id="c7e81-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="c7e81-147">Bu örnekte gösterilmiştir değil son avantajlarından biri yerel işlevler kullanarak yineleyiciler uygulanabilir `yield return` değerler üretmek için söz dizimi.</span><span class="sxs-lookup"><span data-stu-id="c7e81-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="c7e81-148">`yield return` Deyimi lambda ifadelerine izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="c7e81-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="c7e81-149">Yerel işlevler lambda ifadeleri için yedekli olarak görünebilir, ancak bunlar gerçekten farklı amaçlara hizmet eder ve sahip farklı kullanır.</span><span class="sxs-lookup"><span data-stu-id="c7e81-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="c7e81-150">Yalnızca başka bir yöntem bağlamından çağrılan bir işlev yazmak istediğiniz zaman yerel işlevler çalışması için daha verimlidir.</span><span class="sxs-lookup"><span data-stu-id="c7e81-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

---
title: Desen eşleştirme C# Kılavuzu
description: Desen eşleştirme ifadelerinde C# öğrenin
ms.date: 04/10/2019
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 5ace3c4552184b848b90dee3516d549ca8fd5806
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61652032"
---
# <a name="pattern-matching"></a><span data-ttu-id="8d71d-103">Desen Eşleştirme</span><span class="sxs-lookup"><span data-stu-id="8d71d-103">Pattern Matching</span></span>

<span data-ttu-id="8d71d-104">Desenler test değeri belirli bir sahip *şekli*ve *ayıklamak* eşleşen şekil sahip olduğunda bu değerden daha fazla bilgi.</span><span class="sxs-lookup"><span data-stu-id="8d71d-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="8d71d-105">Desen eşleştirme bugün kullanmakta olduğunuz algoritmaları için daha kısa bir söz dizimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="8d71d-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="8d71d-106">Zaten mevcut söz dizimini kullanarak algoritmaları desen de oluşturun.</span><span class="sxs-lookup"><span data-stu-id="8d71d-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="8d71d-107">Yazdığınız `if` veya `switch` test değerleri deyimleri.</span><span class="sxs-lookup"><span data-stu-id="8d71d-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="8d71d-108">Ardından bu deyimleri eşleştiğinde ayıklayın ve bu değer bilgileri kullanın.</span><span class="sxs-lookup"><span data-stu-id="8d71d-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="8d71d-109">Yeni sözdizimi öğeleri, zaten alışık olduğunuz deyimleri uzantılarıdır: `is` ve `switch`.</span><span class="sxs-lookup"><span data-stu-id="8d71d-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="8d71d-110">Bu yeni uzantılar bir değer test etme ve bu bilgileri ayıklamak birleştirin.</span><span class="sxs-lookup"><span data-stu-id="8d71d-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="8d71d-111">Bu makalede, okunabilir, kısa kodu nasıl bağlayabileceğinizi göstermek için yeni sözdizimine inceleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="8d71d-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="8d71d-112">Desen eşleştirme deyimleri burada veri ve kodu, nesne yönelimli tasarımlarında burada veri ve üzerlerinde değişiklik yöntemleri sıkı şekilde bağlı ayrılmış sağlar.</span><span class="sxs-lookup"><span data-stu-id="8d71d-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="8d71d-113">Bu yeni deyimleri göstermek için ifadeleri desen kullanarak geometrik şekiller temsil eden yapılar ile çalışalım.</span><span class="sxs-lookup"><span data-stu-id="8d71d-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="8d71d-114">Sınıf Hiyerarşiler oluşturma ve oluşturma ile biliyor [sanal ve geçersiz kılınan yöntemleri](methods.md#inherited) nesnenin çalışma zamanı türüne göre nesne davranışını özelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8d71d-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="8d71d-115">Bu tekniklerin bir sınıf hiyerarşisini, yapısal olmayan veriler için mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="8d71d-116">Verilere ve yöntemlere ayrı diğer araçları gerekir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="8d71d-117">Yeni *desen eşleştirme* verilerini inceleme ve düzenleme denetim akışı verileri bir koşula göre temizleme söz dizimi yapıları etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="8d71d-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="8d71d-118">Zaten yazma `if` deyimleri ve `switch` bir değişkenin değeri test edin.</span><span class="sxs-lookup"><span data-stu-id="8d71d-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="8d71d-119">Yazdığınız `is` bir değişkenin türünü test deyimleri.</span><span class="sxs-lookup"><span data-stu-id="8d71d-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="8d71d-120">*Desen eşleştirme* bu deyimleri için yeni özellikleri ekler.</span><span class="sxs-lookup"><span data-stu-id="8d71d-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="8d71d-121">Bu makalede, farklı geometrik şekiller alanını hesaplayan bir yöntem oluşturacaksınız.</span><span class="sxs-lookup"><span data-stu-id="8d71d-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="8d71d-122">Ancak, nesne yönelimli teknikleri ile maksimum ve farklı şekilleri için bir sınıf hiyerarşisi oluşturma olmadan gerçekleştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8d71d-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="8d71d-123">Kullanacağınız *desen eşleştirme* yerine.</span><span class="sxs-lookup"><span data-stu-id="8d71d-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="8d71d-124">Bu kod ile nasıl, bir nesne hiyerarşisine yapılandırılmış olması, bu örnek giderken, karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="8d71d-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="8d71d-125">Bir sınıf hiyerarşisi verileri sorgulama ve düzenleme gerekir olmadığı durumlarda, desen eşleştirme zarif bir tasarım sağlar.</span><span class="sxs-lookup"><span data-stu-id="8d71d-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="8d71d-126">Bir soyut şekil tanımı ile başlayan ve farklı belirli şekil sınıfları eklemek yerine, bunun yerine basit verilerle yalnızca tanımları her geometrik şekiller başlayalım:</span><span class="sxs-lookup"><span data-stu-id="8d71d-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="8d71d-127">Bu yapıları, bazı şekli alanını hesaplayan bir yöntem yazalım.</span><span class="sxs-lookup"><span data-stu-id="8d71d-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="8d71d-128">`is` Desen ifadesi yazın</span><span class="sxs-lookup"><span data-stu-id="8d71d-128">The `is` type pattern expression</span></span>

<span data-ttu-id="8d71d-129">C# 7.0 önce bir dizide her tür test gerekecektir `if` ve `is` ifadeleri:</span><span class="sxs-lookup"><span data-stu-id="8d71d-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="8d71d-130">Yukarıdaki kod, klasik bir ifade olduğunu *türü deseni*: Bir değişken türünü belirlemek için test etme ve bu türüne göre farklı bir eylem gerçekleştirmesine.</span><span class="sxs-lookup"><span data-stu-id="8d71d-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="8d71d-131">Bu kod daha basit hale uzantılarını kullanarak `is` ifade bir değişken ise test atamak için başarılı olur:</span><span class="sxs-lookup"><span data-stu-id="8d71d-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="8d71d-132">Bu güncelleştirilmiş sürüm `is` ifade hem değişken test eder ve uygun türde yeni bir değişkene atar.</span><span class="sxs-lookup"><span data-stu-id="8d71d-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="8d71d-133">Ayrıca, bu sürüm içeren bildirim `Rectangle` türünü bir `struct`.</span><span class="sxs-lookup"><span data-stu-id="8d71d-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="8d71d-134">Yeni `is` ifade, başvuru türleri yanı sıra değer türleri ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="8d71d-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="8d71d-135">Desen eşleştirme ifadeler için dil kuralları bir eşleme ifadesi sonuçlarını kötüye önlemenize yardımcı.</span><span class="sxs-lookup"><span data-stu-id="8d71d-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="8d71d-136">Değişkenleri yukarıdaki örnekte `s`, `c`, ve `r` yalnızca kapsamındaki ve ilgili deseni eşleşme ifadeleri olduğunda kesinlikle atanan `true` sonuçları.</span><span class="sxs-lookup"><span data-stu-id="8d71d-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="8d71d-137">Başka bir konuma ya da değişken kullanmayı denerseniz, kodunuzu derleyici hataları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8d71d-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="8d71d-138">Ayrıntılı kapsam ile başlayarak, bu kuralların her ikisi de inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="8d71d-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="8d71d-139">Değişken `c` kapsamındaki yalnızca `else` ilk dal `if` deyimi.</span><span class="sxs-lookup"><span data-stu-id="8d71d-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="8d71d-140">Değişken `s` yöntemi kapsam içinde `ComputeAreaModernIs`.</span><span class="sxs-lookup"><span data-stu-id="8d71d-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="8d71d-141">Çünkü her dal, bir `if` ifade değişkenleri için ayrı bir kapsam oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8d71d-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="8d71d-142">Ancak, `if` beyannamesi değil.</span><span class="sxs-lookup"><span data-stu-id="8d71d-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="8d71d-143">İçinde bildirilmiş değişkenlerin anlamına `if` deyimi olan aynı kapsamda `if` deyimi (Bu durumda yöntem.) Bu davranış desen eşleştirme için özgü değildir, ancak değişken kapsam için tanımlanan davranıştır ve `if` ve `else` deyimleri.</span><span class="sxs-lookup"><span data-stu-id="8d71d-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="8d71d-144">Değişkenleri `c` ve `s` ne zaman atanmış olan ilgili `if` deyimleri true kesinlikle atanan nedeniyle zaman true mekanizması.</span><span class="sxs-lookup"><span data-stu-id="8d71d-144">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="8d71d-145">Bu konudaki örnekler önerilen yapısı, bir desen eşleme yerlerde kullanın. `is` ifade kesinlikle atar eşleşme değişkende `true` dalı `if` deyimi.</span><span class="sxs-lookup"><span data-stu-id="8d71d-145">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="8d71d-146">Mantığı tarafından bildiren tersine çevirebilir `if (!(shape is Square s))` ve değişken `s` kesinlikle yalnızca atanmış olur `false` dal.</span><span class="sxs-lookup"><span data-stu-id="8d71d-146">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="8d71d-147">Bu geçerli bir C# olsa da, mantıksal izlemek daha karmaşık olduğu için önerilmez.</span><span class="sxs-lookup"><span data-stu-id="8d71d-147">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="8d71d-148">Bu kurallar bu desene karşılanmadığı durumların yanlışlıkla bir desen eşleştirme ifadesi sonucu erişmeye olası anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-148">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="8d71d-149">Desen eşleştirme kullanarak `switch` deyimleri</span><span class="sxs-lookup"><span data-stu-id="8d71d-149">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="8d71d-150">Zaman gibi diğer şekil türleri desteklemek gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-150">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="8d71d-151">Koşullar test sayısı arttıkça, kullanmanın bulabilirsiniz `is` desen eşleştirme ifadelerinde zahmetli hale gelebilir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-151">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="8d71d-152">Gerektiren ek olarak `if` deyimleri, kontrol etmek istediğiniz her türüne `is` ifadeleri tek bir tür giriş eşleşmesi durumunda test sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="8d71d-152">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="8d71d-153">Bu durumda, bulabilirsiniz `switch` desen eşleştirme ifadeleri daha iyi bir seçim haline gelir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-153">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="8d71d-154">Geleneksel `switch` ifade olan bir desen ifadesi: sabit desen desteklenir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-154">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="8d71d-155">Kullanılan tüm sabit bir değişkene kıyaslayarak bir `case` deyimi:</span><span class="sxs-lookup"><span data-stu-id="8d71d-155">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="8d71d-156">Tarafından desteklenen tek desen `switch` ifadesi sabit desen oluştu.</span><span class="sxs-lookup"><span data-stu-id="8d71d-156">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="8d71d-157">Daha fazla sınırlıdır sayısal türleri olan ve `string` türü.</span><span class="sxs-lookup"><span data-stu-id="8d71d-157">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="8d71d-158">Bu kısıtlamaları kaldırılmış ve artık yazabileceğiniz bir `switch` türü desenini kullanarak deyimi:</span><span class="sxs-lookup"><span data-stu-id="8d71d-158">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="8d71d-159">Desen eşleştirme `switch` deyimi geleneksel C stili kullanan geliştiriciler için tanıdık sözdizimini kullanan `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="8d71d-159">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="8d71d-160">Her `case` değerlendirilir ve giriş değişkeni eşleşen koşul altında kod yürütülür.</span><span class="sxs-lookup"><span data-stu-id="8d71d-160">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="8d71d-161">Kod yürütmeyi "bir case ifadesinden sonraki geçemez"; söz dizimi `case` deyimi gerektirir, her `case` sonunda bir `break`, `return`, veya `goto`.</span><span class="sxs-lookup"><span data-stu-id="8d71d-161">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="8d71d-162">`goto` Başka bir etikete atlanamaz deyimleri yalnızca sabit desenini (Klasik switch deyimi) geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-162">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="8d71d-163">Düzenleyen önemli yeni kurallar `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="8d71d-163">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="8d71d-164">Değişken türünü kısıtlamalar `switch` ifadesi kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="8d71d-164">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="8d71d-165">Gibi herhangi türdeki `object` Bu örnekte, kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-165">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="8d71d-166">Case ifadesi, artık sabit değerleri için sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-166">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="8d71d-167">Bu sınırlama kaldırma anlamına gelir, yeniden sıralama `switch` bölümler, programın davranışını değişebilir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-167">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="8d71d-168">Birden fazla sabit değerleri için sınırlı olduğunda `case` etiketle değerinin eşleşen `switch` ifade.</span><span class="sxs-lookup"><span data-stu-id="8d71d-168">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="8d71d-169">Bu kuralla birleştirme, her `switch` bölüm gerekir değil sonraki bölüme dönüş yapmasına ve onu izleyen `switch` bölümleri düzenlenmeyecek herhangi bir sırada davranışını etkilemeden.</span><span class="sxs-lookup"><span data-stu-id="8d71d-169">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="8d71d-170">Artık, daha fazla genelleştirilmiş ile `switch` ifadeleri, her bölümün sırası önemlidir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-170">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="8d71d-171">`switch` İfadeleri, metinsel sırayla değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-171">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="8d71d-172">Yürütme için ilk aktarır `switch` eşleşen etiket `switch` ifade.</span><span class="sxs-lookup"><span data-stu-id="8d71d-172">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="8d71d-173">`default` Çalışması, yalnızca diğer bir durum etiketi eşleşen yürütülür.</span><span class="sxs-lookup"><span data-stu-id="8d71d-173">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="8d71d-174">`default` Çalışması bağımsız olarak metinsel sırası son olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-174">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="8d71d-175">Yoksa hiçbir `default` çalışması ve diğer hiçbiri `case` ifadeleri eşleşen, yürütme devam deyimi aşağıdaki `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="8d71d-175">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="8d71d-176">Hiçbiri `case` etiketleri kod yürütülür.</span><span class="sxs-lookup"><span data-stu-id="8d71d-176">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="8d71d-177">`when` yan tümcelerinde `case` ifadeleri</span><span class="sxs-lookup"><span data-stu-id="8d71d-177">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="8d71d-178">0 alanı kullanarak bu şekilleri için özel durumlar yapabileceğiniz bir `when` yan tümcesi `case` etiketi.</span><span class="sxs-lookup"><span data-stu-id="8d71d-178">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="8d71d-179">Bir kare yan uzunluğu 0 ile veya bir daire ile bir RADIUS 0 0 alanı vardır.</span><span class="sxs-lookup"><span data-stu-id="8d71d-179">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="8d71d-180">Bu koşul kullanarak belirttiğiniz bir `when` yan tümcesi `case` etiketi:</span><span class="sxs-lookup"><span data-stu-id="8d71d-180">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="8d71d-181">Bu değişiklik birkaç önemli noktaları hakkında yeni söz dizimini gösterir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-181">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="8d71d-182">İlk olarak, birden çok `case` etiketleri için uygulanabilir `switch` bölümü.</span><span class="sxs-lookup"><span data-stu-id="8d71d-182">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="8d71d-183">Deyim bloğu yürütülür etiketlerin hiçbirini olduğunda `true`.</span><span class="sxs-lookup"><span data-stu-id="8d71d-183">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="8d71d-184">Bu örnekte, `switch` ifade bir daire ya da bir kare 0 alanı, 0 sabiti yöntemi döndürür.</span><span class="sxs-lookup"><span data-stu-id="8d71d-184">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="8d71d-185">Bu örnek iki iki farklı değişken tanıtır `case` ilk etiket `switch` blok.</span><span class="sxs-lookup"><span data-stu-id="8d71d-185">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="8d71d-186">Dikkat Bu tablolarda `switch` bloğu ya da değişkenleri kullanma `c` (daire için) veya `s` (için kare).</span><span class="sxs-lookup"><span data-stu-id="8d71d-186">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="8d71d-187">Bu değişkenleri hiçbiri kesinlikle bu atanan `switch` blok.</span><span class="sxs-lookup"><span data-stu-id="8d71d-187">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="8d71d-188">Bu durumların herhangi birini eşleşirse, açıkça bir değişken atandı.</span><span class="sxs-lookup"><span data-stu-id="8d71d-188">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="8d71d-189">Söyleyin mümkün değildir ancak *hangi* her iki durumda da, çalışma zamanında eşleşen derleme zamanında atanmıştır.</span><span class="sxs-lookup"><span data-stu-id="8d71d-189">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="8d71d-190">Bu nedenle, çoğu kez kullandığınızda, birden çok `case` etiketleri aynı blok için yeni bir değişkende neden olmaz `case` deyimi veya yalnızca kullanacağınız değişkeninde `when` yan tümcesi.</span><span class="sxs-lookup"><span data-stu-id="8d71d-190">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="8d71d-191">0 alanı bu şekillerle eklediğiniz birkaç daha fazla şekil türleri ekleyelim: bir üçgen ve bir dikdörtgen:</span><span class="sxs-lookup"><span data-stu-id="8d71d-191">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="8d71d-192">Bu değişiklik kümesini ekler `case` bozuk durum etiketlerini ve etiketleri ve her yeni şekiller engeller.</span><span class="sxs-lookup"><span data-stu-id="8d71d-192">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="8d71d-193">Son olarak, ekleyebileceğiniz bir `null` bağımsız değişken olmadığından emin olmak için durum `null`:</span><span class="sxs-lookup"><span data-stu-id="8d71d-193">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="8d71d-194">İçin özel bir davranış `null` desendir ilginç çünkü sabiti `null` desende bir tür yoktur, ancak herhangi bir başvuru türüyle veya Null olabilen bir türle dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-194">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="8d71d-195">Yerine dönüştürme bir `null` dil herhangi bir türü tanımlayan bir `null` değerin değişkenin derleme zamanı türünden bağımsız olarak herhangi bir türü desen eşleşmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8d71d-195">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="8d71d-196">Bu davranış yeni yapar `switch` desenine türü ile tutarlı `is` deyimi: `is` return deyimleri her zaman `false` denetlenen değer olduğunda `null`.</span><span class="sxs-lookup"><span data-stu-id="8d71d-196">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="8d71d-197">Ayrıca basittir: türü denetledikten sonra ek bir null denetimi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8d71d-197">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="8d71d-198">Hiçbir null bulunmasına durum blokları yukarıdaki örnekleri hiçbirinde denetler görebilirsiniz: boş olmayan bir değer türü desen eşleştirme garanti olduğundan bunlar gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-198">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="8d71d-199">`var` bildirimlerinde `case` ifadeleri</span><span class="sxs-lookup"><span data-stu-id="8d71d-199">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="8d71d-200">Giriş `var` desen eşleşmesi için eşleşmesi ifadelerden biri tanıtan yeni kurallar.</span><span class="sxs-lookup"><span data-stu-id="8d71d-200">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="8d71d-201">İlk kuralı olan `var` bildirimini normal tür çıkarımı kurallarını izler: Türü, anahtar ifadenin statik türü olarak algılanır.</span><span class="sxs-lookup"><span data-stu-id="8d71d-201">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="8d71d-202">Bu kuraldan türü her zaman eşleşir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-202">From that rule, the type always matches.</span></span>

<span data-ttu-id="8d71d-203">İkinci kuralı olan bir `var` bildirimi, diğer tür deseni ifadeler içeren null denetimi yok.</span><span class="sxs-lookup"><span data-stu-id="8d71d-203">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="8d71d-204">Bu değişkeni boş olabilir ve bu durumda null denetimi gereklidir anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-204">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="8d71d-205">Çoğu durumda, bu iki kural anlamına bir `var` bildiriminde bir `case` ifadeyle eşleşen aynı koşullarda bir `default` ifade.</span><span class="sxs-lookup"><span data-stu-id="8d71d-205">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="8d71d-206">Herhangi bir varsayılan olmayan çalışması için tercih edilen olduğundan `default` durumda `default` durumu hiçbir zaman yürütülecek.</span><span class="sxs-lookup"><span data-stu-id="8d71d-206">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="8d71d-207">Derleyici, bu durumda bir uyarı vermez burada bir `default` çalışması yazıldı, ancak hiçbir zaman yürütülür.</span><span class="sxs-lookup"><span data-stu-id="8d71d-207">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="8d71d-208">Bu tutarlıdır geçerli `switch` deyimi davranışı nerede tüm olası durumların listeleniyor.</span><span class="sxs-lookup"><span data-stu-id="8d71d-208">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="8d71d-209">Üçüncü kuralı kullanan tanıtır burada bir `var` çalışması yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-209">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="8d71d-210">Burada Giriş bir dizedir ve bilinen komut değerlerini aradığınız deseni eşleştirmesini yaptığınızı hayal edin.</span><span class="sxs-lookup"><span data-stu-id="8d71d-210">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="8d71d-211">Benzer bir şey yazabiliriz:</span><span class="sxs-lookup"><span data-stu-id="8d71d-211">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="8d71d-212">`var` Eşleşen servis talebi `null`, boş bir dize veya yalnızca boşluk içeren herhangi bir dize.</span><span class="sxs-lookup"><span data-stu-id="8d71d-212">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="8d71d-213">Önceki kod bildirim `?.` yanlışlıkla oluşturmaz emin olmak için işleci bir <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="8d71d-213">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="8d71d-214">`default` Durumu işler bu komut ayrıştırıcı tarafından anlaşılan olmayan herhangi bir dize değeri.</span><span class="sxs-lookup"><span data-stu-id="8d71d-214">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="8d71d-215">Bu bir yere göz önünde bulundurun isteyebilirsiniz örnektir bir `var` case farklı ifade bir `default` ifade.</span><span class="sxs-lookup"><span data-stu-id="8d71d-215">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="8d71d-216">Sonuçlar</span><span class="sxs-lookup"><span data-stu-id="8d71d-216">Conclusions</span></span>

<span data-ttu-id="8d71d-217">*Eşleşen yapıları desen* denetim akışı farklı değişkenler ve devralma hiyerarşisi ile ilişkili olmayan türler arasında kolayca yönetmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="8d71d-217">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="8d71d-218">Değişkenin üzerine her türlü koşul test kullanılacak mantıksal de denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8d71d-218">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="8d71d-219">Ancak, desenler ve deyimler veri ve bu verileri işleyen yöntemler ayrı olduğu daha dağıtılmış uygulamalar oluşturmak daha sık ihtiyaç duyacağınız etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="8d71d-219">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="8d71d-220">Bu örnekte kullanılan şekli yapılar herhangi bir yöntem içermeyen fark edeceksiniz yalnızca salt okunur özellikler.</span><span class="sxs-lookup"><span data-stu-id="8d71d-220">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="8d71d-221">Herhangi bir veri türü ile Works desen.</span><span class="sxs-lookup"><span data-stu-id="8d71d-221">Pattern Matching works with any data type.</span></span> <span data-ttu-id="8d71d-222">Nesne İnceleme ifadeler yazabilirsiniz ve bu koşullara göre denetim akışı kararlar.</span><span class="sxs-lookup"><span data-stu-id="8d71d-222">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="8d71d-223">Bu örnek için bir soyut bir sınıf hiyerarşisi oluşturmaktan izlenir tasarımı ile koddan karşılaştırma `Shape` ve türetilen özel şekiller her alanı hesaplamak için sanal bir yöntem, kendi uygulama.</span><span class="sxs-lookup"><span data-stu-id="8d71d-223">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="8d71d-224">Genellikle, verilerle çalışıyorsanız ve veri depolama endişelere yer bırakmadan davranışı endişelere yer bırakmadan ayırmak istediğiniz desen eşleştirme ifadeleri çok kullanışlı bir aracı olabilir bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8d71d-224">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

---
title: Temsilcileri ve olayları ayırt etme
description: Temsilciler ve olaylar ve .NET Core, bu özelliklerin her birini kullanmak ne zaman arasındaki farkı öğrenin.
ms.date: 06/20/2016
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 2f9c26519d93314f4991829191723df5426b23b7
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61646650"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="52d6e-103">Temsilcileri ve olayları ayırt etme</span><span class="sxs-lookup"><span data-stu-id="52d6e-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="52d6e-104">Önceki</span><span class="sxs-lookup"><span data-stu-id="52d6e-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="52d6e-105">Genellikle .NET Core platformu için yeni olan geliştiriciler, temel bir tasarım arasında karar olduğunda uğraşır `delegates` ve temel bir tasarım `events`.</span><span class="sxs-lookup"><span data-stu-id="52d6e-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="52d6e-106">İki dil özellikleri oldukça benzerdir zor bir kavram olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="52d6e-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="52d6e-107">Olaylar, temsilciler için dil desteği kullanılarak bile oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="52d6e-107">Events are even built using the language support for delegates.</span></span> 

<span data-ttu-id="52d6e-108">Her ikisi de geç bağlama senaryo sunar: bir bileşen iletişim kuran burada yalnızca çalışma zamanında bilinen bir yöntem çağırarak senaryoları tanırlar.</span><span class="sxs-lookup"><span data-stu-id="52d6e-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="52d6e-109">Her ikisi de tek ve birden çok abone yöntemleri destekler.</span><span class="sxs-lookup"><span data-stu-id="52d6e-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="52d6e-110">Bu singlecast olarak adlandırılır ve çok noktaya yayın desteği bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="52d6e-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="52d6e-111">Her ikisi de benzer bir söz dizimi ekleme ve kaldırma işleyicileri için destek.</span><span class="sxs-lookup"><span data-stu-id="52d6e-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="52d6e-112">Son olarak, bir olayı tetiklenmeden ve temsilci çağırma tam olarak aynı yöntem çağrı sözdizimini kullanın.</span><span class="sxs-lookup"><span data-stu-id="52d6e-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="52d6e-113">Her ikisi de bile aynı destekleyen `Invoke()` yöntem sözdizimi ile kullanılmak üzere `?.` işleci.</span><span class="sxs-lookup"><span data-stu-id="52d6e-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="52d6e-114">Bu benzerlikler ile hangisi ne zaman kullanılmalıdır belirleme konusunda sorun yaşıyorsanız kolaydır.</span><span class="sxs-lookup"><span data-stu-id="52d6e-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="52d6e-115">İsteğe bağlı olduğunda olayları dinleme</span><span class="sxs-lookup"><span data-stu-id="52d6e-115">Listening to Events is Optional</span></span>

<span data-ttu-id="52d6e-116">Ekli bir abonesi olmalıdır desteklemediğini kullanmak için hangi dil özelliği belirlemede en önemli husustur.</span><span class="sxs-lookup"><span data-stu-id="52d6e-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="52d6e-117">Kodunuzu abone tarafından sağlanan kod çağırmanız gerekir, temsilciler üzerinde temel bir tasarım kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="52d6e-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="52d6e-118">Tüm iş herhangi aboneleri çağırmaya gerek kalmadan kodunuzu tamamlayabilirsiniz etkinliklere göre bir tasarım kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="52d6e-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span> 

<span data-ttu-id="52d6e-119">Bu bölümde sırasında oluşturulan örneklere bakın.</span><span class="sxs-lookup"><span data-stu-id="52d6e-119">Consider the examples built during this section.</span></span> <span data-ttu-id="52d6e-120">Yerleşik kullanarak kod `List.Sort()` öğeleri doğru sıralamak için bir karşılaştırıcı işlevi verilmelidir.</span><span class="sxs-lookup"><span data-stu-id="52d6e-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="52d6e-121">LINQ sorguları ile temsilciler döndürmek için hangi öğelere belirleyebilmesi sağlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="52d6e-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="52d6e-122">Her ikisi de temsilci ile oluşturulmuş bir tasarım kullanılır.</span><span class="sxs-lookup"><span data-stu-id="52d6e-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="52d6e-123">Göz önünde bulundurun `Progress` olay.</span><span class="sxs-lookup"><span data-stu-id="52d6e-123">Consider the `Progress` event.</span></span> <span data-ttu-id="52d6e-124">Bu görevde ilerlemeyi raporlar.</span><span class="sxs-lookup"><span data-stu-id="52d6e-124">It reports progress on a task.</span></span>
<span data-ttu-id="52d6e-125">Görev var olup olmadığını tüm dinleyiciler devam etmek devam eder.</span><span class="sxs-lookup"><span data-stu-id="52d6e-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="52d6e-126">`FileSearcher` Başka bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="52d6e-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="52d6e-127">Yine de arama ve hatta bağlı hiçbir olay aboneliği olan Aranan tüm dosyaları bulur.</span><span class="sxs-lookup"><span data-stu-id="52d6e-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="52d6e-128">Olayları dinleme abone olduğunda bile UX denetimleri yine de düzgün çalışır.</span><span class="sxs-lookup"><span data-stu-id="52d6e-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="52d6e-129">Her ikisi de etkinliklere göre tasarımları kullanın.</span><span class="sxs-lookup"><span data-stu-id="52d6e-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="52d6e-130">Dönüş değerleri temsilciler gerektirir</span><span class="sxs-lookup"><span data-stu-id="52d6e-130">Return Values Require Delegates</span></span>

<span data-ttu-id="52d6e-131">Temsilci yönteminizi istersiniz yöntemi prototip başka bir husustur.</span><span class="sxs-lookup"><span data-stu-id="52d6e-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="52d6e-132">Gördüğünüz gibi tüm olaylar için kullanılan temsilci bir dönüş türü void olacak.</span><span class="sxs-lookup"><span data-stu-id="52d6e-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="52d6e-133">Ayrıca, olay bağımsız değişkeni nesnesinin özelliklerini değiştirme aracılığıyla geri olay kaynakları için bilgi geçirmek olay işleyicilerini oluşturma deyimleri olduğunu gördünüz.</span><span class="sxs-lookup"><span data-stu-id="52d6e-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="52d6e-134">Bu deyimleri çalışırken, bu doğal olarak bir yöntemi bir değer döndüren olarak değiller.</span><span class="sxs-lookup"><span data-stu-id="52d6e-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="52d6e-135">Bu iki buluşsal yöntemler genellikle her ikisi de mevcut olabileceğine dikkat edin: Bir temsilci yöntemi bir değer döndürüyorsa, algoritma bir şekilde büyük olasılıkla etkiler.</span><span class="sxs-lookup"><span data-stu-id="52d6e-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="52d6e-136">Olay dinleyicilerini genellikle daha uzun ömre sahip</span><span class="sxs-lookup"><span data-stu-id="52d6e-136">Event Listeners Often Have Longer Lifetimes</span></span> 

<span data-ttu-id="52d6e-137">Biraz daha zayıf bir gerekçe budur.</span><span class="sxs-lookup"><span data-stu-id="52d6e-137">This is a slightly weaker justification.</span></span> <span data-ttu-id="52d6e-138">Ancak, uzun bir süre olayları olay kaynağı oluşturma, olay tabanlı tasarımları daha doğal olduğunu fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="52d6e-138">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="52d6e-139">Örnekler için UX denetimleri birçok sistemlerinde görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="52d6e-139">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="52d6e-140">Olay kaynağı, bir olaya abone olduktan sonra programın ömrü boyunca olayları neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="52d6e-140">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="52d6e-141">(Artık ihtiyacınız olduğunda olayları abonelikten çıkabilirsiniz.)</span><span class="sxs-lookup"><span data-stu-id="52d6e-141">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="52d6e-142">Bir temsilci yöntemi için bağımsız değişken olarak kullanıldığı, çok sayıda temsilci tabanlı tasarımlar ile karşıtlık ve bu yöntemin dönüşünün ardından temsilci kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="52d6e-142">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="52d6e-143">Dikkatlice değerlendirin</span><span class="sxs-lookup"><span data-stu-id="52d6e-143">Evaluate Carefully</span></span>

<span data-ttu-id="52d6e-144">Yukarıdaki konuları sabit ve hızlı kurallar değildir.</span><span class="sxs-lookup"><span data-stu-id="52d6e-144">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="52d6e-145">Bunun yerine, hangi belirli kullanımınız için en iyi seçimdir karar vermenize yardımcı olabilecek bir kılavuz gösterir.</span><span class="sxs-lookup"><span data-stu-id="52d6e-145">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="52d6e-146">Benzer olduklarından, her iki prototip bile ve hangi çalışmak için daha doğal olacaktır göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="52d6e-146">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="52d6e-147">Her ikisi de geç bağlama senaryoları da işler.</span><span class="sxs-lookup"><span data-stu-id="52d6e-147">They both handle late binding scenarios well.</span></span> <span data-ttu-id="52d6e-148">Tasarımınızı iletişim kuran bir en iyi kullanın.</span><span class="sxs-lookup"><span data-stu-id="52d6e-148">Use the one that communicates your design the best.</span></span>

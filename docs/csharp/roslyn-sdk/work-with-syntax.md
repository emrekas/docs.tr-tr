---
title: .NET derleyici Platformu SDK'sı söz dizimi modelini kullanın
description: Bu genel bakışta anlamak ve söz dizimi düğümleri işlemek için kullandığınız türleri bir anlayış sağlar.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: a48d48168dffdb439c984f5b4209019514b3b970
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61706604"
---
# <a name="work-with-syntax"></a><span data-ttu-id="d9a7a-103">Söz dizimi ile çalışma</span><span class="sxs-lookup"><span data-stu-id="d9a7a-103">Work with syntax</span></span>

<span data-ttu-id="d9a7a-104">**Söz dizimi ağacı** olan API'leri derleyici tarafından kullanıma sunulan bir temel veri yapısı.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="d9a7a-105">Bu ağaç, kaynak kodu sözcük ve söz dizimi yapısını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="d9a7a-106">Bunlar, iki önemli amaca hizmet eder:</span><span class="sxs-lookup"><span data-stu-id="d9a7a-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="d9a7a-107">Gibi bir IDE araçları - izin vermek için eklentileri, Kod Analizi araçları ve yeniden düzenlemeler - bakın ve bir kullanıcının proje kaynak kodunda sözdizimi yapısını işlemek için.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="d9a7a-108">Araçları - yeniden düzenlemeler ve oluşturmak için bir IDE - gibi etkinleştirmek için değiştirme ve kaynak kodu, doğrudan metin düzenlemeleri kullanmak zorunda kalmadan doğal bir şekilde yeniden düzenleyin.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="d9a7a-109">Oluşturma ve ağaçları düzenleme araçları kolayca oluşturun ve kaynak kodu yeniden düzenleyin.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="d9a7a-110">Sözdizimi ağacı</span><span class="sxs-lookup"><span data-stu-id="d9a7a-110">Syntax trees</span></span>

<span data-ttu-id="d9a7a-111">Sözdizimi ağacı yeniden düzenleme, IDE özellikleri ve kod oluşturmayı bağlama, kod analizi, derleme için kullanılan birincil yapısı var.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="d9a7a-112">Kaynak kodun hiçbir kısmı ilk ve tanımlanmış birçok iyi bilinen yapısal dil öğelerini birine kategorilere olmadan anlaşılır.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span> 

<span data-ttu-id="d9a7a-113">Sözdizimi ağacı üç anahtar özniteliklere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="d9a7a-114">Söz dizimi ağacı içinde tam uygunlukta tüm kaynak bilgileri tutmak ilk özniteliğidir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="d9a7a-115">Başka bir deyişle, söz dizimi ağacı her bir parçası boşluk, açıklamalar ve ön işlemci yönergeleri dahil olmak üzere kaynak metni, her dilbilgisi yapısı, her sözcük temelli belirteç ve arasındaki, diğer her şey bulunan bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="d9a7a-116">Örneğin, tam olarak yazılmış şekilde kaynak bahsedilen her bir sabit değer gösterilir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="d9a7a-117">Program sözdizimi ağacı belirteçleri Atlanan ya da eksik temsil eden tarafından eksik veya hatalı olduğunda söz dizimi ağacı ayrıca kaynak kodundaki hataları temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>  

<span data-ttu-id="d9a7a-118">Bu ikinci öznitelik söz dizimi ağaçları sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="d9a7a-119">Ayrıştırıcının alınan bir sözdizimi ağacına gelen ayrıştırıldığında küpte tam metin üretebilir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="d9a7a-120">Herhangi bir söz dizimi düğümünden metin temsili o düğümde kökü alt ağacı mümkündür.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="d9a7a-121">Başka bir deyişle, söz dizimi ağacı bir şekilde oluşturun ve kaynak metni düzenlemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="d9a7a-122">Yeni bir ağaç değişiklikleri dışında varolan ağacına yapma eşdeğer metin oluşturulan itiraz ve düzenleyerek bir sözdizimi ağacına sahip bir ağaç oluşturarak, metin etkili bir şekilde düzenlediniz.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span> 

<span data-ttu-id="d9a7a-123">Üçüncü söz dizimi ağacı sabittir ve iş parçacığı açısından güvenli olmalarını özniteliğidir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="d9a7a-124">Bu bir ağaç alındıktan sonra bu kodun geçerli durumunun bir anlık görüntüdür, hiçbir zaman anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="d9a7a-125">Bu, aynı söz dizimi ağacı ile aynı anda farklı iş parçacıklarında kilitlenmesi veya çoğaltma etkileşime geçmek birden fazla kullanıcı sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="d9a7a-126">Çünkü ağaçları sabittir ve bir ağaca doğrudan herhangi bir değişiklik yapılabilmesi için Fabrika yöntemleri oluşturun ve ek anlık görüntü ağacının oluşturarak söz dizimi ağaçlarını değiştirme yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="d9a7a-127">Hızlı ve çok az ek bellek ile yeni bir sürüm oluşturulabilmesi için temel alınan düğümleri yeniden şekilde ağaçları verimlidir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="d9a7a-128">Sözdizimi ağacı terminal olmayan yapısal öğelerini diğer öğeleri nerede üst ağaç veri yapısı, tam anlamıyla olduğu.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="d9a7a-129">Her bir söz dizimi ağacı, düğümler, belirteçleri ve trivia yapılır.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>  

## <a name="syntax-nodes"></a><span data-ttu-id="d9a7a-130">Söz dizimi düğümleri</span><span class="sxs-lookup"><span data-stu-id="d9a7a-130">Syntax nodes</span></span>

<span data-ttu-id="d9a7a-131">Söz dizimi düğümleri söz dizimi ağacı birincil öğelerinden biridir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="d9a7a-132">Bu düğümler, bildirimleri, deyimler, yan tümceleri ve ifadeler gibi bir söz dizimi yapıları temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="d9a7a-133">Söz dizimi düğümlerinin her kategori türetilen ayrı bir sınıf tarafından temsil edilen <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a7a-134">Düğüm sınıf kümesi Genişletilebilir değildir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-134">The set of node classes is not extensible.</span></span> 

<span data-ttu-id="d9a7a-135">Tüm söz dizimi terminal olmayan düğümleri her zaman diğer düğümleri ve alt öğeleri olarak belirteçleri olduğu anlamına gelir. söz dizimi ağacı içinde düğümlerdir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="d9a7a-136">Başka bir düğümün alt, her düğüm üzerinden erişilebilen bir üst düğümün sahip <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> özelliği.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="d9a7a-137">Düğümler ve ağaçları sabit olduğundan, üst düğümünün hiçbir zaman değiştirir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="d9a7a-138">Ağacının kökü null bir üst öğeye sahip.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-138">The root of the tree has a null parent.</span></span>  

<span data-ttu-id="d9a7a-139">Her düğüme sahip bir <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> yöntemi kaynak metin konumlarına göre sıralı alt düğümlerin listesini döndürür.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="d9a7a-140">Bu liste, belirteç içermiyor.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-140">This list does not contain tokens.</span></span> <span data-ttu-id="d9a7a-141">Her düğüm alt sınamak için yöntemlerini de sahip <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, veya <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> -tüm düğümleri, belirteçleri veya o düğümün kökü alt ağaçta mevcut Meraklısına Notlar listesini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia, that exist in the sub-tree rooted by that node.</span></span>  

<span data-ttu-id="d9a7a-142">Ayrıca, her bir sözdizimi düğümü alt hepsi aynı alt kesin olarak belirlenmiş özellikler aracılığıyla kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="d9a7a-143">Örneğin, bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> düğümü sınıfı için ikili işleçler belirli üç ek özelliklere sahiptir: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="d9a7a-144">Türünü <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> olduğu <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>ve türünü <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> olduğu <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="d9a7a-145">İsteğe bağlı alt öğeleri bazı sözdizimi düğümünüz.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="d9a7a-146">Örneğin, bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> isteğe sahip <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="d9a7a-147">Alt mevcut değilse özellik null döndürür.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-147">If the child is not present, the property returns null.</span></span> 

## <a name="syntax-tokens"></a><span data-ttu-id="d9a7a-148">Söz dizimi belirteçleri</span><span class="sxs-lookup"><span data-stu-id="d9a7a-148">Syntax tokens</span></span>

<span data-ttu-id="d9a7a-149">Söz dizimi, kod söz dizimi küçük parçaları temsil eden dil dilbilgisi terminaller belirteçleridir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="d9a7a-150">Hiçbir zaman diğer düğümleri veya belirteçleri üst öğelerinin değildirler.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="d9a7a-151">Söz dizimi belirteçleri, anahtar sözcükler, tanımlayıcılar, değişmez değerler ve noktalama işaretleri oluşur.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span> 

<span data-ttu-id="d9a7a-152">Verimliliği amacıyla <xref:Microsoft.CodeAnalysis.SyntaxToken> türü, bir CLR değer türüdür.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="d9a7a-153">Bu nedenle, söz dizimi düğümleri, tüm tür belirteçleri karışımından oluşan temsil edilen bir belirteç türünü bağlı olarak anlam taşıyan özellikler için yalnızca bir yapı yoktur.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="d9a7a-154">Örneğin, bir tamsayı değişmez değer belirteci sayısal bir değeri temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="d9a7a-155">Ham kaynak metin yanı sıra belirteci yayılma değişmez değer belirtece bir <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> tam belirten özellik çözülmüş tamsayı değeri.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="d9a7a-156">Bu özellik olarak yazılan <xref:System.Object> çünkü çok basit türlerden biri olabilir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="d9a7a-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> Özelliği bildirir, aynı bilgileri <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> özelliği; ancak bu özellik her zaman olarak yazılan <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="d9a7a-158">Bir tanımlayıcı C# kaynak metin, Unicode kaçış karakterlerini içerebilir, ancak çıkış dizisi söz dizimi tanımlayıcı adı bir parçası olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="d9a7a-159">Belirteç tarafından kapsanan ham metni kaçış sırası içerse bunu <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> özelliği yok.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="d9a7a-160">Bunun yerine, kaçış tarafından tanımlanan Unicode karakterler içerir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="d9a7a-161">Örneğin, kaynak metin olarak yazılan tanımlayıcının içeriyorsa `\u03C0`, ardından <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> özelliği için bu belirteci döndürür `π`.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="d9a7a-162">Söz dizimi Meraklısına Notlar</span><span class="sxs-lookup"><span data-stu-id="d9a7a-162">Syntax trivia</span></span>

<span data-ttu-id="d9a7a-163">Söz dizimi Meraklısına notlar gibi boşluk, açıklamalar ve ön işlemci yönergelerini kodun normal anlamak için büyük ölçüde Önemsiz kaynak metin parçalarını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="d9a7a-164">Söz dizimi belirteçleri gibi Meraklısına Notlar değer türleridir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="d9a7a-165">Tek <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> türü Meraklısına Notlar tüm türleri tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="d9a7a-166">Meraklısına Notlar normal dil sözdiziminin bir parçası değildir ve herhangi iki belirteç arasında herhangi bir yeri görünebilir çünkü bunlar sözdizimi ağacında bir düğümün alt düğümü dahil edilmez.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="d9a7a-167">Henüz, bunlar yeniden düzenleme gibi ve kaynak metni ile tam uygunluğu korumak için bir özellik uygularken önemli olduğundan, bunlar söz dizimi ağacı bir parçası olarak mevcut.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="d9a7a-168">Meraklısına Notlar bir belirtecin inceleyerek erişebileceğiniz <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> veya <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> koleksiyonları.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="d9a7a-169">Kaynak metni ayrıştırıldığında Meraklısına Notlar dönüştürülmelerini belirteçleri ile ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="d9a7a-170">Genel olarak, bir belirteç tüm Meraklısına Notlar sonra aynı satıra kadar sonraki belirtece sahip.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="d9a7a-171">Bu satırdan herhangi trivia aşağıdaki belirteciyle ilişkilendirilmiş olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="d9a7a-172">Kaynak dosyadaki ilk belirteçten tüm ilk trivia alır ve trivia dosyasındaki son dizi olan aksi Sıfır Genişlik dosya sonu belirteci sabitlenmiş.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="d9a7a-173">Söz dizimi düğümleri ve belirteçleri aksine, söz dizimi trivia üst öğeleri yok.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="d9a7a-174">Henüz her tek bir belirteçle ilişkilendirilir ve ağacın parçası olduğundan, belirteci kullanarak ilişkili olduğu erişebilir <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> özelliği.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="d9a7a-175">Yayılma</span><span class="sxs-lookup"><span data-stu-id="d9a7a-175">Spans</span></span>

<span data-ttu-id="d9a7a-176">Her düğüm, belirteç veya trivia kaynak metni ve içerdiği karakter sayısını içindeki konumuna bilir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="d9a7a-177">Bir metin konumu sıfır tabanlı bir 32 bit tamsayı olarak temsil edilen `char` dizini.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="d9a7a-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> nesne başlangıç konumu ve karakter sayısı, her ikisi de tamsayı olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="d9a7a-179">Varsa <xref:Microsoft.CodeAnalysis.Text.TextSpan> bir sıfır uzunluğuna sahip iki karakter arasına bir konuma başvuruyor.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="d9a7a-180">Her düğümü iki içeren <xref:Microsoft.CodeAnalysis.Text.TextSpan> özellikleri: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> ve <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span></span> 

<span data-ttu-id="d9a7a-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> Düğümün alt ağacı ilk belirteci başlangıcı metin aralığı son belirteç sonuna bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="d9a7a-182">Bu aralık, başında veya sonunda tüm Meraklısına Notlar içermez.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="d9a7a-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> Düğümün normal yayılma yanı sıra, herhangi bir başında veya sonunda trivia aralık içeren metin aralığı bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="d9a7a-184">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="d9a7a-184">For example:</span></span> 

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="d9a7a-185">Deyimi düğümü bloktaki tek dikey çubuk (|) tarafından belirtilen bir yayılma vardır.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="d9a7a-186">Karakterleri içeren `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="d9a7a-187">Tam aralık çift dikey çubuk (|) tarafından belirtilir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="d9a7a-188">Bu, aynı aralık olarak, baştaki ve sondaki Meraklısına Notlar ile ilişkili karakter içerir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="d9a7a-189">Tür</span><span class="sxs-lookup"><span data-stu-id="d9a7a-189">Kinds</span></span>

<span data-ttu-id="d9a7a-190">Her düğüm, belirteç veya Meraklısına Notlar bir <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> türünün özelliği <xref:System.Int32?displayProperty=nameWithType>, temsil edilen söz dizimi öğe tanımlar.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="d9a7a-191">Bu değer bir dile özgü sabit listesine dönüştürülebilen; Her bir dilin C# veya VB, tek bir `SyntaxKind` numaralandırması (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> ve <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>sırasıyla), tüm olası düğümlerinin, belirteçleri ve Meraklısına Notlar öğeleri dilbilgisi içinde listelenir.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-191">This value can be cast to a language-specific enumeration; each language, C# or VB, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="d9a7a-192">Bu dönüştürme erişerek otomatik olarak yapılabilir <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> veya <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> genişletme yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="d9a7a-193"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> Özelliği için aynı düğümü sınıfı paylaşan sözdizimi düğümü türleri kolay Kesinleştirme sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="d9a7a-194">Belirteçler ve Meraklısına notlar için bu özellik öğesi bir tür diğerinden ayırt etmek için tek yoludur.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span> 

<span data-ttu-id="d9a7a-195">Örneğin, bir tek <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> sınıfında <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> alt öğeleri olarak.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="d9a7a-196"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> Özelliği olduğunu ayıran bir <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, veya <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> söz dizimi düğümünün türü.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="d9a7a-197">Hatalar</span><span class="sxs-lookup"><span data-stu-id="d9a7a-197">Errors</span></span>

<span data-ttu-id="d9a7a-198">Kaynak metni söz dizimi hataları içerdiğinde, bile, hepsini kaynağına ayrıştırılabilmelerini sağlamak üzere bir tam söz dizimi ağacı kullanıma sunulur.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="d9a7a-199">Ayrıştırıcının dili tanımlanan sözdizimine uygun değil kod karşılaştığında, iki tekniklerden birini söz dizimi ağacı oluşturmak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="d9a7a-200">İlk olarak, ayrıştırıcının belirli bir belirteç türünü bekliyor, ancak bunu bulamaz, belirteç bekleniyordu konumda söz dizimi ağacı içinde eksik bir belirteç ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-200">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="d9a7a-201">Eksik bir belirteç bekleniyordu gerçek belirteci temsil eder, ancak boş bir yayılma vardır ve kendi <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> özelliği döndürür `true`.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="d9a7a-202">İkinci olarak, bunu bir ayrıştırma burada devam edebilirsiniz bulana kadar ayrıştırıcının belirteçleri atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-202">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="d9a7a-203">Bu durumda, atlanan belirteçleri trivia düğüm türü ile olarak eklenen <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="d9a7a-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>

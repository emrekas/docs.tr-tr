---
title: Türleri - C# Programlama Kılavuzu
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- value types [C#]
- reference types [C#]
- types [C#]
- C# language, data types
- common type system [C#]
- data types [C#]
- C# language, types
- strong typing [C#]
ms.assetid: f782d7cc-035e-4500-b1b1-36a9881130ad
ms.openlocfilehash: ed666208c3d9bf2e9eb7d7f316cac3767e1bc718
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54604323"
---
# <a name="types-c-programming-guide"></a><span data-ttu-id="d3752-102">Türler (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="d3752-102">Types (C# Programming Guide)</span></span>
## <a name="types-variables-and-values"></a><span data-ttu-id="d3752-103">Türler, değişkenler ve değerleri</span><span class="sxs-lookup"><span data-stu-id="d3752-103">Types, Variables, and Values</span></span>  
 <span data-ttu-id="d3752-104">C# bir türü kesin belirlenmiş dildir.</span><span class="sxs-lookup"><span data-stu-id="d3752-104">C# is a strongly-typed language.</span></span> <span data-ttu-id="d3752-105">Bir değere Değerlenen her ifadenin gibi her değişken ve sabit bir türü vardır.</span><span class="sxs-lookup"><span data-stu-id="d3752-105">Every variable and constant has a type, as does every expression that evaluates to a value.</span></span> <span data-ttu-id="d3752-106">Her yöntem imzası bir tür için her giriş parametresi ve dönüş değeri belirtir.</span><span class="sxs-lookup"><span data-stu-id="d3752-106">Every method signature specifies a type for each input parameter and for the return value.</span></span> <span data-ttu-id="d3752-107">.NET sınıf kitaplığı bir yerleşik sayısal türler ve bunun yanı sıra çok çeşitli dosya sistemi, ağ bağlantıları, koleksiyonlar ve diziler nesneleri ve tarihler gibi mantıksal yapıları temsil eden daha karmaşık türleri kümesi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="d3752-107">The .NET class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</span></span> <span data-ttu-id="d3752-108">Tipik bir C# programı sınıf kitaplığından alınan türleri aynı zamanda programın sorun etki alanına özgü kavramları modelleyen kullanıcı tanımlı türler kullanır.</span><span class="sxs-lookup"><span data-stu-id="d3752-108">A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</span></span>  
  
 <span data-ttu-id="d3752-109">Bir tür içinde depolanan bilgiler aşağıdakileri içerebilir:</span><span class="sxs-lookup"><span data-stu-id="d3752-109">The information stored in a type can include the following:</span></span>  
  
-   <span data-ttu-id="d3752-110">Bir tür değişkeninin gerektirdiği depolama alanı.</span><span class="sxs-lookup"><span data-stu-id="d3752-110">The storage space that a variable of the type requires.</span></span>  
  
-   <span data-ttu-id="d3752-111">Temsil edebileceği maksimum ve minimum değerler.</span><span class="sxs-lookup"><span data-stu-id="d3752-111">The maximum and minimum values that it can represent.</span></span>  
  
-   <span data-ttu-id="d3752-112">İçerdiği üyeler (yöntemler, alanlar, olaylar vb.).</span><span class="sxs-lookup"><span data-stu-id="d3752-112">The members (methods, fields, events, and so on) that it contains.</span></span>  
  
-   <span data-ttu-id="d3752-113">Devraldığı taban türü.</span><span class="sxs-lookup"><span data-stu-id="d3752-113">The base type it inherits from.</span></span>  
  
-   <span data-ttu-id="d3752-114">Değişkenler için belleğin çalışma zamanında burada ayrılacak konumu.</span><span class="sxs-lookup"><span data-stu-id="d3752-114">The location where the memory for variables will be allocated at run time.</span></span>  
  
-   <span data-ttu-id="d3752-115">İzin verilen işlem türleri.</span><span class="sxs-lookup"><span data-stu-id="d3752-115">The kinds of operations that are permitted.</span></span>  
  
 <span data-ttu-id="d3752-116">Derleyici, kodunuzda gerçekleştirilen tüm işlemler olduğundan emin olmak için tür bilgilerini kullanır. *denkliği*.</span><span class="sxs-lookup"><span data-stu-id="d3752-116">The compiler uses type information to make sure that all operations that are performed in your code are *type safe*.</span></span> <span data-ttu-id="d3752-117">Örneğin, türünde bir değişken bildirirseniz [int](../../../csharp/language-reference/keywords/int.md), derleyici değişkeni buna ek olarak kullanmanızı ve çıkarma işlemleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="d3752-117">For example, if you declare a variable of type [int](../../../csharp/language-reference/keywords/int.md), the compiler allows you to use the variable in addition and subtraction operations.</span></span> <span data-ttu-id="d3752-118">Türünde bir değişkende aynı işlemleri gerçekleştirmeyi denerseniz [bool](../../../csharp/language-reference/keywords/bool.md), aşağıdaki örnekte gösterildiği gibi derleyici bir hata oluşturur:</span><span class="sxs-lookup"><span data-stu-id="d3752-118">If you try to perform those same operations on a variable of type [bool](../../../csharp/language-reference/keywords/bool.md), the compiler generates an error, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideTypes#42](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_1.cs)]  
  
> [!NOTE]
>  <span data-ttu-id="d3752-119">C ve C++ geliştiricileri seçeneğinde bu C# ' ta [bool](../../../csharp/language-reference/keywords/bool.md) öğesine dönüştürülebilir değildir [int](../../../csharp/language-reference/keywords/int.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-119">C and C++ developers, notice that in C#, [bool](../../../csharp/language-reference/keywords/bool.md) is not convertible to [int](../../../csharp/language-reference/keywords/int.md).</span></span>  
  
 <span data-ttu-id="d3752-120">Derleyicinin tür bilgisini yürütülebilir dosya meta veri olarak gömer.</span><span class="sxs-lookup"><span data-stu-id="d3752-120">The compiler embeds the type information into the executable file as metadata.</span></span> <span data-ttu-id="d3752-121">Ortak dil çalışma zamanı (CLR) ayırır ve belleği geri kazanır, daha fazla tür güvenliği sağlamak için çalışma zamanında bu meta verileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="d3752-121">The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</span></span>  
  
### <a name="specifying-types-in-variable-declarations"></a><span data-ttu-id="d3752-122">Değişken bildirimlerinde türleri belirtme</span><span class="sxs-lookup"><span data-stu-id="d3752-122">Specifying Types in Variable Declarations</span></span>  
 <span data-ttu-id="d3752-123">Ne zaman bir değişken bildirdiğinizde veya sabit bir program, türünü belirtmeniz veya kullanın [var](../../../csharp/language-reference/keywords/var.md) anahtar sözcüğünü kullanarak derleyicinin türü sağlar.</span><span class="sxs-lookup"><span data-stu-id="d3752-123">When you declare a variable or constant in a program, you must either specify its type or use the [var](../../../csharp/language-reference/keywords/var.md) keyword to let the compiler infer the type.</span></span> <span data-ttu-id="d3752-124">Aşağıdaki örnek, hem yerleşik sayısal türler hem de kullanıcı tanımlı karmaşık türler kullanan bazı değişken bildirimlerini gösterir:</span><span class="sxs-lookup"><span data-stu-id="d3752-124">The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</span></span>  
  
 [!code-csharp[csProgGuideTypes#36](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_2.cs)]  
  
 <span data-ttu-id="d3752-125">Yöntem parametreleri ve dönüş değerlerinin türleri Yöntem imzasında belirtilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-125">The types of method parameters and return values are specified in the method signature.</span></span> <span data-ttu-id="d3752-126">Aşağıdaki imza gerektiren bir yöntemi gösterir bir [int](../../../csharp/language-reference/keywords/int.md) giriş bağımsız değişkeni olarak bir dize döndürür:</span><span class="sxs-lookup"><span data-stu-id="d3752-126">The following signature shows a method that requires an [int](../../../csharp/language-reference/keywords/int.md) as an input argument and returns a string:</span></span>  
  
 [!code-csharp[csProgGuideTypes#35](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_3.cs)]  
  
 <span data-ttu-id="d3752-127">Bir değişken bildirildikten sonra yeni bir türle yeniden bildirilemez ve bildirilen türle uyumlu olmayan bir değer atanamaz.</span><span class="sxs-lookup"><span data-stu-id="d3752-127">After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</span></span> <span data-ttu-id="d3752-128">Örneğin, bildiremezsiniz bir [int](../../../csharp/language-reference/keywords/int.md) Boolean değerini atayın [true](../../../csharp/language-reference/keywords/true-literal.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-128">For example, you cannot declare an [int](../../../csharp/language-reference/keywords/int.md) and then assign it a Boolean value of [true](../../../csharp/language-reference/keywords/true-literal.md).</span></span> <span data-ttu-id="d3752-129">Ancak, değerler örneğin yeni değişkenlere eklendiklerinde veya yöntem bağımsız değişkenleri olarak geçtiklerinde diğer türlere dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-129">However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</span></span> <span data-ttu-id="d3752-130">A *tür dönüştürme* , yoksa veri kaybına neden olmayan derleyici tarafından otomatik olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-130">A *type conversion* that does not cause data loss is performed automatically by the compiler.</span></span> <span data-ttu-id="d3752-131">Veri kaybına neden olabilecek bir dönüştürme gerektiren bir *atama* kaynak kodunda.</span><span class="sxs-lookup"><span data-stu-id="d3752-131">A conversion that might cause data loss requires a *cast* in the source code.</span></span>  
  
 <span data-ttu-id="d3752-132">Daha fazla bilgi için [atama ve tür dönüşümleri](../../../csharp/programming-guide/types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-132">For more information, see [Casting and Type Conversions](../../../csharp/programming-guide/types/casting-and-type-conversions.md).</span></span>  
  
## <a name="built-in-types"></a><span data-ttu-id="d3752-133">Yerleşik türler</span><span class="sxs-lookup"><span data-stu-id="d3752-133">Built-in Types</span></span>  
 <span data-ttu-id="d3752-134">C# Standart tamsayılar, kayan nokta değerleri, Boolean ifadeler, metin karakterleri, ondalık değerleri temsil etmek için yerleşik sayısal türler ve diğer veri türleri kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="d3752-134">C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</span></span> <span data-ttu-id="d3752-135">Ayrıca vardır yerleşik `string` ve `object` türleri.</span><span class="sxs-lookup"><span data-stu-id="d3752-135">There are also built-in `string` and `object` types.</span></span> <span data-ttu-id="d3752-136">Bunlar, bir C# programında kullanabilmeniz için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-136">These are available for you to use in any C# program.</span></span> <span data-ttu-id="d3752-137">Yerleşik türler hakkında daha fazla bilgi için bkz. [türler için başvuru tabloları](../../../csharp/language-reference/keywords/reference-tables-for-types.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-137">For more information about the built-in types, see [Reference Tables for Types](../../../csharp/language-reference/keywords/reference-tables-for-types.md).</span></span>  
  
## <a name="custom-types"></a><span data-ttu-id="d3752-138">Özel türler</span><span class="sxs-lookup"><span data-stu-id="d3752-138">Custom Types</span></span>  
 <span data-ttu-id="d3752-139">Kullandığınız [yapı](../../../csharp/language-reference/keywords/struct.md), [sınıfı](../../../csharp/language-reference/keywords/class.md), [arabirimi](../../../csharp/language-reference/keywords/interface.md), ve [enum](../../../csharp/language-reference/keywords/enum.md) yapılar, kendi özel türlerinizi oluşturmak için.</span><span class="sxs-lookup"><span data-stu-id="d3752-139">You use the [struct](../../../csharp/language-reference/keywords/struct.md), [class](../../../csharp/language-reference/keywords/class.md), [interface](../../../csharp/language-reference/keywords/interface.md), and [enum](../../../csharp/language-reference/keywords/enum.md) constructs to create your own custom types.</span></span> <span data-ttu-id="d3752-140">.NET sınıf kitaplığının kendisi, uygulamalarınızda kullanabileceğiniz Microsoft tarafından sağlanan özel türler koleksiyonudur.</span><span class="sxs-lookup"><span data-stu-id="d3752-140">The .NET class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</span></span> <span data-ttu-id="d3752-141">Varsayılan olarak, Sınıf Kitaplığı'nda en sık kullanılan türleri bir C# programı içinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-141">By default, the most frequently used types in the class library are available in any C# program.</span></span> <span data-ttu-id="d3752-142">Diğerleri yalnızca açıkça tanımlanmış derlemenin bir proje başvurusu eklediğinizde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-142">Others become available only when you explicitly add a project reference to the assembly in which they are defined.</span></span> <span data-ttu-id="d3752-143">Derleyici derlemesine bir başvuru olduğunda, değişkenler (ve sabitler) türlerinin derlemeye kaynak kodunda bildirilen bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-143">After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</span></span> <span data-ttu-id="d3752-144">Daha fazla bilgi için [.NET sınıf kitaplığı](../../../standard/class-library-overview.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-144">For more information, see [.NET Class Library](../../../standard/class-library-overview.md).</span></span>  
  
## <a name="the-common-type-system"></a><span data-ttu-id="d3752-145">Ortak tür sistemi</span><span class="sxs-lookup"><span data-stu-id="d3752-145">The Common Type System</span></span>  
 <span data-ttu-id="d3752-146">.NET içindeki tür sisteminde iki temel noktanın anlaşılması önemlidir:</span><span class="sxs-lookup"><span data-stu-id="d3752-146">It is important to understand two fundamental points about the type system in .NET:</span></span>  
  
-   <span data-ttu-id="d3752-147">Bu devralma ilkesini destekler.</span><span class="sxs-lookup"><span data-stu-id="d3752-147">It supports the principle of inheritance.</span></span> <span data-ttu-id="d3752-148">Türleri olarak adlandırılan diğer türlerden türetilebilir *taban türler*.</span><span class="sxs-lookup"><span data-stu-id="d3752-148">Types can derive from other types, called *base types*.</span></span> <span data-ttu-id="d3752-149">Türetilmiş bir tür, yöntemleri, özellikleri ve diğer temel türün üyelerini (bazı sınırlamalarla birlikte) devralır.</span><span class="sxs-lookup"><span data-stu-id="d3752-149">The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</span></span> <span data-ttu-id="d3752-150">Temel tür sırayla durumda türetilmiş tür devralma hiyerarşisinde her iki taban türün üyelerini devralan başka bir türden türeyebilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-150">The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</span></span> <span data-ttu-id="d3752-151">Gibi yerleşik sayısal türler dahil olmak üzere tüm türleri <xref:System.Int32?displayProperty=nameWithType> (C# anahtar sözcüğünü: [int](../../../csharp/language-reference/keywords/int.md)), türetilen sonuçta tek temel türünden olduğu <xref:System.Object?displayProperty=nameWithType> (C# anahtar sözcüğünü: [nesne](../../../csharp/language-reference/keywords/object.md)).</span><span class="sxs-lookup"><span data-stu-id="d3752-151">All types, including built-in numeric types such as <xref:System.Int32?displayProperty=nameWithType> (C# keyword: [int](../../../csharp/language-reference/keywords/int.md)), derive ultimately from a single base type, which is <xref:System.Object?displayProperty=nameWithType> (C# keyword: [object](../../../csharp/language-reference/keywords/object.md)).</span></span> <span data-ttu-id="d3752-152">Bu birleşik tür hiyerarşisine adlı [ortak tür sistemi](../../../standard/base-types/common-type-system.md) (CTS).</span><span class="sxs-lookup"><span data-stu-id="d3752-152">This unified type hierarchy is called the [Common Type System](../../../standard/base-types/common-type-system.md) (CTS).</span></span> <span data-ttu-id="d3752-153">C# içinde devralma hakkında daha fazla bilgi için bkz: [devralma](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-153">For more information about inheritance in C#, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
-   <span data-ttu-id="d3752-154">Cts'deki her tür olarak tanımlanan bir *değer türü* veya *başvuru türüne*.</span><span class="sxs-lookup"><span data-stu-id="d3752-154">Each type in the CTS is defined as either a *value type* or a *reference type*.</span></span> <span data-ttu-id="d3752-155">Bu, .NET sınıf kitaplığı'nda tüm özel türleri ve ayrıca kendi kullanıcı tanımlı türler içerir.</span><span class="sxs-lookup"><span data-stu-id="d3752-155">This includes all custom types in the .NET class library and also your own user-defined types.</span></span> <span data-ttu-id="d3752-156">Kullanarak tanımladığınız türler [yapı](../../../csharp/language-reference/keywords/struct.md) anahtar değer türleri; tüm yerleşik sayısal türler `structs`.</span><span class="sxs-lookup"><span data-stu-id="d3752-156">Types that you define by using the [struct](../../../csharp/language-reference/keywords/struct.md) keyword are value types; all the built-in numeric types are `structs`.</span></span> <span data-ttu-id="d3752-157">Kullanarak tanımladığınız türler [sınıfı](../../../csharp/language-reference/keywords/class.md) anahtar sözcüğü olan başvuru türleri.</span><span class="sxs-lookup"><span data-stu-id="d3752-157">Types that you define by using the [class](../../../csharp/language-reference/keywords/class.md) keyword are reference types.</span></span> <span data-ttu-id="d3752-158">Başvuru türleri ve değer türleri farklı derleme zamanı kuralları ve farklı çalışma zamanı davranışı sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d3752-158">Reference types and value types have different compile-time rules, and different run-time behavior.</span></span>  
  
 <span data-ttu-id="d3752-159">Aşağıdaki çizim CTS'deki değer türleri ve başvuru türleri arasındaki ilişkiyi gösterir.</span><span class="sxs-lookup"><span data-stu-id="d3752-159">The following illustration shows the relationship between value types and reference types in the CTS.</span></span>  
  
 <span data-ttu-id="d3752-160">![Değer türleri ve başvuru türleri](../../../csharp/programming-guide/types/media/valuetypescts.png "ValueTypesCTS")</span><span class="sxs-lookup"><span data-stu-id="d3752-160">![Value Types and Reference Types](../../../csharp/programming-guide/types/media/valuetypescts.png "ValueTypesCTS")</span></span>  
<span data-ttu-id="d3752-161">Değer türleri ve başvuru türleri cts'deki</span><span class="sxs-lookup"><span data-stu-id="d3752-161">Value types and reference types in the CTS</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3752-162">Sık kullanılan türlerinin tümünün olduğunu gördüğünüz <xref:System> ad alanı.</span><span class="sxs-lookup"><span data-stu-id="d3752-162">You can see that the most commonly used types are all organized in the <xref:System> namespace.</span></span> <span data-ttu-id="d3752-163">Ancak türü içeren ad alanı için bir değer olup ilgisi yoktur türü veya başvuru türü.</span><span class="sxs-lookup"><span data-stu-id="d3752-163">However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.</span></span>  
  
### <a name="value-types"></a><span data-ttu-id="d3752-164">Değer Türleri</span><span class="sxs-lookup"><span data-stu-id="d3752-164">Value Types</span></span>  
 <span data-ttu-id="d3752-165">Değer türleri <xref:System.ValueType?displayProperty=nameWithType>, öğesinden türetildiğini <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d3752-165">Value types derive from <xref:System.ValueType?displayProperty=nameWithType>, which derives from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3752-166">Öğesinden türetilen türler <xref:System.ValueType?displayProperty=nameWithType> CLR içinde özel davranışa sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d3752-166">Types that derive from <xref:System.ValueType?displayProperty=nameWithType> have special behavior in the CLR.</span></span> <span data-ttu-id="d3752-167">Değer türü değişkenler doğrudan değerlerini, değişkenin bildirildiği hangi bağlamda satır içi bellek tahsis edildiği anlamına gelir içerir.</span><span class="sxs-lookup"><span data-stu-id="d3752-167">Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared.</span></span> <span data-ttu-id="d3752-168">Ayrı yığın atama veya değer türü değişkenler çöp toplama taşması yoktur.</span><span class="sxs-lookup"><span data-stu-id="d3752-168">There is no separate heap allocation or garbage collection overhead for value-type variables.</span></span>  
  
 <span data-ttu-id="d3752-169">Değer türlerinin iki kategorisi vardır: [yapı](../../../csharp/language-reference/keywords/struct.md) ve [enum](../../../csharp/language-reference/keywords/enum.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-169">There are two categories of value types: [struct](../../../csharp/language-reference/keywords/struct.md) and [enum](../../../csharp/language-reference/keywords/enum.md).</span></span>  
  
 <span data-ttu-id="d3752-170">Yerleşik sayısal türler yapı birimleridir ve özellikleri ve yöntemleri erişebileceğiniz sahiptirler:</span><span class="sxs-lookup"><span data-stu-id="d3752-170">The built-in numeric types are structs, and they have properties and methods that you can access:</span></span>  
  
```csharp  
// Static method on type Byte.  
byte b = Byte.MaxValue;  
```  
  
 <span data-ttu-id="d3752-171">Ancak bildirmek ve bunların basit toplama olmayan türlermiş gibi bunlara değer atayamazsınız:</span><span class="sxs-lookup"><span data-stu-id="d3752-171">But you declare and assign values to them as if they were simple non-aggregate types:</span></span>  
  
```csharp  
byte num = 0xA;  
int i = 5;  
char c = 'Z';  
```  
  
 <span data-ttu-id="d3752-172">Değer türleri *korumalı*, yani, örneğin, bir türden türetilemez <xref:System.Int32?displayProperty=nameWithType>, ve bir yapı yalnızca kaynağından devralabileceğinden bir kullanıcı tanımlı sınıf veya yapıdan devralacak bir yapı tanımlayamazsınız <xref:System.ValueType?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d3752-172">Value types are *sealed*, which means, for example, that you cannot derive a type from <xref:System.Int32?displayProperty=nameWithType>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3752-173">Ancak, bir yapının bir veya daha fazla arabirim uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-173">However, a struct can implement one or more interfaces.</span></span> <span data-ttu-id="d3752-174">Bir yapı türünü uygulayan herhangi bir arabirim türüne çevirebilirsiniz; Bu neden olan bir *kutulama* yönetilen yığında struct bir başvuru türü nesnesi içine sarmak için işlemi.</span><span class="sxs-lookup"><span data-stu-id="d3752-174">You can cast a struct type to any interface type that it implements; this causes a *boxing* operation to wrap the struct inside a reference type object on the managed heap.</span></span> <span data-ttu-id="d3752-175">Kutulama işlemleri, bir değer türü alan bir yönteme geçirdiğinizde meydana bir <xref:System.Object?displayProperty=nameWithType> veya herhangi bir arabirim türü giriş parametresi olarak.</span><span class="sxs-lookup"><span data-stu-id="d3752-175">Boxing operations occur when you pass a value type to a method that takes a <xref:System.Object?displayProperty=nameWithType> or any interface type as an input parameter.</span></span> <span data-ttu-id="d3752-176">Daha fazla bilgi için [kutulama ve kutudan çıkarma](../../../csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-176">For more information, see [Boxing and Unboxing](../../../csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
 <span data-ttu-id="d3752-177">Kullandığınız [yapı](../../../csharp/language-reference/keywords/struct.md) kendi özel değer türlerinizi oluşturmak için anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="d3752-177">You use the [struct](../../../csharp/language-reference/keywords/struct.md) keyword to create your own custom value types.</span></span> <span data-ttu-id="d3752-178">Genellikle, bir yapının bir kapsayıcı gibi küçük bir ilişkili değişken kümesi için aşağıdaki örnekte gösterildiği gibi kullanılır:</span><span class="sxs-lookup"><span data-stu-id="d3752-178">Typically, a struct is used as a container for a small set of related variables, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideObjects#1](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/index_4.cs)]  
  
 <span data-ttu-id="d3752-179">Yapılar hakkında daha fazla bilgi için bkz. [yapılar](../../../csharp/programming-guide/classes-and-structs/structs.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-179">For more information about structs, see [Structs](../../../csharp/programming-guide/classes-and-structs/structs.md).</span></span> <span data-ttu-id="d3752-180">.NET içindeki değer türleri hakkında daha fazla bilgi için bkz. [değer türleri](../../../csharp/language-reference/keywords/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-180">For more information about value types in .NET, see [Value Types](../../../csharp/language-reference/keywords/value-types.md).</span></span>  
  
 <span data-ttu-id="d3752-181">Değer türlerinin diğer kategorisi [enum](../../../csharp/language-reference/keywords/enum.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-181">The other category of value types is [enum](../../../csharp/language-reference/keywords/enum.md).</span></span> <span data-ttu-id="d3752-182">Bir numaralandırma, adlandırılmış tam sayı sabitler kümesini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="d3752-182">An enum defines a set of named integral constants.</span></span> <span data-ttu-id="d3752-183">Örneğin, <xref:System.IO.FileMode?displayProperty=nameWithType> numaralandırma .NET sınıf kitaplığı'nda adlandırılmış bir dosyanın nasıl açılacağını belirten sabit tamsayı Seti içerir.</span><span class="sxs-lookup"><span data-stu-id="d3752-183">For example, the <xref:System.IO.FileMode?displayProperty=nameWithType> enumeration in the .NET class library contains a set of named constant integers that specify how a file should be opened.</span></span> <span data-ttu-id="d3752-184">Aşağıdaki örnekte gösterildiği gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="d3752-184">It is defined as shown in the following example:</span></span>  
 
 [!code-csharp[csProgGuideTypes#44](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_5.cs)]  
  
 <span data-ttu-id="d3752-185">`System.IO.FileMode.Create` Sabitinin değeri 2'dir.</span><span class="sxs-lookup"><span data-stu-id="d3752-185">The `System.IO.FileMode.Create` constant has a value of 2.</span></span> <span data-ttu-id="d3752-186">Ancak, ad, kaynak kodu okuyanlar için daha anlamlı olur ve bu nedenle sabit ve değişmez sayılar yerine numaralandırmalar kullanılması daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="d3752-186">However, the name is much more meaningful for humans reading the source code, and for that reason it is better to use enumerations instead of constant literal numbers.</span></span> <span data-ttu-id="d3752-187">Daha fazla bilgi için bkz. <xref:System.IO.FileMode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d3752-187">For more information, see <xref:System.IO.FileMode?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d3752-188">Tüm numaralandırmalar devralınacak <xref:System.Enum?displayProperty=nameWithType>, işlevinden devralan <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d3752-188">All enums inherit from <xref:System.Enum?displayProperty=nameWithType>, which inherits from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3752-189">Yapılar için geçerli olan tüm kurallar numaralandırmalar için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="d3752-189">All the rules that apply to structs also apply to enums.</span></span> <span data-ttu-id="d3752-190">Numaralandırmalar hakkında daha fazla bilgi için bkz. [Numaralandırma türleri](../../../csharp/programming-guide/enumeration-types.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-190">For more information about enums, see [Enumeration Types](../../../csharp/programming-guide/enumeration-types.md).</span></span>  
  
### <a name="reference-types"></a><span data-ttu-id="d3752-191">Başvuru Türleri</span><span class="sxs-lookup"><span data-stu-id="d3752-191">Reference Types</span></span>  
 <span data-ttu-id="d3752-192">Olarak tanımlanan bir tür bir [sınıfı](../../../csharp/language-reference/keywords/class.md), [temsilci](../../../csharp/language-reference/keywords/delegate.md), dizi veya [arabirimi](../../../csharp/language-reference/keywords/interface.md) olduğu bir *başvuru türüne*.</span><span class="sxs-lookup"><span data-stu-id="d3752-192">A type that is defined as a [class](../../../csharp/language-reference/keywords/class.md), [delegate](../../../csharp/language-reference/keywords/delegate.md), array, or [interface](../../../csharp/language-reference/keywords/interface.md) is a *reference type*.</span></span> <span data-ttu-id="d3752-193">Bir değişken bildirdiğinizde başvuru türü, çalışma zamanında değişken değeri içeren [null](../../../csharp/language-reference/keywords/null.md) açıkça kullanarak bir nesne oluşturma kadar [yeni](../../../csharp/language-reference/keywords/new.md) işleci veya olan bir nesne atama başka bir yerde kullanılarak oluşturulan `new`, aşağıdaki örnekte gösterildiği gibi:</span><span class="sxs-lookup"><span data-stu-id="d3752-193">At run time, when you declare a variable of a reference type, the variable contains the value [null](../../../csharp/language-reference/keywords/null.md) until you explicitly create an object by using the [new](../../../csharp/language-reference/keywords/new.md) operator, or assign it an object that has been created elsewhere by using `new`, as shown in the following example:</span></span>
  
```csharp  
MyClass mc = new MyClass();  
MyClass mc2 = mc;  
```  
   <span data-ttu-id="d3752-194">Bir arabirim, kendisini uygulayan bir sınıf nesnesiyle birlikte başlatılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d3752-194">An interface must be initialized together with a class object that implements it.</span></span> <span data-ttu-id="d3752-195">Varsa `MyClass` uygulayan `IMyInterface`, örneğini oluşturduğunuz `IMyInterface` aşağıdaki örnekte gösterildiği gibi:</span><span class="sxs-lookup"><span data-stu-id="d3752-195">If `MyClass` implements `IMyInterface`, you create an instance of `IMyInterface` as shown in the following example:</span></span>  
  
```csharp  
IMyInterface iface = new MyClass();  
```  
  
 <span data-ttu-id="d3752-196">Nesne oluşturulduğunda bellek yönetilen yığında ayrılır ve değişken yalnızca nesne konumu bir başvuru tutar.</span><span class="sxs-lookup"><span data-stu-id="d3752-196">When the object is created, the memory is allocated on the managed heap, and the variable holds only a reference to the location of the object.</span></span> <span data-ttu-id="d3752-197">Yönetilen yığındaki türler ayrıldıkları zaman hem olarak da bilinen CLR'nin otomatik bellek yönetimi işlevinin tarafından talep edilen zaman ek yükü gerektirir *çöp toplama*.</span><span class="sxs-lookup"><span data-stu-id="d3752-197">Types on the managed heap require overhead both when they are allocated and when they are reclaimed by the automatic memory management functionality of the CLR, which is known as *garbage collection*.</span></span> <span data-ttu-id="d3752-198">Ancak, çöp toplama yüksek oranda iyileştirilmiştir ve çoğu senaryoda, bir performans sorununa neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="d3752-198">However, garbage collection is also highly optimized, and in most scenarios it does not create a performance issue.</span></span> <span data-ttu-id="d3752-199">Çöp toplama hakkında daha fazla bilgi için bkz: [otomatik bellek yönetimi](../../../standard/automatic-memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-199">For more information about garbage collection, see [Automatic Memory Management](../../../standard/automatic-memory-management.md).</span></span>  
  
 <span data-ttu-id="d3752-200">Öğeleri değer türleri olsa bile, tüm diziler başvuru türleridir.</span><span class="sxs-lookup"><span data-stu-id="d3752-200">All arrays are reference types, even if their elements are value types.</span></span> <span data-ttu-id="d3752-201">Diziler dolaylı olarak türetilen <xref:System.Array?displayProperty=nameWithType> sınıfı, ancak bildirme ve bunları C# tarafından sağlanan Basitleştirilmiş sözdizimi ile aşağıdaki örnekte gösterildiği gibi kullanın:</span><span class="sxs-lookup"><span data-stu-id="d3752-201">Arrays implicitly derive from the <xref:System.Array?displayProperty=nameWithType> class, but you declare and use them with the simplified syntax that is provided by C#, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideTypes#45](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_6.cs)]  
  
 <span data-ttu-id="d3752-202">Başvuru türleri devralmayı tam olarak destekler.</span><span class="sxs-lookup"><span data-stu-id="d3752-202">Reference types fully support inheritance.</span></span> <span data-ttu-id="d3752-203">Bir sınıf oluşturduğunuz zaman, herhangi bir arabirim veya tanımlanmamış sınıfı devralabilirsiniz [korumalı](../../../csharp/language-reference/keywords/sealed.md), ve diğer sınıflar, sizin sınıfınızdan miras ve sanal yöntemlerinizi geçersiz kılabilir.</span><span class="sxs-lookup"><span data-stu-id="d3752-203">When you create a class, you can inherit from any other interface or class that is not defined as [sealed](../../../csharp/language-reference/keywords/sealed.md), and other classes can inherit from your class and override your virtual methods.</span></span> <span data-ttu-id="d3752-204">Kendi sınıflarınızı nasıl oluşturabileceğiniz hakkında daha fazla bilgi için bkz. [sınıfları ve yapıları](../../../csharp/programming-guide/classes-and-structs/index.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-204">For more information about how to create your own classes, see [Classes and Structs](../../../csharp/programming-guide/classes-and-structs/index.md).</span></span> <span data-ttu-id="d3752-205">Devralma ve sanal yöntemler hakkında daha fazla bilgi için bkz: [devralma](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-205">For more information about inheritance and virtual methods, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
## <a name="types-of-literal-values"></a><span data-ttu-id="d3752-206">Değişmez değer türleri</span><span class="sxs-lookup"><span data-stu-id="d3752-206">Types of Literal Values</span></span>  
 <span data-ttu-id="d3752-207">C# dilinde değişmez değerler derleyiciden bir tür alır.</span><span class="sxs-lookup"><span data-stu-id="d3752-207">In C#, literal values receive a type from the compiler.</span></span> <span data-ttu-id="d3752-208">Sayı sonuna bir harf ekleyerek sayısal değişmez değerin nasıl yazılacağını belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d3752-208">You can specify how a numeric literal should be typed by appending a letter to the end of the number.</span></span> <span data-ttu-id="d3752-209">Örneğin, 4.56 değerinin kaydırma olarak ele alınması gerektiğini belirtmek için bir "f" veya "F" sayı sonra Ekle: `4.56f`.</span><span class="sxs-lookup"><span data-stu-id="d3752-209">For example, to specify that the value 4.56 should be treated as a float, append an "f" or "F" after the number: `4.56f`.</span></span> <span data-ttu-id="d3752-210">Hiçbir harf eklenirse, derleyici değişmez değer için bir tür olarak çıkarımlar.</span><span class="sxs-lookup"><span data-stu-id="d3752-210">If no letter is appended, the compiler will infer a type for the literal.</span></span> <span data-ttu-id="d3752-211">Hangi belirtilebilen türler harf sonekleri daha fazla bilgi için her bir türe ilişkin başvuru sayfalarına bakın [değer türleri](../../../csharp/language-reference/keywords/value-types.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-211">For more information about which types can be specified with letter suffixes, see the reference pages for individual types in [Value Types](../../../csharp/language-reference/keywords/value-types.md).</span></span>  
  
 <span data-ttu-id="d3752-212">Değişmez değerler olduğu ve tüm türler nihai olarak türetmek için gelen <xref:System.Object?displayProperty=nameWithType>, yazabilir ve aşağıdaki gibi kodu derleyin:</span><span class="sxs-lookup"><span data-stu-id="d3752-212">Because literals are typed, and all types derive ultimately from <xref:System.Object?displayProperty=nameWithType>, you can write and compile code such as the following:</span></span>  
  
 [!code-csharp[csProgGuideTypes#37](../../../csharp/programming-guide/nullable-types/codesnippet/CSharp/index_7.cs)]  
  
## <a name="generic-types"></a><span data-ttu-id="d3752-213">Genel türler</span><span class="sxs-lookup"><span data-stu-id="d3752-213">Generic Types</span></span>  
 <span data-ttu-id="d3752-214">Bir türü bir veya daha fazla bildirilmiş *tür parametrelerindeki* gerçek tür için bir yer tutucu olarak hizmet veren ( *somut tür*) türün bir örneğini oluşturduğunda, istemci kodunun sağlayacağı.</span><span class="sxs-lookup"><span data-stu-id="d3752-214">A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type.</span></span> <span data-ttu-id="d3752-215">Bu türler olarak adlandırılır *genel türler*.</span><span class="sxs-lookup"><span data-stu-id="d3752-215">Such types are called *generic types*.</span></span> <span data-ttu-id="d3752-216">Örneğin, .NET türü <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> gereği adı verilen bir tür parametresine sahip *T*. Bir türün örneğini oluşturduğunuzda dize listesi yer alacak nesnelerin türünü belirtin:</span><span class="sxs-lookup"><span data-stu-id="d3752-216">For example, the .NET type <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</span></span>  
 
```csharp
List<string> stringList = new List<string>();
stringList.Add("String example");
// compile time error adding a type other than a string:
stringList.Add(4);
```
 <span data-ttu-id="d3752-217">Tür parametresinin kullanımı, her öğesine dönüştürmek zorunda kalmadan herhangi bir türde öğe için aynı sınıf yeniden mümkün kılar [nesne](../../../csharp/language-reference/keywords/object.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-217">The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](../../../csharp/language-reference/keywords/object.md).</span></span> <span data-ttu-id="d3752-218">Genel koleksiyon sınıflarına çağrılır *kesin olarak belirtilmiş koleksiyonlar* derleyici koleksiyonun öğelerinin belirli tür bilir ve derleme sırasında bir hata gönderebilirsiniz olduğundan, örneğin, bir tamsayı içineklemeyideneyin`stringList` önceki örnekte nesne.</span><span class="sxs-lookup"><span data-stu-id="d3752-218">Generic collection classes are called *strongly-typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `stringList` object in the previous example.</span></span> <span data-ttu-id="d3752-219">Daha fazla bilgi için [genel türler](../../../csharp/programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-219">For more information, see [Generics](../../../csharp/programming-guide/generics/index.md).</span></span>  
  
## <a name="implicit-types-anonymous-types-and-nullable-types"></a><span data-ttu-id="d3752-220">Örtülü türler, anonim türler ve boş değer atanabilir türler</span><span class="sxs-lookup"><span data-stu-id="d3752-220">Implicit Types, Anonymous Types, and Nullable Types</span></span>  
 <span data-ttu-id="d3752-221">Daha önce belirtildiği gibi örtük olarak yerel bir değişken (ancak sınıf üyeleri olmamak) kullanarak yazabilirsiniz [var](../../../csharp/language-reference/keywords/var.md) anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="d3752-221">As stated previously, you can implicitly type a local variable (but not class members) by using the [var](../../../csharp/language-reference/keywords/var.md) keyword.</span></span> <span data-ttu-id="d3752-222">Değişken derleme zamanında hala bir türü alır, ancak türü derleyici tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="d3752-222">The variable still receives a type at compile time, but the type is provided by the compiler.</span></span> <span data-ttu-id="d3752-223">Daha fazla bilgi için [örtük olarak yazılan yerel değişkenler](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-223">For more information, see [Implicitly Typed Local Variables](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="d3752-224">Bazı durumlarda, bu depolamak veya yöntemi sınırları dışında geçirmek istemediğiniz ilgili değer kümeleri için adlandırılmış bir tür oluşturmak çok kullanışsız olur.</span><span class="sxs-lookup"><span data-stu-id="d3752-224">In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</span></span> <span data-ttu-id="d3752-225">Oluşturabileceğiniz *anonim türler* bu amaç için.</span><span class="sxs-lookup"><span data-stu-id="d3752-225">You can create *anonymous types* for this purpose.</span></span> <span data-ttu-id="d3752-226">Daha fazla bilgi için [anonim türler](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-226">For more information, see [Anonymous Types](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md).</span></span>  
  
 <span data-ttu-id="d3752-227">Sıradan değer türleri değerine sahip [null](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-227">Ordinary value types cannot have a value of [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="d3752-228">Ancak, boş değer atanabilen değer türleri ekleyerek oluşturabileceğiniz bir `?` türden sonra.</span><span class="sxs-lookup"><span data-stu-id="d3752-228">However, you can create nullable value types by affixing a `?` after the type.</span></span> <span data-ttu-id="d3752-229">Örneğin, `int?` olduğu bir `int` değeri de olabilir bir tür [null](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-229">For example, `int?` is an `int` type that can also have the value [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="d3752-230">CTS içinde boş değer atanabilir türler genel yapı türünün örnekleridir <xref:System.Nullable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d3752-230">In the CTS, nullable types are instances of the generic struct type <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3752-231">Boş değer atanabilir türler için ve veritabanlarına sayı değerleri null olabilir veri geçirirken özellikle kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="d3752-231">Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null.</span></span> <span data-ttu-id="d3752-232">Daha fazla bilgi için [boş değer atanabilir türler](../../../csharp/programming-guide/nullable-types/index.md).</span><span class="sxs-lookup"><span data-stu-id="d3752-232">For more information, see [Nullable Types](../../../csharp/programming-guide/nullable-types/index.md).</span></span>  
  
## <a name="related-sections"></a><span data-ttu-id="d3752-233">İlgili Bölümler</span><span class="sxs-lookup"><span data-stu-id="d3752-233">Related Sections</span></span>  
 <span data-ttu-id="d3752-234">Daha fazla bilgi için aşağıdaki konulara bakın:</span><span class="sxs-lookup"><span data-stu-id="d3752-234">For more information, see the following topics:</span></span>  
  
-   [<span data-ttu-id="d3752-235">Tür Değiştirme ve Tür Dönüştürmeler</span><span class="sxs-lookup"><span data-stu-id="d3752-235">Casting and Type Conversions</span></span>](../../../csharp/programming-guide/types/casting-and-type-conversions.md)  
  
-   [<span data-ttu-id="d3752-236">Kutulama ve Kutudan Çıkarma</span><span class="sxs-lookup"><span data-stu-id="d3752-236">Boxing and Unboxing</span></span>](../../../csharp/programming-guide/types/boxing-and-unboxing.md)  
  
-   [<span data-ttu-id="d3752-237">Tür dinamiği kullanma</span><span class="sxs-lookup"><span data-stu-id="d3752-237">Using Type dynamic</span></span>](../../../csharp/programming-guide/types/using-type-dynamic.md)  
  
-   [<span data-ttu-id="d3752-238">Değer Türleri</span><span class="sxs-lookup"><span data-stu-id="d3752-238">Value Types</span></span>](../../../csharp/language-reference/keywords/value-types.md)  
  
-   [<span data-ttu-id="d3752-239">Başvuru Türleri</span><span class="sxs-lookup"><span data-stu-id="d3752-239">Reference Types</span></span>](../../../csharp/language-reference/keywords/reference-types.md)  
  
-   [<span data-ttu-id="d3752-240">Sınıflar ve Yapılar</span><span class="sxs-lookup"><span data-stu-id="d3752-240">Classes and Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/index.md)  
  
-   [<span data-ttu-id="d3752-241">Anonim Tipler</span><span class="sxs-lookup"><span data-stu-id="d3752-241">Anonymous Types</span></span>](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)  
  
-   [<span data-ttu-id="d3752-242">Genel Türler</span><span class="sxs-lookup"><span data-stu-id="d3752-242">Generics</span></span>](../../../csharp/programming-guide/generics/index.md)  

## <a name="c-language-specification"></a><span data-ttu-id="d3752-243">C# Dil Belirtimi</span><span class="sxs-lookup"><span data-stu-id="d3752-243">C# Language Specification</span></span>  
 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]  
  
## <a name="see-also"></a><span data-ttu-id="d3752-244">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="d3752-244">See also</span></span>

- [<span data-ttu-id="d3752-245">C# başvurusu</span><span class="sxs-lookup"><span data-stu-id="d3752-245">C# Reference</span></span>](../../../csharp/language-reference/index.md)
- [<span data-ttu-id="d3752-246">C# Programlama Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="d3752-246">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
- [<span data-ttu-id="d3752-247">XML Veri Türlerini Dönüştürme</span><span class="sxs-lookup"><span data-stu-id="d3752-247">Conversion of XML Data Types</span></span>](../../../standard/data/xml/conversion-of-xml-data-types.md)
- [<span data-ttu-id="d3752-248">Tam Sayı Türleri Tablosu</span><span class="sxs-lookup"><span data-stu-id="d3752-248">Integral Types Table</span></span>](../../../csharp/language-reference/keywords/integral-types-table.md)

---
title: Tanımlama grubu türleri - C# Kılavuzu
description: C# adsız ve adlandırılmış bir tanımlama grubu türleri hakkında bilgi edinin
ms.date: 05/15/2018
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 2c2b25c34555699c196099c0e1c51681fba8c358
ms.sourcegitcommit: 0069cb3de8eed4e92b2195d29e5769a76111acdd
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/16/2019
ms.locfileid: "56332760"
---
# <a name="c-tuple-types"></a><span data-ttu-id="33d3b-103">C# demet türleri</span><span class="sxs-lookup"><span data-stu-id="33d3b-103">C# tuple types</span></span> #

<span data-ttu-id="33d3b-104">C# diziler basit bir söz dizimi kullanılarak tanımladığınız türleridir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="33d3b-105">Avantajları, daha basit bir sözdizimi, dönüştürmeleri (kardinalite adlandırılır) sayısını ve türlerini öğeleri ve tutarlı kuralları kopyalar, eşitlik testleri ve atamaları göre kurallarını içerir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="33d3b-106">Bir tradeoff diziler bazı devralma ile ilişkili nesne yönelimli deyimlerini desteklemez.</span><span class="sxs-lookup"><span data-stu-id="33d3b-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="33d3b-107">Bir genel bakış bölümünde alma [C# 7.0 yenilikleri içindeki diziler](whats-new/csharp-7.md#tuples) makalesi.</span><span class="sxs-lookup"><span data-stu-id="33d3b-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="33d3b-108">Bu makalede, C# 7.0 ve üzeri sürümler tanımlama grupları ile çalışma hakkında onlara ve Başlangıç Kılavuzu kullanmak için farklı yollar diziler dil kuralları öğreneceksiniz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="33d3b-109">Yeni diziler işlevleri <xref:System.ValueTuple> türleri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="33d3b-110">NuGet paketini eklemeniz gerekir [ `System.ValueTuple` ](https://www.nuget.org/packages/System.ValueTuple/) türlerini içermez platformlarda kullanmak için.</span><span class="sxs-lookup"><span data-stu-id="33d3b-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="33d3b-111">Bu çerçevede teslim türleri kullanan diğer dil özellikleri benzer.</span><span class="sxs-lookup"><span data-stu-id="33d3b-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="33d3b-112">Örnekler `async` ve `await` güvenmek `INotifyCompletion` arabirimi ve bağlı LINQ `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="33d3b-113">Ancak, .NET, daha fazla platform bağımsız olma gibi teslim mekanizması değişiyor.</span><span class="sxs-lookup"><span data-stu-id="33d3b-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="33d3b-114">.NET Framework her zaman aynı temposu dil derleyicisi olarak yükleyeceğiniz değil.</span><span class="sxs-lookup"><span data-stu-id="33d3b-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="33d3b-115">Yeni dil özellikleri üzerinde yeni türler kullanan, dil başlayamıyorsunuz türlerine NuGet paketleri olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="33d3b-116">Bu yeni türleri ve .NET standart API için eklenen framework'ün bir parçası olarak sunulan NuGet paketini gereksinim kaldırılacak.</span><span class="sxs-lookup"><span data-stu-id="33d3b-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="33d3b-117">Yeni bir tanımlama grubu desteği ekleme nedenleri başlayalım.</span><span class="sxs-lookup"><span data-stu-id="33d3b-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="33d3b-118">Yöntemler, tek bir nesne döndürür.</span><span class="sxs-lookup"><span data-stu-id="33d3b-118">Methods return a single object.</span></span> <span data-ttu-id="33d3b-119">Diziler, daha kolay, tek bir nesnede birden çok değer paketi sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d3b-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="33d3b-120">.NET Framework genel zaten `Tuple` sınıfları.</span><span class="sxs-lookup"><span data-stu-id="33d3b-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="33d3b-121">Bu sınıfların ancak iki önemli sınırlamalarını vardı.</span><span class="sxs-lookup"><span data-stu-id="33d3b-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="33d3b-122">Biri, `Tuple` sınıflar adlandırılan özelliklerini `Item1`, `Item2`ve benzeri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="33d3b-123">Bu adları anlamsal bilgi taşır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-123">Those names carry no semantic information.</span></span> <span data-ttu-id="33d3b-124">Bunları kullanarak `Tuple` türleri özelliklerin her birini anlamını iletişim sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="33d3b-125">Yeni dil özellikleri bildirme ve bir grup içinde öğeler için anlamsal olarak anlamlı adlar kullanın olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d3b-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="33d3b-126">`Tuple` Sınıfları neden daha fazla performans endişelerini çünkü bunlar başvuru türleri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="33d3b-127">Aşağıdakilerden birini kullanarak `Tuple` türleri nesneleri ayırma anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="33d3b-128">Etkin yolları üzerinde çok sayıda küçük nesne ayırma, uygulamanızın performans üzerinde ölçülebilir bir etkisi olabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="33d3b-129">Bu nedenle, diziler için dil desteği yeni yararlanır `ValueTuple` yapılar.</span><span class="sxs-lookup"><span data-stu-id="33d3b-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="33d3b-130">Bu eksiklikleri önlemek için aşağıdakileri oluşturabilirsiniz bir `class` veya `struct` birden çok öğe yürütmek için.</span><span class="sxs-lookup"><span data-stu-id="33d3b-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="33d3b-131">Ne yazık ki sizin için daha fazla iş olduğunu ve tasarım amacınızla gizler.</span><span class="sxs-lookup"><span data-stu-id="33d3b-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="33d3b-132">Yapmadan bir `struct` veya `class` hem verileri hem de davranışı ile bir tür tanımlama anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="33d3b-133">Çoğu zaman, yalnızca birden çok değeri tek bir nesnede depolamak istediğiniz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="33d3b-134">Dil özellikleri ve `ValueTuple` genel yapılar bu demet türleri için herhangi bir davranış (yöntem) ekleyemezsiniz kuralı uygular.</span><span class="sxs-lookup"><span data-stu-id="33d3b-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="33d3b-135">Tüm `ValueTuple` türleridir *değişebilir yapılar*.</span><span class="sxs-lookup"><span data-stu-id="33d3b-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="33d3b-136">Her üye alan genel bir alandır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-136">Each member field is a public field.</span></span> <span data-ttu-id="33d3b-137">Bunları çok basit hale getirir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-137">That makes them very lightweight.</span></span> <span data-ttu-id="33d3b-138">Ancak, diziler, değiştirilemezlik önemli olduğu kullanılmamalıdır anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="33d3b-139">Diziler, hem daha basit ve daha esnek veri kapsayıcılardır daha `class` ve `struct` türleri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="33d3b-140">Bu farklar araştıralım.</span><span class="sxs-lookup"><span data-stu-id="33d3b-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="33d3b-141">Adlandırılmış ve adlandırılmamış diziler</span><span class="sxs-lookup"><span data-stu-id="33d3b-141">Named and unnamed tuples</span></span>

<span data-ttu-id="33d3b-142">`ValueTuple` Yapı sahip alanları adlı `Item1`, `Item2`, `Item3`ve benzeri varolan tanımlanan özelliklere benzer `Tuple` türleri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="33d3b-143">Bu adlar için kullanabileceğiniz adlar şunlardır *diziler adlandırılmamış*.</span><span class="sxs-lookup"><span data-stu-id="33d3b-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="33d3b-144">Bir demet için herhangi bir diğer alan adı belirtmezseniz, adlandırılmamış bir tanımlama grubu oluşturdunuz:</span><span class="sxs-lookup"><span data-stu-id="33d3b-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="33d3b-145">Önceki örnekte demet sabit değeri sabitler kullanılarak başlatıldı ve öğe adları kullanılarak oluşturulan sahip olmaz *demet alan adı projeksiyonlar* C# 7.1 içinde.</span><span class="sxs-lookup"><span data-stu-id="33d3b-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="33d3b-146">Ancak, bir tanımlama grubu başlattığınızda her alan için daha iyi adlar vermek yeni dil özelliklerini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="33d3b-147">Bunun yapılması oluşturur bir *demet adlı*.</span><span class="sxs-lookup"><span data-stu-id="33d3b-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="33d3b-148">Adlandırılmış diziler adlı öğe çözümlenmedi `Item1`, `Item2`, `Item3` ve benzeri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="33d3b-149">Ancak herhangi biri söz konusu öğelerin adlı için eş anlamlı sözcükler de sahiptir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="33d3b-150">Adlandırılmış bir tanımlama grubu, her öğe için bir ad belirterek oluşturun.</span><span class="sxs-lookup"><span data-stu-id="33d3b-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="33d3b-151">Dizi başlatma bir parçası olarak adlarını belirtin bir yoludur:</span><span class="sxs-lookup"><span data-stu-id="33d3b-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="33d3b-152">Bu eş anlamlıların derleyici tarafından işlenir ve dil etkili bir şekilde adlandırılmış'u diziler böylece kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="33d3b-153">Roslyn API'leri kullanılarak bu anlamsal adları IDE'ler ve düzenleyicilerden okuyabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="33d3b-154">Adlandırılmış bir tanımlama grubu öğelerinin aynı derlemenin başka bir yerindeki bu anlamsal adlarıyla başvurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="33d3b-155">Derleyici ile tanımladığınız adlarını değiştirir `Item*` derlenen Çıkışta oluştururken eşdeğerleri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="33d3b-156">Derlenmiş Microsoft Ara dil (MSIL) bu öğeleri tanıdığımıza adları içermez.</span><span class="sxs-lookup"><span data-stu-id="33d3b-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="33d3b-157">C# 7.1 ile başlayarak, alan adları bir demet için demet başlatmak için kullanılan değişkenleri sağlanabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="33d3b-158">Bu olarak adlandırılır  **[demet projeksiyon başlatıcılar](#tuple-projection-initializers)**.</span><span class="sxs-lookup"><span data-stu-id="33d3b-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="33d3b-159">Aşağıdaki kod adlı bir kayıt düzeni oluşturur `accumulation` öğelerle `count` (tamsayı), ve `sum` (çift).</span><span class="sxs-lookup"><span data-stu-id="33d3b-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="33d3b-160">Derleyici, genel yöntemleri veya özellikleri döndürülen diziler için oluşturulan bu adları iletişim kurması gerekir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="33d3b-161">Bu gibi durumlarda, derleyicinin ekler bir <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> yöntemi özniteliği.</span><span class="sxs-lookup"><span data-stu-id="33d3b-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="33d3b-162">Bu öznitelik içeren bir <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> dizideki öğelerin her biri için verilen adları içeren özellik listesi.</span><span class="sxs-lookup"><span data-stu-id="33d3b-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="33d3b-163">Visual Studio gibi geliştirme araçları da bu meta verileri okuyun ve IntelliSense ve meta verileri alan adları kullanarak diğer özellikleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d3b-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="33d3b-164">Bu yeni diziler temelleri temel anlamak önemlidir ve `ValueTuple` atama kurallarını anlamak için türü adlı birbirine tanımlama grubu.</span><span class="sxs-lookup"><span data-stu-id="33d3b-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="33d3b-165">Tanımlama grubu projeksiyon başlatıcıları</span><span class="sxs-lookup"><span data-stu-id="33d3b-165">Tuple projection initializers</span></span>

<span data-ttu-id="33d3b-166">Genel olarak, bir dizi başlatma ifadesinin sağ tarafı değişken veya alan adları kullanarak demet projeksiyon başlatıcılar çalışır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="33d3b-167">Açık bir ad belirtilmezse, öngörülen herhangi bir ad öncelik kazanır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="33d3b-168">Örneğin, aşağıdaki başlatıcısında öğeleridir `explicitFieldOne` ve `explicitFieldTwo`değil `localVariableOne` ve `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="33d3b-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="33d3b-169">Burada açık bir ad sağlanmazsa herhangi bir alan için geçerli bir örtük adı yansıtılır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="33d3b-170">Anlam adları açıkça veya örtülü olarak sağlamak için bir gereksinim değildir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="33d3b-171">Aşağıdaki Başlatıcı alan adlarını sahip `Item1`, değeri olan `42` ve `stringContent`, "Her şey için yanıt" değeri olan:</span><span class="sxs-lookup"><span data-stu-id="33d3b-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="33d3b-172">Burada aday alan adları demet alan yansıtılan değil iki koşul vardır:</span><span class="sxs-lookup"><span data-stu-id="33d3b-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="33d3b-173">Aday adı ayrılmış demet adını olduğunda.</span><span class="sxs-lookup"><span data-stu-id="33d3b-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="33d3b-174">Örnekler `Item3`, `ToString`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-174">Examples include `Item3`, `ToString`.</span></span> <span data-ttu-id="33d3b-175">veya `Rest`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-175">or `Rest`.</span></span>
1. <span data-ttu-id="33d3b-176">Ne zaman aday adı açık veya örtülü başka bir tanımlama grubu alan adı yineleniyor.</span><span class="sxs-lookup"><span data-stu-id="33d3b-176">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="33d3b-177">Bu koşullar belirsizlik kaçının.</span><span class="sxs-lookup"><span data-stu-id="33d3b-177">These conditions avoid ambiguity.</span></span> <span data-ttu-id="33d3b-178">Bu adlar, tanımlama grubu alanın alan adları olarak kullanıldıysa belirsizliğe neden olur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-178">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="33d3b-179">Bu koşulların hiçbiri, derleme zamanı hatalarına neden.</span><span class="sxs-lookup"><span data-stu-id="33d3b-179">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="33d3b-180">Bunun yerine, öğeler olmadan öngörülen adları bunlar için öngörülen anlam adları yok.</span><span class="sxs-lookup"><span data-stu-id="33d3b-180">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="33d3b-181">Aşağıdaki örnekler, bu koşullar göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="33d3b-181">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="33d3b-182">Bu durumlarda, bir dizi alan adı projeksiyonlar kullanılabilir değil, C# 7.0 ile yazılan kod için değişiklik olacağından derleyici hataları neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-182">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="33d3b-183">Eşitlik ve diziler</span><span class="sxs-lookup"><span data-stu-id="33d3b-183">Equality and tuples</span></span>

<span data-ttu-id="33d3b-184">C# 7.3 ile başlayarak, tanımlama grubu türleri desteği `==` ve `!=` işleçleri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-184">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="33d3b-185">Bu işleçler sırayla sağ bağımsız değişkeni her üyesi sol bağımsız değişkeni her üyesi karşılaştırarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-185">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="33d3b-186">Bu karşılaştırmalar kısa devre oluşturur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-186">These comparisons short-circuit.</span></span> <span data-ttu-id="33d3b-187">Bunlar üyeleri bir çifti eşit değil olarak değerlendiriliyor durdurur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-187">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="33d3b-188">Aşağıdaki kod örnekleri kullan `==`, ancak tüm uygulamak için karşılaştırma kurallarını `!=`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-188">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="33d3b-189">Aşağıdaki kod örneği, iki tamsayı çiftleri için bir eşitlik karşılaştırması gösterir:</span><span class="sxs-lookup"><span data-stu-id="33d3b-189">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="33d3b-190">Tanımlama grubu eşitliği testleri daha kullanışlı hale çeşitli kurallar vardır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-190">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="33d3b-191">Tanımlama grubu eşitliği gerçekleştirir [dönüştürmeler yükseltilmiş](~/_csharplang/spec/conversions.md#lifted-conversion-operators) diziler biri aşağıdaki kodda gösterildiği gibi boş değer atanabilir bir tanımlama grubu ise:</span><span class="sxs-lookup"><span data-stu-id="33d3b-191">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="33d3b-192">Tanımlama grubu eşitliği, ayrıca hem de tanımlama gruplarının her üye üzerinde örtük dönüştürmeleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-192">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="33d3b-193">Bunlar, dönüştürme, yükseltilmiş dönüştürmeler ve diğer örtük dönüştürmeleri genişletme içerir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-193">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="33d3b-194">Aşağıdaki örnekler bir tamsayı 2 bölütlü uzun bir 2-demet tamsayıya örtülü dönüştürme nedeniyle karşılaştırılabilir uzun:</span><span class="sxs-lookup"><span data-stu-id="33d3b-194">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="33d3b-195">Tanımlama grubu üyelerinin adları eşitliği testleri katılmaz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-195">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="33d3b-196">Ancak, biri açık adlar ile sabit tanımlama grubu ise, bu adlar diğer işlenen adları eşleşmiyorsa derleyici uyarı CS8383 oluşturur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-196">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="33d3b-197">Her iki işlenen demet sabit olduğu durumda, uyarıyı sağ işlenen üzerinde aşağıdaki örnekte gösterildiği gibi verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="33d3b-197">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="33d3b-198">Son olarak, diziler, iç içe geçmiş bir tanımlama grubu içerebilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-198">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="33d3b-199">Tanımlama grubu eşitliği "aşağıdaki örnekte gösterilen şeklini" iç içe geçmiş tanımlama grupları halinde aracılığıyla her işlenen karşılaştırılır:</span><span class="sxs-lookup"><span data-stu-id="33d3b-199">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="33d3b-200">Eşitlik (ya da eşitsizlik) için iki diziler karşılaştırmak için bir derleme zamanı hata farklı şekiller zaman sahiptirler.</span><span class="sxs-lookup"><span data-stu-id="33d3b-200">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="33d3b-201">Kazanılan derleyici ' iç içe geçmiş bir tanımlama grubu herhangi bir ayrıştırma bunları karşılaştırmak için çalışır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-201">The compiler won' attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="33d3b-202">Atama ve diziler</span><span class="sxs-lookup"><span data-stu-id="33d3b-202">Assignment and tuples</span></span>

<span data-ttu-id="33d3b-203">Burada her sağ tarafı öğe örtük karşılık gelen sol tarafı öğesine dönüştürülebilir aynı sayıda öğe olan tanımlama grubu türleri arasında atama dili destekler.</span><span class="sxs-lookup"><span data-stu-id="33d3b-203">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="33d3b-204">Diğer dönüştürme atamalarını bulundurulmaz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-204">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="33d3b-205">Bu farklı şekillere sahip oldukları zaman bir tanımlama grubu atamak için bir derleme zamanı hatasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-205">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="33d3b-206">Derleyici iç içe geçmiş bir tanımlama grubu herhangi bir ayrıştırma bunları atamak için deneme olmaz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-206">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="33d3b-207">Tanımlama grubu türleri arasında izin atamaları türlerini bakalım.</span><span class="sxs-lookup"><span data-stu-id="33d3b-207">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="33d3b-208">Aşağıdaki örneklerde kullanılan bu değişkenleri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="33d3b-208">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="33d3b-209">İlk iki değişken `unnamed` ve `anonymous` olmayan öğeler için sağlanan anlam adlarına sahip.</span><span class="sxs-lookup"><span data-stu-id="33d3b-209">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="33d3b-210">Alan adları `Item1` ve `Item2`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-210">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="33d3b-211">Son iki değişken `named` ve `differentName` öğeleri için verilen anlam adlarına sahip.</span><span class="sxs-lookup"><span data-stu-id="33d3b-211">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="33d3b-212">Bu iki diziler öğeler için farklı adlara sahip.</span><span class="sxs-lookup"><span data-stu-id="33d3b-212">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="33d3b-213">Dört bu tanımlama grubu aynı sayıda öğe ('önem' adlandırılır) varsa ve söz konusu öğelerin türleri aynı.</span><span class="sxs-lookup"><span data-stu-id="33d3b-213">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="33d3b-214">Bu nedenle, tüm bu atamaları çalışır:</span><span class="sxs-lookup"><span data-stu-id="33d3b-214">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="33d3b-215">Tanımlama grubu adlarını atanmamış dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="33d3b-215">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="33d3b-216">Dizideki öğelerin sırasını aşağıdaki öğelerin değerlerinin atanır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-216">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="33d3b-217">Farklı türler veya öğeleri sayıda tanımlama atanabilir değil:</span><span class="sxs-lookup"><span data-stu-id="33d3b-217">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="33d3b-218">Yöntemin dönüş değeri olarak diziler</span><span class="sxs-lookup"><span data-stu-id="33d3b-218">Tuples as method return values</span></span>

<span data-ttu-id="33d3b-219">Demetler en yaygın kullanımlarından biri, yöntemi dönüş değeridir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-219">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="33d3b-220">Bir örnek atalım.</span><span class="sxs-lookup"><span data-stu-id="33d3b-220">Let's walk through one example.</span></span> <span data-ttu-id="33d3b-221">Bir sayı dizisi üzerinde için standart sapmayı hesaplar. Bu yöntem göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="33d3b-221">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="33d3b-222">Bu örnekler düzeltilemeyen örnek standart sapma hesaplaması.</span><span class="sxs-lookup"><span data-stu-id="33d3b-222">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="33d3b-223">Düzeltilmiş örnek standart sapma formülü (N-1) tarafından N yerine mean squared fark toplamı olarak çizilmesini sağlıyordu `Average` uzantı yöntemi yapar.</span><span class="sxs-lookup"><span data-stu-id="33d3b-223">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="33d3b-224">Standart sapma bu formülleri arasındaki farklar hakkında daha fazla ayrıntı için istatistikleri metin başvurun.</span><span class="sxs-lookup"><span data-stu-id="33d3b-224">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="33d3b-225">Yukarıdaki kod Ders Kitabı standart sapma formülü aşağıdadır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-225">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="33d3b-226">Doğru yanıtı oluşturur, ancak bu verimsiz bir uygulaması.</span><span class="sxs-lookup"><span data-stu-id="33d3b-226">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="33d3b-227">Bu yöntem dizisi iki kez listeler: Ortalama üretmek için bir kez ve ortalama farkı karesini ortalamasını üretmek için bir kez.</span><span class="sxs-lookup"><span data-stu-id="33d3b-227">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="33d3b-228">(Ortalama fark hesaplama ve bu farklar ortalaması yalnızca bir sabit listesi yapsak LINQ sorguları gevşek, değerlendirildiğini unutmayın.)</span><span class="sxs-lookup"><span data-stu-id="33d3b-228">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="33d3b-229">Standart sapma yalnızca bir sabit listesi sırası kullanarak hesaplar alternatif bir formül yoktur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-229">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="33d3b-230">Sıralı listeler gibi bu hesaplama iki değer üretir: dizisindeki tüm öğelerin toplamının yanı sıra, her bir değerin toplamını kare:</span><span class="sxs-lookup"><span data-stu-id="33d3b-230">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="33d3b-231">Bu sürümü tam bir kez sırasını numaralandırır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-231">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="33d3b-232">Ancak, yeniden kullanılabilir kod değil.</span><span class="sxs-lookup"><span data-stu-id="33d3b-232">But it's not reusable code.</span></span> <span data-ttu-id="33d3b-233">Çalışmaya devam gibi birçok farklı istatistiksel hesaplamalar öğe dizisi, dizinin toplamı ve dizinin kareler toplamı kullanmak bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-233">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="33d3b-234">Şimdi bu yöntem yeniden düzenleyin ve üçünü de bu değerleri üreten bir yardımcı yöntemi yazın.</span><span class="sxs-lookup"><span data-stu-id="33d3b-234">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="33d3b-235">Bir tanımlama grubu olarak, tüm üç değer döndürülebilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-235">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="33d3b-236">Numaralandırma sırasında hesaplanan üç değerden bir grup içinde depolanır. böylece bu yöntem güncelleştirelim.</span><span class="sxs-lookup"><span data-stu-id="33d3b-236">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="33d3b-237">Bu sürümü oluşturan:</span><span class="sxs-lookup"><span data-stu-id="33d3b-237">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="33d3b-238">Visual Studio'nun yeniden düzenleme desteği, özel bir yöntem işlevselliği temel istatistikleri için ayıklamak üzere kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-238">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="33d3b-239">Size bir `private static` demet türü ile üç değerden döndüren yöntem `Sum`, `SumOfSquares`, ve `Count`:</span><span class="sxs-lookup"><span data-stu-id="33d3b-239">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]
 
<span data-ttu-id="33d3b-240">Birkaç hızlı düzenlemeler el ile yapmak istiyorsanız dil kullanabilirsiniz, daha fazla birkaç seçeneği sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d3b-240">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="33d3b-241">İlk olarak kullanabileceğiniz `var` demet sonuçtan başlatmak için bildirimi `ComputeSumAndSumOfSquares` yöntem çağrısı.</span><span class="sxs-lookup"><span data-stu-id="33d3b-241">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="33d3b-242">İçinde üç ayrık değişkeni de oluşturabilirsiniz `ComputeSumAndSumOfSquares` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="33d3b-242">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="33d3b-243">Son sürümü, aşağıdaki kodda gösterilmiştir:</span><span class="sxs-lookup"><span data-stu-id="33d3b-243">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="33d3b-244">Bu son sürümü, üç değerlerin veya bunların herhangi bir alt gereken herhangi bir yöntem için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-244">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="33d3b-245">Dil, bu kayıt döndüren yöntemler öğelerin adlarını yönetilmesindeki diğer seçeneklerini destekler.</span><span class="sxs-lookup"><span data-stu-id="33d3b-245">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="33d3b-246">Dönüş değeri bildirimden alan adlarını kaldırın ve adlandırılmamış bir tanımlama grubu döndürür:</span><span class="sxs-lookup"><span data-stu-id="33d3b-246">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="33d3b-247">Bu dizi alanları adlı `Item1`, `Item2`, ve `Item3`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-247">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="33d3b-248">Anlam yöntemlerinden döndürülen tanımlama grubu öğelerinin adlarını sağlamanız önerilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-248">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="33d3b-249">Başka bir deyim burada diziler yararlı olabilir, LINQ sorguları geliştirmekte olduğunuz durumdur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-249">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="33d3b-250">Öngörülen sonucunu bazı, tümü değil, genellikle seçili nesnelerin özelliklerini içerir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-250">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="33d3b-251">Geleneksel olarak anonim bir tür olan nesneleri dizisine sorgunun sonuçlarının proje.</span><span class="sxs-lookup"><span data-stu-id="33d3b-251">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="33d3b-252">Öncelikle anonim türler rahatça dönüş türünü bir yöntem için adlandırılabilir değildir çünkü, çok sayıda sınırlamaya sunulur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-252">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="33d3b-253">Kullanarak alternatifleri `object` veya `dynamic` sonuç türü önemli performans maliyetleri ile birlikte gelen gibi.</span><span class="sxs-lookup"><span data-stu-id="33d3b-253">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="33d3b-254">Bir demet dizisi döndürme türü kolaydır ve adlarını ve türlerini öğelerin derleme zamanında ve IDE araçları aracılığıyla kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-254">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="33d3b-255">Örneğin, bir ToDo uygulaması göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="33d3b-255">For example, consider a ToDo application.</span></span> <span data-ttu-id="33d3b-256">Yapılacaklar listesindeki tek bir giriş temsil etmek için aşağıdakine benzer bir sınıf tanımlayabilir:</span><span class="sxs-lookup"><span data-stu-id="33d3b-256">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="33d3b-257">Mobil uygulamalarınızı, yalnızca bir başlık görüntüler compact geçerli Yapılacaklar öğelerine biçiminin destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-257">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="33d3b-258">LINQ sorgusu bir projeksiyon, yapacağınız, yalnızca ID ve başlık içerir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-258">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="33d3b-259">Diziler bir dizi döndüren bir yöntem de bu tasarım ifade eder:</span><span class="sxs-lookup"><span data-stu-id="33d3b-259">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="33d3b-260">C# 7.1, demet projeksiyonlar adlandırılmış diziler özellik adlarının anonim türleri benzer bir şekilde öğelerini kullanarak oluşturmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d3b-260">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="33d3b-261">Yukarıdaki kodda, `select` sorgu projeksiyon deyiminde öğeleri olan tanımlama grubu oluşturur `ID` ve `Title`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-261">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="33d3b-262">Adlandırılmış demet imzasının bir parçası olabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-262">The named tuple can be part of the signature.</span></span> <span data-ttu-id="33d3b-263">Derleyici sağlar ve IDE araçları statik sonucu doğru kullanıyorsanız denetimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d3b-263">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="33d3b-264">Sonuçları ile çalışmak için pahalı çalışma zamanı özellikleri yansıma veya dinamik bağlama gibi kullanılması gerekmez bu nedenle adlandırılmış demet ayrıca statik tür bilgilerini taşır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-264">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="33d3b-265">Ayrıştırma</span><span class="sxs-lookup"><span data-stu-id="33d3b-265">Deconstruction</span></span>

<span data-ttu-id="33d3b-266">Tarafından bir tanımlama grubu içindeki tüm öğeler Sunu paketini *ayrıştırma* yöntemi tarafından döndürülen dizi.</span><span class="sxs-lookup"><span data-stu-id="33d3b-266">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="33d3b-267">Diziler ayrıştırma için üç farklı yaklaşım vardır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-267">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="33d3b-268">İlk olarak, dizideki öğelerin her biri için ayrık değişkenlerinin parantez içinde her alanın türünü açıkça bildirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="33d3b-268">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="33d3b-269">Kullanarak bir tanımlama grubu içindeki her alan için örtük olarak yazılan değişkenleri bildirebilirsiniz `var` anahtar sözcüğü parantezler dışında:</span><span class="sxs-lookup"><span data-stu-id="33d3b-269">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="33d3b-270">Kullanılacak yasaldır `var` anahtar sözcüğü, bir bölümünü veya tamamını parantez içinde değişken bildirimleri ile.</span><span class="sxs-lookup"><span data-stu-id="33d3b-270">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span> 

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="33d3b-271">Dizideki her alan aynı türde olsa bile, belirli bir tür parantez dışında kullanamazsınız.</span><span class="sxs-lookup"><span data-stu-id="33d3b-271">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="33d3b-272">Varolan bildirimler ile tanımlama grubu Ayrıştır:</span><span class="sxs-lookup"><span data-stu-id="33d3b-272">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
>  <span data-ttu-id="33d3b-273">Varolan bildirimler bildirimi parantez içinde ile karıştırılamaz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-273">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="33d3b-274">Örneğin, aşağıdaki izin verilmiyor: `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-274">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="33d3b-275">Bu hata CS8184 çünkü oluşturur *x* parantez içinde bildirilir ve *y* daha önce başka bir yerde bildirilmiş.</span><span class="sxs-lookup"><span data-stu-id="33d3b-275">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="33d3b-276">Kullanıcı tanımlı türleri ayrıştırma</span><span class="sxs-lookup"><span data-stu-id="33d3b-276">Deconstructing user-defined types</span></span>

<span data-ttu-id="33d3b-277">Yukarıda da gösterildiği gibi herhangi bir demet türü ayrıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-277">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="33d3b-278">Ayrıştırma (sınıflar, yapılar veya hatta arabirimleri) kullanıcı tanımlı tür üzerinde etkinleştirmek çok kolaydır.</span><span class="sxs-lookup"><span data-stu-id="33d3b-278">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="33d3b-279">Türü yazarı, bir veya daha fazla tanımlayabilirsiniz `Deconstruct` dilediğiniz sayıda atayabilmeniz yöntemleri `out` türünü oluşturan veri öğelerini temsil eden değişken.</span><span class="sxs-lookup"><span data-stu-id="33d3b-279">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="33d3b-280">Örneğin, aşağıdaki `Person` türünü tanımlayan bir `Deconstruct` ad ve soyadı temsil eden öğeyi bir kişi nesnesinin deconstructs yöntemi:</span><span class="sxs-lookup"><span data-stu-id="33d3b-280">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="33d3b-281">Atamadan deconstruct yöntemi sağlayan bir `Person` temsil eden iki dizelere `FirstName` ve `LastName` özellikleri:</span><span class="sxs-lookup"><span data-stu-id="33d3b-281">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="33d3b-282">Ayrıştırma deyiminin bile değil Yazar türleri için etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-282">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="33d3b-283">`Deconstruct` Yöntemi, bir nesnenin erişilebilir veri üyelerine tutucusu paketten çıkarır bir genişletme yöntemi olabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-283">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="33d3b-284">Gösterir aşağıdaki örnekte bir `Student` türetilen tür, `Person` türü ve deconstructs bir genişletme yöntemi bir `Student` temsil eden üç değişkenin içine `FirstName`, `LastName`ve `GPA`:</span><span class="sxs-lookup"><span data-stu-id="33d3b-284">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="33d3b-285">A `Student` nesne artık sahip iki erişilebilir `Deconstruct` yöntemleri: genişletme yöntemi için bildirilen `Student` türleri ve üyesi `Person` türü.</span><span class="sxs-lookup"><span data-stu-id="33d3b-285">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="33d3b-286">Her ikisi de kapsamındaki ve sağlayan bir `Student` iki değişkeni veya üç deconstructed için.</span><span class="sxs-lookup"><span data-stu-id="33d3b-286">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="33d3b-287">Bir öğrenci üç değişkenlere atarsanız, tüm ad son adı ve GPA döndürdü.</span><span class="sxs-lookup"><span data-stu-id="33d3b-287">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="33d3b-288">İki değişken için bir öğrenci atarsanız, yalnızca ilk adı ve Soyadı döndürülür.</span><span class="sxs-lookup"><span data-stu-id="33d3b-288">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="33d3b-289">Birden fazla tanımlama dikkatli olmanız gerekir `Deconstruct` yöntemleri bir sınıf ya da bir sınıf hiyerarşisi.</span><span class="sxs-lookup"><span data-stu-id="33d3b-289">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="33d3b-290">Birden çok `Deconstruct` aynı sayıda içeren yöntemlerin `out` parametreleri hızla belirsizliğe neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-290">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="33d3b-291">Çağıranlar kolayca istenen arayabilmesi için olmayabilir `Deconstruct` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="33d3b-291">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="33d3b-292">Bu örnekte var olduğundan belirsiz bir çağrı için en az bir fırsat `Deconstruct` yöntemi `Person` parametreleri, iki çıkışı vardır ve `Deconstruct` yöntemi `Student` üç.</span><span class="sxs-lookup"><span data-stu-id="33d3b-292">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="33d3b-293">Ayrıştırma deyiminin işleçleri eşitlik testinde katılamaz.</span><span class="sxs-lookup"><span data-stu-id="33d3b-293">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="33d3b-294">Aşağıdaki örnek, derleyici hatası CS0019 oluşturur:</span><span class="sxs-lookup"><span data-stu-id="33d3b-294">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="33d3b-295">`Deconstruct` Yöntemi dönüştürme `Person` nesne `p` bir demet için iki dizeyi, ancak içeren eşitliği testleri bağlamında geçerli değil.</span><span class="sxs-lookup"><span data-stu-id="33d3b-295">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="conclusion"></a><span data-ttu-id="33d3b-296">Sonuç</span><span class="sxs-lookup"><span data-stu-id="33d3b-296">Conclusion</span></span> 

<span data-ttu-id="33d3b-297">Adlandırılmış diziler yeni dil ve kitaplığa desteği sınıfları ve yapıları olduğu gibi birden çok öğe depolamak ancak davranışı tanımlamaz veri yapıları kullanan tasarımlar ile çalışmak çok daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="33d3b-297">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="33d3b-298">Bu, kolay ve Diziler bu türleri için kullanılacak kısa olur.</span><span class="sxs-lookup"><span data-stu-id="33d3b-298">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="33d3b-299">Statik tür denetimi, türleri daha ayrıntılı kullanarak yazmak zorunda kalmadan tüm avantajlarını elde `class` veya `struct` söz dizimi.</span><span class="sxs-lookup"><span data-stu-id="33d3b-299">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="33d3b-300">Bu halde bile, yardımcı program yöntemleri için en kullanışlı `private`, veya `internal`.</span><span class="sxs-lookup"><span data-stu-id="33d3b-300">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="33d3b-301">Kullanıcı tanımlı türler, ya da oluşturma `class` veya `struct` genel yöntemlerinizi birden çok öğe içeren bir değer döndürmediğinde türleri.</span><span class="sxs-lookup"><span data-stu-id="33d3b-301">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>

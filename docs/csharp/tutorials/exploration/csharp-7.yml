### YamlMime:Tutorial
title: <span data-ttu-id="92d6c-101">Keşfedin C# 7.0 - C# etkileşimli öğretici</span><span class="sxs-lookup"><span data-stu-id="92d6c-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: Keşfedin C# 7.0 - yeni özellikleri deneyin C# 7.0 etkileşimli olarak tarayıcınızı kullanarak
  description: Bu öğreticide keşfetmek için tarayıcınızı kullanacaksınız C# 7.0 etkileşimli olarak. İle birlikte kullanabileceğiniz yeni deyimleri hakkında bilgi edineceksiniz C# daha kısa süren ve okunabilir bir kod etkinleştirme 7.0.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: f488d6c05a8be1b2e6ad73d241533ac23b65b9ce
  ms.sourcegitcommit: 15ab532fd5e1f8073a4b678922d93b68b521bfa0
  ms.translationtype: MT
  ms.contentlocale: tr-TR
  ms.lasthandoff: 03/29/2019
  ms.locfileid: "58655539"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="92d6c-105">Bu öğretici sayesinde keşfedin C# yazmak için tarayıcınızı kullanarak 7.0 etkileşimli özellikleri C# ve derleyerek ve çalıştırarak kodunuzun sonuçlarını göreceksiniz.</span><span class="sxs-lookup"><span data-stu-id="92d6c-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="92d6c-106">Bir dizi Ders daha önce değiştiren içerdiği C# yeni, daha kısa kullanmak için uygulamaları C# 7.0 özellikleri.</span><span class="sxs-lookup"><span data-stu-id="92d6c-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="92d6c-107">Bu makalenin geri kalanında her bir özellik keşfetmek için bir bağlantı ile bu özelliklerin her biri bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="92d6c-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="92d6c-108">Atama konumda değişken bildirimleri</span><span class="sxs-lookup"><span data-stu-id="92d6c-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"92d6c-109\">Destekleyen varolan sözdizimi `out` parametreleri bu sürümde geliştirildi.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"92d6c-110\">Tıklayın *odak moduna girin* bu sayfanın alt kısmında düğmesine ve ardından etkileşimli pencerede aşağıdaki kodu deneyin:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"92d6c-111\">Artık bildirebilirsiniz `out` ayrı bildirim deyimindeki yazmak yerine bir yöntem çağrısının bağımsız değişken listesinde değişkenler.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"92d6c-112\">Yöntem çağrısına bildirimi taşıyabilirsiniz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"92d6c-113\">Etkileşimli pencerenin altına aşağıdaki kodu ekleyin:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"92d6c-114\">Değiştirebileceğiniz `int` bildirimine bir `var` bildirimi.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"92d6c-115\">Etkileşimli pencereye aşağıdaki kodu ekleyin:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"92d6c-116\">Yeni sözdizimi mevcut söz dizimi iki önemli avantaj sağlar:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"92d6c-117\">Kodu daha kolay.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"92d6c-118\">Out değişkeni da değil başka bir satırda yukarıdaki kullandığınız bildirdiğiniz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"92d6c-119\">Bir başlangıç değeri atamanız gerekmez.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"92d6c-120\">Bildirmek `out` bunu atanmadan önce değişken bir yöntem çağrısında kullanıldığı yanlışlıkla kullanamazsınız.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"92d6c-121\">Bildirilen değişkenin kapsamı kapsamdır kapsayan `if` deyimi.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"92d6c-122\">Bu, daha sonra değişkeni kullanmanıza olanak sağlar.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"92d6c-123\">Son değiştirme `if` aşağıdaki kod parçacığında gösterildiği gibi engelleyin.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="92d6c-124">Basit veri yapılarını diziler oluşturma</span><span class="sxs-lookup"><span data-stu-id="92d6c-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"92d6c-125\">Diziler veri üyelerini temsil etmek için birden fazla alan içeren basit veri yapılarıdır.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"92d6c-126\">Alanlar yok doğrulanır ve kendi yöntemlerini tanımlanamaz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"92d6c-127\">Diziler C# 7.0 önce kullanılabilir, ancak verimsiz ve dil desteği yok vardı.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"92d6c-128\">Bu dizi öğeleri yalnızca olarak başvurulan geliyordu `Item1`, `Item2` ve benzeri.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"92d6c-129\">C#7.0 yeni daha verimli tanımlama grubu türleri kullanarak bir kayıt düzeni alanlarını anlam adlarını sağlayan diziler için dil desteği sunar.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"92d6c-130\">Bir değer adlandırılmış her üyesine atayarak bir tanımlama grubu oluşturabilirsiniz:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"92d6c-131\">`namedLetters` Tanımlama grubu olarak adlandırılan alanları içeren `Alpha` ve `Beta`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"92d6c-132\">Bu adları, yalnızca derleme zamanında mevcut ve çalışma zamanında (örneğin, yansıma kullanarak tanımlama grubu incelenirken) korunmaz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"92d6c-133\">Bir tanımlama grubu atamasını alanların adlarını atamada sağ tarafta da belirtebilirsiniz:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"92d6c-134\">Her iki sol ve sağ tarafında atama alanların adlarını belirtebilirsiniz, ancak işlecin sağ tarafındaki adları yok sayılır.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"92d6c-135\">Diziler için dönüş türleri olarak faydalı `private` ve `internal` yöntemleri.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"92d6c-136\">Diziler, birden çok ayrı değer döndürmek bu yöntemleri için basit bir söz dizimi sağlar.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"92d6c-137\">Bir demet oluşturma, daha verimli ve daha üretken bir sınıf veya yapı oluşturmak bağlıdır.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"92d6c-138\">Bu, birden fazla değer taşıyan bir veri yapısını tanımlamak için daha basit ve basit bir söz dizimine sahiptir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"92d6c-139\">Aşağıdaki örnek yöntemi, bir tamsayı dizisinde bulunan minimum ve maksimum değerleri döndürür:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-139\">The example method below returns the minimum and maximum values found in a sequence of integers:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"92d6c-140\">Yöntemden döndürülen bir tanımlama grubu üyelerinin açmak istediğinizde zamanlar olabilir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-140\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"92d6c-141\">Dizideki değerlerin her biri için ayrı değişkenleri bildirerek bunu yapabilirsiniz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-141\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"92d6c-142\">Bu adlandırılır *ayrıştırma* tanımlama grubu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-142\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"92d6c-143\">Tarayıcınızda denemek için aşağıdaki kodu ekleyin:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-143\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"92d6c-144\">Tanımlama grubu ile çalışırken, genellikle tüm üyelerin bir tanımlama grubu sonucunun kullanmayın bulabilirsiniz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-144\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"92d6c-145\">Bu durum oluştuğunda, bir veya daha fazla döndürülen değerleri kullanarak atabilirsiniz `_` yerine bir değişken.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-145\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"92d6c-146\">Tarayıcınızda denemek için aşağıdaki kodu ekleyin:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-146\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"92d6c-147\">Diziler hakkında daha da ayrıntılı bilgi edinebilirsiniz [diziler makale](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-147\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"92d6c-148\">İçinde iptali hakkında daha fazla bilgi [atar makale](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-148\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="92d6c-149">Tür deseni kullanan ifadesi</span><span class="sxs-lookup"><span data-stu-id="92d6c-149">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="92d6c-150">`is` Desen ifadesi genişletir bilinen [ `is` işleci](../../language-reference/keywords/is.md#pattern-matching-with-is) bir nesne türünü ötesinde sorgulamak için.</span><span class="sxs-lookup"><span data-stu-id="92d6c-150">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="92d6c-151">Tarayıcı pencerenizde aşağıdaki kodu deneyin:</span><span class="sxs-lookup"><span data-stu-id="92d6c-151">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="92d6c-152">Bunun yerine, değişken bildirimi bir dizeye değiştirin:</span><span class="sxs-lookup"><span data-stu-id="92d6c-152">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="92d6c-153">Şimdi, `is` ifade false, böylece `else` dal yürütülür.</span><span class="sxs-lookup"><span data-stu-id="92d6c-153">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="92d6c-154">Değiştirmeye `count` için `number` başka dal:</span><span class="sxs-lookup"><span data-stu-id="92d6c-154">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="92d6c-155">Yukarıdaki çünkü derlenemeyecektir `number` içinde atanmamış `else` dal.</span><span class="sxs-lookup"><span data-stu-id="92d6c-155">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="92d6c-156">İçinde yalnızca atanan `true` dalı `if` deyimi.</span><span class="sxs-lookup"><span data-stu-id="92d6c-156">It's only assigned in the `true` branch of the `if` statement.</span></span>


    > [!NOTE]

    > <span data-ttu-id="92d6c-157">Var olan bir [sorunu](https://github.com/dotnet/try/issues/175) burada alabilirsiniz yanlış çıkış önceki örnekte.</span><span class="sxs-lookup"><span data-stu-id="92d6c-157">There is an [issue](https://github.com/dotnet/try/issues/175) where you may get incorrect output in the preceding example.</span></span>


    <span data-ttu-id="92d6c-158">`is` İfade türü deseni, türlerine karşı test etmek için az sayıda olduğunda yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="92d6c-158">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="92d6c-159">Genellikle, birden çok test gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="92d6c-159">Often, you may need to test multiple types.</span></span> <span data-ttu-id="92d6c-160">Desen eşleştirme gerektiren `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="92d6c-160">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="92d6c-161">Switch deyimi içinde desen</span><span class="sxs-lookup"><span data-stu-id="92d6c-161">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="92d6c-162">*Eşleşen ifade* sahip temel tanıdık bir söz dizimi `switch` ifadesi C# dilinin zaten parçası.</span><span class="sxs-lookup"><span data-stu-id="92d6c-162">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="92d6c-163">Göre küçük bir örnek ile başlayalım `is` önceki sayfada incelediniz ifadesi söz dizimi:</span><span class="sxs-lookup"><span data-stu-id="92d6c-163">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="92d6c-164">Yukarıdaki kod denetleyen bir `int` veya `null`.</span><span class="sxs-lookup"><span data-stu-id="92d6c-164">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="92d6c-165">Her bir türün varsayılan durumda ulaşıldı.</span><span class="sxs-lookup"><span data-stu-id="92d6c-165">Every other type reached the default case.</span></span> <span data-ttu-id="92d6c-166">Davranış doğrulamak için aşağıdaki iki satırı ekleyin:</span><span class="sxs-lookup"><span data-stu-id="92d6c-166">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="92d6c-167">`switch` İfade karşılık gelen türü için boş değer atanabilir bir tür dönüştürme.</span><span class="sxs-lookup"><span data-stu-id="92d6c-167">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="92d6c-168">Doğrulamak için aşağıdakileri ekleyin:</span><span class="sxs-lookup"><span data-stu-id="92d6c-168">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="92d6c-169">Switch deyimleri için diğer tür deseni ifadeleri herhangi bir sayıda ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="92d6c-169">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="92d6c-170">Önce ekleme `null` çalışması:</span><span class="sxs-lookup"><span data-stu-id="92d6c-170">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="92d6c-171">Bu iş şu testler ekleyerek emin olun:</span><span class="sxs-lookup"><span data-stu-id="92d6c-171">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="92d6c-172">Eşleşme ifadeleri sabitleri de destekler.</span><span class="sxs-lookup"><span data-stu-id="92d6c-172">The match expressions also support constants.</span></span> <span data-ttu-id="92d6c-173">Bu basit durumlar hesaba katacak şekilde tarafından zamandan tasarruf edebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="92d6c-173">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="92d6c-174">Önceki durum eklemelisiniz *önce* `case int:` ifade.</span><span class="sxs-lookup"><span data-stu-id="92d6c-174">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="92d6c-175">Bu durumda sonra eklerseniz, derleyici, zaten önceki bir case tarafından işlendiğini sizi uyarır.</span><span class="sxs-lookup"><span data-stu-id="92d6c-175">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="92d6c-176">Ekleyebileceğiniz bir `when` herhangi bir desen yan tümcesini case böylece bir türü veya bir sabit değer dışında diğer koşulları test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="92d6c-176">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="92d6c-177">Genel yukarıda aşağıdaki durum ekleyerek deneyin `string` çalışması:</span><span class="sxs-lookup"><span data-stu-id="92d6c-177">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="92d6c-178">Aşağıdaki kod gibi bir şeyle test edin:</span><span class="sxs-lookup"><span data-stu-id="92d6c-178">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="92d6c-179">Desen eşleştirme ifadelerinde yeni sözdizimi, bir nesnenin türü veya diğer özelliklere göre kısa ve anlaşılır bir söz dizimi kullanılarak dağıtım algoritmalar oluşturmak kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="92d6c-179">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="92d6c-180">Desen eşleştirme ifadeleri, bu yapıları tarafından devralma ilişkisiz veri türlerinde etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="92d6c-180">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="92d6c-181">Adanmış makaledeki desen hakkında daha fazla bilgi [içinde desen C# ](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="92d6c-181">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="92d6c-182">Ref yerel değerleri ve dönüşleri kullanarak bellek depolama en iyi duruma getirme</span><span class="sxs-lookup"><span data-stu-id="92d6c-182">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"92d6c-183\">Bu özelliği kullanın ve başka bir yerde tanımlanan değişkenleri başvuruları dönüş algoritmalar sağlar.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-183\">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id=\"92d6c-184\">Büyük matrisler ve belirli özelliklere sahip tek bir konum bulma ile bir örnek verilebilir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-184\">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id=\"92d6c-185\">Bir yöntemi iki indeks matriste tek bir konum döndürür:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-185\">One method would return the two indices a single location in the matrix:</span></span>\n\n```csharp\npublic class Program\n{\n    private static (int i, int j) Find(int[,] matrix, Func<int, bool> predicate)\n    {\n        for (int i = 0; i < matrix.GetLength(0); i++)\n            for (int j = 0; j < matrix.GetLength(1); j++)\n                if (predicate(matrix[i, j]))\n                    return (i, j);\n        return (-1, -1); // Not found\n    }\n\n    public static void Main()\n    {\n        int[,] sourceMatrix = new int[10, 10];\n        for (int x = 0; x < 10; x++)\n            for (int y = 0; y < 10; y++)\n                sourceMatrix[x, y] = x * 10 + y;\n\n        var indices = Find(sourceMatrix, (val) => val == 42);\n        Console.WriteLine(indices);\n        sourceMatrix[indices.i, indices.j] = 24;        \n    }\n\n}\n```\n\n\n<span data-ttu-id=\"92d6c-186\">Bu `Find` yöntemi Matristeki öğenin dizinleri döndürür.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-186\">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id=\"92d6c-187\">Bu başvuru matrisi ve bir öğeyi değiştirmek için bu dizinleri kullanan kod yazmak için çağıranlar yol açar.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-187\">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id=\"92d6c-188\">Döndüren bir yöntem yerine yazmak istediğiniz bir *başvuru* değiştirmek istediğiniz matris öğesine.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-188\">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>\n\n<span data-ttu-id=\"92d6c-189\">Şimdi bir dizi değişikliği ref yerel özelliği göstermek ve dahili depolama başvuru döndüren bir yöntem oluşturma işlemini göstermek için yol.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-189\">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id=\"92d6c-190\">Bu doğrultuda, bunu kötüye yanlışlıkla koruma kuralları ref dönüş ve ref yerel özellik öğreneceksiniz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-190\">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>\n\n<span data-ttu-id=\"92d6c-191\">Başlangıç değiştirerek `Find` BT'nin döndürecek şekilde yöntem bildiriminde bir `ref int` yerine bir tanımlama grubu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-191\">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>\n\n```csharp\nprivate static ref int Find(int[,] matrix, Func<int, bool> predicate)\n```\n\n<span data-ttu-id=\"92d6c-192\">Doğru dizinleri öğe döndürmek için dönüş deyimi değiştirin:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-192\">Modify the return statement to return the item at the correct indices:</span></span>\n\n```csharp\nreturn matrix[i,j];\n```\n\n<span data-ttu-id=\"92d6c-193\">Bunun yerine bir özel durum için son dönüş değiştirin:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-193\">Change the final return to throw an exception instead:</span></span>\n\n```csharp\nthrow new InvalidOperationException(\"Not found\");\n```\n\n<span data-ttu-id=\"92d6c-194\">Bu derlenemeyecektir unutmayın.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-194\">Note that this won't compile.</span></span> <span data-ttu-id=\"92d6c-195\">Yöntem bildiriminde gösteren bir `ref` dönüş ancak dönüş deyimi bir dönüş değeri belirtir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-195\">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id=\"92d6c-196\">Eklemelisiniz `ref` her iade bildirimde anahtar sözcüğü.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-196\">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id=\"92d6c-197\">Başvuru ile dönüş gösterir ve daha sonra kodu okuyan yardımcı geliştiriciler yöntemi başvuru ile döndürülen unutmayın:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-197\">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>\n\n```csharp\nreturn ref matrix[i,j];\n```\n\n<span data-ttu-id=\"92d6c-198\">Yöntem matriste tamsayı değerine bir başvuru döndürür, burada çağrılır değiştirmeniz gerekir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-198\">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id=\"92d6c-199\">`var` Bildirimi anlamına `valItem` artık bir `int` yerine bir tanımlama grubu.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-199\">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id=\"92d6c-200\">Arama kodda değişiklik `Main` aşağıdaki yöntemi:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-200\">Change the calling code in the `Main` method to the following:</span></span>\n\n```csharp\nvar valItem = Find(matrix, (val) => val == 42);\nConsole.WriteLine(valItem);\nvalItem = 24;\nConsole.WriteLine(matrix[4, 2]);\n```\n\n<span data-ttu-id=\"92d6c-201\">İkinci `WriteLine` yukarıdaki örnekte deyimi yazdırır değerini `42`değil `24`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-201\">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id=\"92d6c-202\">Değişken `valItem` olduğu bir `int`değil bir `ref int`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-202\">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id=\"92d6c-203\">`var` Anahtar sözcüğü türü belirtmek derleyiciyi etkinleştirir, ancak değil örtük olarak ekleyecek `ref` değiştiricisi.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-203\">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id=\"92d6c-204\">Bunun yerine, değeri adlandırılan tarafından `ref return` olduğu *kopyalanan* atamanın sol tarafı değişkenine.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-204\">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id=\"92d6c-205\">Değişken değil bir `ref` yerel.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-205\">The variable is not a `ref` local.</span></span>\n\n<span data-ttu-id=\"92d6c-206\">Eklemenize gerek döndürülen başvuru değiştirmek için `ref` çağırmadan önce yerel değişken bildirimi için değiştiricisinin `Find` dönüş değeri bir başvuru değişkeni başvuru yapmak için.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-206\">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id=\"92d6c-207\">Değiştirme `Main` aşağıdaki ile eşleşecek şekilde tarayıcınızda yöntemi:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-207\">Modify the `Main` method in your browser to match the following:</span></span>\n\n```csharp\npublic static void Main()\n{\n    int[,] sourceMatrix = new int[10, 10];\n    for (int x = 0; x < 10; x++)\n        for (int y = 0; y < 10; y++)\n            sourceMatrix[x, y] = x * 10 + y;\n\n    ref var item = ref Find(sourceMatrix, (val) => val == 42);\n    Console.WriteLine(item);\n    item = 24;\n    Console.WriteLine(sourceMatrix[4, 2]);\n}\n```\n\n<span data-ttu-id=\"92d6c-208\">Şimdi, ikinci `WriteLine` yukarıdaki örnekte deyimi yazdırır değerini `24`, Matristeki depolama değiştirilmiş olduğunu gösteren.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-208\">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id=\"92d6c-209\">Yerel değişken ile bildirilen `ref` değiştiricisi ve alacağınız bir `ref` döndürür.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-209\">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id=\"92d6c-210\">Başlatması gerekir bir `ref` değişkeni bildirildiğinde; bildirim ve başlatma bölünemiyor.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-210\">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>\n\n<span data-ttu-id=\"92d6c-211\">C# dili kötüye kullanmasının korumak üç kuralları sahip `ref` yerel değerleri ve Dönüşleri:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-211\">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>\n\n* <span data-ttu-id=\"92d6c-212\">Standart bir yöntem dönüş değerine atanamaz bir `ref` yerel değişken.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-212\">You cannot assign a standard method return value to a `ref` local variable.</span></span>\n* <span data-ttu-id=\"92d6c-213\">Döndüremezsiniz bir `ref` ömürlerinin yönteminin yürütülmesi genişletmiyoruz bir değişkene.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-213\">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>\n* <span data-ttu-id=\"92d6c-214\">`ref` yerel değerleri ve dönüşleri zaman uyumsuz yöntemlerle kullanılamaz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-214\">`ref` locals and returns can't be used with async methods.</span></span>\n\n<span data-ttu-id=\"92d6c-215\">Ref yerel ayarlar ve ref değerleri kopyalama veya birden çok kez başvurusunu kaldırma işlemlerini gerçekleştirme önleyerek daha verimlidir etkinleştir algoritmaları döndürür.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-215\">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>\n\n<span data-ttu-id=\"92d6c-216\">Daha fazla bilgi için [ref anahtar sözcüğü](../../language-reference/keywords/ref.md) makalesi.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-216\">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>\n"
- title: <span data-ttu-id="92d6c-217">Yerel işlevleri ile kod erişimi en aza indirin</span><span class="sxs-lookup"><span data-stu-id="92d6c-217">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"92d6c-218\">Şimdi diğer işlevleri içe yerel işlevler bildirebilirsiniz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-218\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"92d6c-219\">Bu, bu işlevler görünürlüğünü en aza indirmek sağlar.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-219\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"92d6c-220\">Yerel işlevler için üç belirgin kullanım örnekleri vardır:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-220\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"92d6c-221\">Özyinelemeli işlevler.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-221\">Recursive functions.</span></span>\n- <span data-ttu-id=\"92d6c-222\">Yineleyici yöntemleri.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-222\">Iterator methods.</span></span>\n- <span data-ttu-id=\"92d6c-223\">Zaman uyumsuz yöntemler.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-223\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"92d6c-224\">Özyinelemeli yöntemleriyle başlayalım.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-224\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"92d6c-225\">Tarayıcıda hesaplamak için aşağıdaki kodu deneyin `6!` (faktöriyelini):</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-225\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"92d6c-226\">Yerel İşlevler, yinelemeli algoritmalar uygulamak için harika bir yoludur.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-226\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"92d6c-227\">Diğer sık kullanımlar genel yineleyici yöntemleri ve genel zaman uyumsuz yöntemler içindir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-227\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"92d6c-228\">Her iki yöntem tür hataları programcılar beklenebilir daha sonra rapor kod oluşturur.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-228\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"92d6c-229\">Yineleyici metotları olması durumunda, yalnızca özel durumların gözlemlenen döndürülen dizi numaralandırır kod çağırırken.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-229\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"92d6c-230\">Söz konusu olduğunda zaman uyumsuz yöntemler, özel durumların yalnızca zaman uyulması gereken döndürülen `Task` beklenir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-230\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"92d6c-231\">Yineleyici yöntemleri tarayıcıda keşfedin, şimdi de bu araştırma kullanmak daha kolaydır.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-231\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"92d6c-232\">Tarayıcınızda bir yineleyici yöntemini çağıran aşağıdaki kodu deneyin:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-232\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"92d6c-233\">Kodu çalıştırın.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-233\">Run the code.</span></span> <span data-ttu-id=\"92d6c-234\">Kod ikinci sonuç kümesi yineleme başladığında, özel durumun dikkat edin.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-234\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"92d6c-235\">İlk sonuç kümesinde yinelenen kodu zaten çalıştırıldı.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-235\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"92d6c-236\">Bu örnek, her ikisi de olan küçük ve tüm veri yapılarını dso zararsız ve düzeltmek kolay bir değişiklik yapmaz.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-236\">This sample is both small and doesn't change any data structures, dso it's harmless and easy to fix.</span></span> <span data-ttu-id=\"92d6c-237\">Ancak, büyük bir programın, burada iki yineleyici nesnesi oluşturulabilir farklı alt yöntemleri kök nedeni bulmak zor olabilir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-237\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"92d6c-238\">İlk yineleyici yöntem veri durum değiştiyse, hatta veri bozulmasına neden olabilir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-238\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"92d6c-239\">Herhangi bir çalışma yapılmadan önce hemen, özel durum oluştu tercih edebilir.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-239\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"92d6c-240\">Böylece tüm bağımsız değişkenler ve numaralandırma gerçekleştiren bir yerel işlev genel yöntem doğrulama kodu yeniden düzenleyebilirsiniz:</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-240\">You can refactor the code so that the public method validates all arguments, and a local function that performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"92d6c-241\">Önceki sürüm Temizle yerel yöntemi başvurulan yalnızca dış yöntem bağlamında kolaylaştırır.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-241\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"92d6c-242\">Yerel işlevleri için kurallar ayrıca bir geliştirici yanlışlıkla sınıfında başka bir konumdan yerel işlev çağrısı veya bağımsız değişken doğrulama atlama emin emin olun.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-242\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"92d6c-243\">Aynı yöntem ile işe `async` zaman uyumsuz işler başlamadan önce bağımsız değişken doğrulama doğan özel durumlar emin olmak için yöntemleri.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-243\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"92d6c-244\">Yerel işlevleri tarafından desteklenen tasarımları bazılarını da kullanarak sağlayabilirsiniz *lambda ifadeleri*.</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-244\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"92d6c-245\">Bu ilgi olabilir [farklar hakkında daha fazla](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"92d6c-245\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="92d6c-246">Başlıca yeni özelliklerini inceleme tamamladınız C# 7.</span><span class="sxs-lookup"><span data-stu-id="92d6c-246">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="92d6c-247">Şimdi kendiniz uygulamalarınızda deneyebilir.</span><span class="sxs-lookup"><span data-stu-id="92d6c-247">Now try them yourself in your applications.</span></span> <span data-ttu-id="92d6c-248">Tam listesinde görebileceğiniz [yenilikler C# 7](../../whats-new/csharp-7.md) makalesi.</span><span class="sxs-lookup"><span data-stu-id="92d6c-248">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>

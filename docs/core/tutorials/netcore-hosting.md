---
title: Özel bir .NET Core çalışma zamanı ana bilgisayarı yazma
description: .NET Core çalışma zamanı nasıl çalıştığını denetleme gerektiren gelişmiş senaryoları desteklemek için yerel koddan .NET Core çalışma zamanı ana öğrenin.
author: mjrousos
ms.date: 12/21/2018
ms.custom: seodec18
ms.openlocfilehash: d3bdaacd4be776e0e9fff01698cca360ea4c9c6d
ms.sourcegitcommit: bab17fd81bab7886449217356084bf4881d6e7c8
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/26/2019
ms.locfileid: "67402018"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="2576a-103">Yerel koddan .NET çalışma zamanı denetlemek için özel bir .NET Core konak yazma</span><span class="sxs-lookup"><span data-stu-id="2576a-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="2576a-104">Tüm yönetilen kod gibi .NET Core uygulamaları bir ana bilgisayar tarafından yürütülür.</span><span class="sxs-lookup"><span data-stu-id="2576a-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="2576a-105">Konak, çalışma zamanı (bileşenler JIT ve çöp toplayıcı gibi) başlangıç ve yönetilen giriş noktaları çağırma sorumludur.</span><span class="sxs-lookup"><span data-stu-id="2576a-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector) and invoking managed entry points.</span></span>

<span data-ttu-id="2576a-106">.NET Core çalışma zamanı barındırma Gelişmiş bir senaryodur ve çoğu durumda, .NET Core geliştiricilerinin .NET Core derleme nedeni işlemleri barındırma hakkında endişelenmeniz gerekmez, .NET Core uygulamaları çalıştırmak için bir varsayılan konak sağlar.</span><span class="sxs-lookup"><span data-stu-id="2576a-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="2576a-107">Bazı özel durumlarda, yine de bu açıkça barındırmak için .NET Core çalışma zamanı yerel işlem veya çalışma zamanı nasıl çalıştığını daha fazla denetim kazanmak için yönetilen kod yürütmesini bir yolu olarak ya da yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="2576a-108">Bu makalede, yerel koddan .NET Core çalışma zamanı başlatma ve yönetilen kodu çalıştırmak için gerekli adımları genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="2576a-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="2576a-109">Önkoşullar</span><span class="sxs-lookup"><span data-stu-id="2576a-109">Prerequisites</span></span>

<span data-ttu-id="2576a-110">Yerel uygulamalar konak olmadığından, bu öğreticide .NET Core barındırmak için bir C++ uygulaması oluşturmak ele alınacaktır.</span><span class="sxs-lookup"><span data-stu-id="2576a-110">Because hosts are native applications, this tutorial will cover constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="2576a-111">Bir C++ geliştirme ortamı gerekir (tarafından sağlanan gibi [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span><span class="sxs-lookup"><span data-stu-id="2576a-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="2576a-112">Bu nedenle yükleme yapılmalıdır Ayrıca, ana bilgisayarı sınamak için basit bir .NET Core uygulaması isteyeceksiniz [.NET Core SDK'sı](https://www.microsoft.com/net/core) ve [küçük .NET Core uygulaması derleme](../../core/tutorials/with-visual-studio.md) (örneğin, bir 'Merhaba Dünya' uygulama).</span><span class="sxs-lookup"><span data-stu-id="2576a-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://www.microsoft.com/net/core) and [build a small .NET Core test app](../../core/tutorials/with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="2576a-113">Yeni .NET Core konsol proje şablonu tarafından oluşturulan 'Hello World' uygulama yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="2576a-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

## <a name="hosting-apis"></a><span data-ttu-id="2576a-114">API'leri barındırma</span><span class="sxs-lookup"><span data-stu-id="2576a-114">Hosting APIs</span></span>
<span data-ttu-id="2576a-115">.NET Core konağı için kullanılabilecek üç farklı API'ler vardır.</span><span class="sxs-lookup"><span data-stu-id="2576a-115">There are three different APIs that can be used to host .NET Core.</span></span> <span data-ttu-id="2576a-116">Bu belge (ve ilişkili [örnekleri](https://github.com/dotnet/samples/tree/master/core/hosting)) tüm seçeneklerini kapsar.</span><span class="sxs-lookup"><span data-stu-id="2576a-116">This document (and its associated [samples](https://github.com/dotnet/samples/tree/master/core/hosting)) cover all options.</span></span>

* <span data-ttu-id="2576a-117">.NET Core 3.0 ve üstü'de .NET Core çalışma zamanı barındırma tercih edilen yöntemi olan `nethost` ve `hostfxr` kitaplıkları API'leri.</span><span class="sxs-lookup"><span data-stu-id="2576a-117">The preferred method of hosting the .NET Core runtime in .NET Core 3.0 and above is with the `nethost` and `hostfxr` libraries' APIs.</span></span> <span data-ttu-id="2576a-118">Bu giriş noktaları, bulma ve çalışma zamanı başlatma için ayarlama karmaşıklığı işlemek ve hem yönetilen bir uygulama başlatma ve statik bir yönetilen yöntemi sağlar.</span><span class="sxs-lookup"><span data-stu-id="2576a-118">These entry points handle the complexity of finding and setting up the runtime for initialization and allow both launching a managed application and calling into a static managed method.</span></span>
* <span data-ttu-id="2576a-119">.NET Core 3.0 önce .NET Core çalışma zamanı barındırma tercih edilen yöntemi olan [CoreClrHost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h) API.</span><span class="sxs-lookup"><span data-stu-id="2576a-119">The preferred method of hosting the .NET Core runtime prior to .NET Core 3.0 is with the [CoreClrHost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h) API.</span></span> <span data-ttu-id="2576a-120">Bu API işlevleri kolayca başlatmak için kullanıma sunar ve çalışma zamanı durduruluyor ve bunları çağırırken yönetilen kod (veya yönetilen bir exe açarak yönetilen statik yöntemleri çağırarak).</span><span class="sxs-lookup"><span data-stu-id="2576a-120">This API exposes functions for easily starting and stopping the runtime and invoking managed code (either by launching a managed exe or by calling static managed methods).</span></span>
* <span data-ttu-id="2576a-121">.NET core de barındırılabilir ile `ICLRRuntimeHost4` arabiriminde [mscoree.h](https://github.com/dotnet/coreclr/blob/master/src/pal/prebuilt/inc/mscoree.h).</span><span class="sxs-lookup"><span data-stu-id="2576a-121">.NET Core can also be hosted with the `ICLRRuntimeHost4` interface in [mscoree.h](https://github.com/dotnet/coreclr/blob/master/src/pal/prebuilt/inc/mscoree.h).</span></span> <span data-ttu-id="2576a-122">Eski konakları kullanmadan görülen şekilde bu API CoreClrHost.h, daha uzun etrafında olmuştur.</span><span class="sxs-lookup"><span data-stu-id="2576a-122">This API has been around longer than CoreClrHost.h, so you may have seen older hosts using it.</span></span> <span data-ttu-id="2576a-123">Hala çalışır ve CoreClrHost daha barındırma işlemi üzerinde biraz daha fazla denetim sağlar.</span><span class="sxs-lookup"><span data-stu-id="2576a-123">It still works and allows a bit more control over the hosting process than CoreClrHost.</span></span> <span data-ttu-id="2576a-124">Çoğu senaryo için yine de CoreClrHost.h artık, daha basit API'ler nedeniyle tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-124">For most scenarios, though, CoreClrHost.h is preferred now because of its simpler APIs.</span></span>

## <a name="sample-hosts"></a><span data-ttu-id="2576a-125">Örnek konakları</span><span class="sxs-lookup"><span data-stu-id="2576a-125">Sample Hosts</span></span>
<span data-ttu-id="2576a-126">[Örnek konakları](https://github.com/dotnet/samples/tree/master/core/hosting) öğreticilerde özetlenen adımları gösteren kullanılabilir dotnet/samples GitHub deposunda.</span><span class="sxs-lookup"><span data-stu-id="2576a-126">[Sample hosts](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in the tutorials below are available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="2576a-127">Örneklerin açıklamaları açıkça bu öğreticilerden numaralandırılmış adımları örnek burada çalıştırıldığını ile ilişkilendirin.</span><span class="sxs-lookup"><span data-stu-id="2576a-127">Comments in the samples clearly associate the numbered steps from these tutorials with where they're performed in the sample.</span></span> <span data-ttu-id="2576a-128">Yükleme yönergeleri için bkz: [örnekler ve öğreticiler](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span><span class="sxs-lookup"><span data-stu-id="2576a-128">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span></span>

<span data-ttu-id="2576a-129">Bu nedenle bunlar üzerinde hata denetimi açık ve verimlilik üzerinde okunabilirliği vurgulamak için tasarlanmış, öğrenme amacıyla kullanılacak örnek konakları yöneliktir aklınızda bulundurun.</span><span class="sxs-lookup"><span data-stu-id="2576a-129">Keep in mind that the sample hosts are meant to be used for learning purposes, so they are light on error checking and are designed to emphasize readability over efficiency.</span></span>

## <a name="create-a-host-using-nethosth-and-hostfxrh"></a><span data-ttu-id="2576a-130">NetHost.h ve HostFxr.h kullanarak bir konağı oluşturma</span><span class="sxs-lookup"><span data-stu-id="2576a-130">Create a host using NetHost.h and HostFxr.h</span></span>

<span data-ttu-id="2576a-131">Aşağıdaki adımları nasıl kullanılacağını ayrıntı `nethost` ve `hostfxr` kitaplıkları, .NET Core çalışma zamanı yerel bir uygulama ve yönetilen bir statik yöntem çağrısına başlatmak için.</span><span class="sxs-lookup"><span data-stu-id="2576a-131">The following steps detail how to use the `nethost` and `hostfxr` libraries to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="2576a-132">[Örnek](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) kullanan `nethost` üstbilgi ve yükleneceği kopyalarını ve .NET SDK'sı ile Kitaplığı [ `coreclr_delegates.h` ](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/coreclr_delegates.h) ve [ `hostfxr.h` ](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) dosyalarını [dotnet/çekirdek-setup](https://github.com/dotnet/core-setup) depo.</span><span class="sxs-lookup"><span data-stu-id="2576a-132">The [sample](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr) uses the `nethost` header and library installed with the .NET SDK and copies of the [`coreclr_delegates.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/coreclr_delegates.h) and [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) files from the [dotnet/core-setup](https://github.com/dotnet/core-setup) repository.</span></span>

### <a name="step-1---load-hostfxr-and-get-exported-hosting-functions"></a><span data-ttu-id="2576a-133">Adım 1 - yük HostFxr ve barındırma işlevleri dışarı</span><span class="sxs-lookup"><span data-stu-id="2576a-133">Step 1 - Load HostFxr and get exported hosting functions</span></span>

<span data-ttu-id="2576a-134">`nethost` Kitaplığı sağlar `get_hostfxr_path` bulma işlevi `hostfxr` kitaplığı.</span><span class="sxs-lookup"><span data-stu-id="2576a-134">The `nethost` library provides the `get_hostfxr_path` function for locating the `hostfxr` library.</span></span> <span data-ttu-id="2576a-135">`hostfxr` Kitaplığı için .NET Core çalışma zamanı barındırma işlevleri kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="2576a-135">The `hostfxr` library exposes functions for hosting the .NET Core runtime.</span></span> <span data-ttu-id="2576a-136">İşlevlerin tam listesi bulunabilir [ `hostfxr.h` ](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) ve [yerel barındırma tasarım belge](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md).</span><span class="sxs-lookup"><span data-stu-id="2576a-136">The full list of functions can be found in [`hostfxr.h`](https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h) and the [native hosting design document](https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md).</span></span> <span data-ttu-id="2576a-137">Örnek ve Bu öğreticide aşağıdakileri kullanın:</span><span class="sxs-lookup"><span data-stu-id="2576a-137">The sample and this tutorial use the following:</span></span>
* <span data-ttu-id="2576a-138">`hostfxr_initialize_for_runtime_config`: Bir ana bilgisayar bağlamını başlatır ve belirtilen çalışma zamanı Yapılandırması'nı kullanarak .NET Core çalışma zamanı başlatma için hazırlar.</span><span class="sxs-lookup"><span data-stu-id="2576a-138">`hostfxr_initialize_for_runtime_config`: Initializes a host context and prepares for initialization of the .NET Core runtime using the specified runtime configuration.</span></span>
* <span data-ttu-id="2576a-139">`hostfxr_get_runtime_delegate`: Çalışma zamanı işlevselliği için bir temsilciyi alır.</span><span class="sxs-lookup"><span data-stu-id="2576a-139">`hostfxr_get_runtime_delegate`: Gets a delegate for runtime functionality.</span></span>
* <span data-ttu-id="2576a-140">`hostfxr_close`: Bir ana bilgisayar bağlamı kapatır.</span><span class="sxs-lookup"><span data-stu-id="2576a-140">`hostfxr_close`: Closes a host context.</span></span>

<span data-ttu-id="2576a-141">`hostfxr` Kitaplığı kullanarak bulundu `get_hostfxr_path`.</span><span class="sxs-lookup"><span data-stu-id="2576a-141">The `hostfxr` library is found using `get_hostfxr_path`.</span></span> <span data-ttu-id="2576a-142">Ardından yüklenir ve aktarımlarından alınır.</span><span class="sxs-lookup"><span data-stu-id="2576a-142">It is then loaded and its exports are retrieved.</span></span>

[!code-cpp[HostFxrHost#LoadHostFxr](~/samples/core/hosting/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadHostFxr)]

### <a name="step-2---initialize-and-start-the-net-core-runtime"></a><span data-ttu-id="2576a-143">Adım 2 - başlatma ve .NET Core çalışma zamanı başlatma</span><span class="sxs-lookup"><span data-stu-id="2576a-143">Step 2 - Initialize and start the .NET Core runtime</span></span>

<span data-ttu-id="2576a-144">`hostfxr_initialize_for_runtime_config` Ve `hostfxr_get_runtime_delegate` işlevleri başlatmak ve çalışma zamanı yapılandırması yüklenecek bir yönetilen bileşen kullanarak .NET Core çalışma zamanı'nı başlatın.</span><span class="sxs-lookup"><span data-stu-id="2576a-144">The `hostfxr_initialize_for_runtime_config` and `hostfxr_get_runtime_delegate` functions initialize and start the .NET Core runtime using the runtime configuration for the managed component that will be loaded.</span></span> <span data-ttu-id="2576a-145">`hostfxr_get_runtime_delegate` İşlevi, bir yönetilen derlemenin yüklenmesi ve bir işlev işaretçisi için bir statik yöntem söz konusu derlemede alma izin veren bir çalışma zamanı temsilci almak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="2576a-145">The `hostfxr_get_runtime_delegate` function is used to get a runtime delegate that allows loading a managed assembly and getting a function pointer to a static method in that assembly.</span></span>

[!code-cpp[HostFxrHost#Initialize](~/samples/core/hosting/HostWithHostFxr/src/NativeHost/nativehost.cpp#Initialize)]

### <a name="step-3---load-managed-assembly-and-get-function-pointer-to-a-managed-method"></a><span data-ttu-id="2576a-146">3\. adım: yönetilen bütünleştirilmiş kod ve get işlev işaretçisi için bir yönetilen yöntemin yükleme</span><span class="sxs-lookup"><span data-stu-id="2576a-146">Step 3 - Load managed assembly and get function pointer to a managed method</span></span>

<span data-ttu-id="2576a-147">Yönetilen bütünleştirilmiş kod yükleme ve yönetilen bir yönteme bir işlev işaretçisine almak için çalışma zamanı temsilci çağrılır.</span><span class="sxs-lookup"><span data-stu-id="2576a-147">The runtime delegate is called to load the managed assembly and get a function pointer to a managed method.</span></span> <span data-ttu-id="2576a-148">Temsilci, giriş olarak derleme yolu, tür adı ve yöntem adı gerektirir ve yönetilen yöntemini çağırmak için kullanılan bir işlev işaretçisi döndürür.</span><span class="sxs-lookup"><span data-stu-id="2576a-148">The delegate requires the assembly path, type name, and method name as inputs and returns a function pointer that can be used to invoke the managed method.</span></span>

[!code-cpp[HostFxrHost#LoadAndGet](~/samples/core/hosting/HostWithHostFxr/src/NativeHost/nativehost.cpp#LoadAndGet)]

<span data-ttu-id="2576a-149">Geçirerek `nullptr` çalışma zamanı temsilci çağrılırken temsilci türü adı olarak örnek varsayılan imza için Yönetilen yöntemi kullanır:</span><span class="sxs-lookup"><span data-stu-id="2576a-149">By passing `nullptr` as the delegate type name when calling the runtime delegate, the sample uses a default signature for the managed method:</span></span>

```csharp
public delegate int ComponentEntryPoint(IntPtr args, int sizeBytes);
```

<span data-ttu-id="2576a-150">Farklı bir imza, çalışma zamanı temsilci çağırırken temsilci türü adı belirterek kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-150">A different signature can be used by specifying the delegate type name when calling the runtime delegate.</span></span>

### <a name="step-4---run-managed-code"></a><span data-ttu-id="2576a-151">4\. adım - yönetilen kodu çalıştırma!</span><span class="sxs-lookup"><span data-stu-id="2576a-151">Step 4 - Run managed code!</span></span>

<span data-ttu-id="2576a-152">Yerel ana bilgisayar artık yönetilen yöntemini çağırın ve istenen parametreleri geçirin.</span><span class="sxs-lookup"><span data-stu-id="2576a-152">The native host can now call the managed method and pass it the desired parameters.</span></span>

[!code-cpp[HostFxrHost#CallManaged](~/samples/core/hosting/HostWithHostFxr/src/NativeHost/nativehost.cpp#CallManaged)]

## <a name="create-a-host-using-coreclrhosth"></a><span data-ttu-id="2576a-153">CoreClrHost.h kullanarak bir konağı oluşturma</span><span class="sxs-lookup"><span data-stu-id="2576a-153">Create a host using CoreClrHost.h</span></span>

<span data-ttu-id="2576a-154">Aşağıdaki adımları CoreClrHost.h API .NET Core çalışma zamanı yerel bir uygulama ve yönetilen bir statik yöntem çağrısına başlatmak için nasıl kullanılacağını açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="2576a-154">The following steps detail how to use the CoreClrHost.h API to start the .NET Core runtime in a native application and call into a managed static method.</span></span> <span data-ttu-id="2576a-155">Bu belgede yer alan kod parçacıkları bazı Windows özel API'leri kullanın ancak [tam örnek konak](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) hem Windows hem de Linux kod yollarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="2576a-155">The code snippets in this document use some Windows-specific APIs, but the [full sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithCoreClrHost) shows both Windows and Linux code paths.</span></span>

<span data-ttu-id="2576a-156">[UNIX CoreRun konak](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/unixcorerun) coreclrhost.h kullanarak barındırma daha karmaşık, gerçek bir örnek gösterir.</span><span class="sxs-lookup"><span data-stu-id="2576a-156">The [Unix CoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/unixcorerun) shows a more complex, real-world example of hosting using coreclrhost.h.</span></span>

### <a name="step-1---find-and-load-coreclr"></a><span data-ttu-id="2576a-157">Adım 1 - bulma ve yükleme CoreCLR</span><span class="sxs-lookup"><span data-stu-id="2576a-157">Step 1 - Find and load CoreCLR</span></span>

<span data-ttu-id="2576a-158">.NET Core çalışma zamanı API'leri bulunan *coreclr.dll* (Windows) şirket içinde *libcoreclr.so* (Linux) üzerinde veya *libcoreclr.dylib* (macos'ta).</span><span class="sxs-lookup"><span data-stu-id="2576a-158">The .NET Core runtime APIs are in *coreclr.dll* (on Windows), in *libcoreclr.so* (on Linux), or in *libcoreclr.dylib* (on macOS).</span></span> <span data-ttu-id="2576a-159">.NET Core barındırma ilk adımı, CoreCLR kitaplığını sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="2576a-159">The first step to hosting .NET Core is to load the CoreCLR library.</span></span> <span data-ttu-id="2576a-160">Bazı konakların farklı yollarını araştırma veya başkalarının belirli bir yolda (konak, örneğin yanındaki veya bir makine genelindeki konumdan) yükleyin bilmeleri sırada kitaplığı bulmak için giriş parametrelerini kullanın.</span><span class="sxs-lookup"><span data-stu-id="2576a-160">Some hosts probe different paths or use input parameters to find the library while others know to load it from a certain path (next to the host, for example, or from a machine-wide location).</span></span>

<span data-ttu-id="2576a-161">Bir kez bulundu, kitaplığı ile yüklenen `LoadLibraryEx` (Windows üzerinde) veya `dlopen` (üzerinde Linux/Mac).</span><span class="sxs-lookup"><span data-stu-id="2576a-161">Once found, the library is loaded with `LoadLibraryEx` (on Windows) or `dlopen` (on Linux/Mac).</span></span>

[!code-cpp[CoreClrHost#1](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#1)]

### <a name="step-2---get-net-core-hosting-functions"></a><span data-ttu-id="2576a-162">Adım 2 - Get .NET Core barındırma işlevleri</span><span class="sxs-lookup"><span data-stu-id="2576a-162">Step 2 - Get .NET Core hosting functions</span></span>

<span data-ttu-id="2576a-163">.NET Core barındırma için çeşitli önemli yöntemler yararlı CoreClrHost sahiptir:</span><span class="sxs-lookup"><span data-stu-id="2576a-163">CoreClrHost has several important methods useful for hosting .NET Core:</span></span>

* <span data-ttu-id="2576a-164">`coreclr_initialize`: .NET Core çalışma zamanı başlar ve varsayılan ayarlar (ve yalnızca) AppDomain.</span><span class="sxs-lookup"><span data-stu-id="2576a-164">`coreclr_initialize`: Starts the .NET Core runtime and sets up the default (and only) AppDomain.</span></span>
* <span data-ttu-id="2576a-165">`coreclr_execute_assembly`: Eğer yönetilmiş bir derlemeyi yürütür.</span><span class="sxs-lookup"><span data-stu-id="2576a-165">`coreclr_execute_assembly`: Executes a managed assembly.</span></span>
* <span data-ttu-id="2576a-166">`coreclr_create_delegate`: Bir işlev işaretçisi ile yönetilen bir yöntem oluşturur.</span><span class="sxs-lookup"><span data-stu-id="2576a-166">`coreclr_create_delegate`: Creates a function pointer to a managed method.</span></span>
* <span data-ttu-id="2576a-167">`coreclr_shutdown`: .NET Core çalışma zamanı kapatır.</span><span class="sxs-lookup"><span data-stu-id="2576a-167">`coreclr_shutdown`: Shuts down the .NET Core runtime.</span></span>
* <span data-ttu-id="2576a-168">`coreclr_shutdown_2`: Gibi `coreclr_shutdown`, ancak ayrıca yönetilen kodun çıkış kodu alır.</span><span class="sxs-lookup"><span data-stu-id="2576a-168">`coreclr_shutdown_2`: Like `coreclr_shutdown`, but also retrieves the managed code's exit code.</span></span>

<span data-ttu-id="2576a-169">CoreCLR kitaplığı yüklendikten sonra sonraki adıma kullanarak bu işlevlere yönelik başvurulara almaktır `GetProcAddress` (Windows üzerinde) veya `dlsym` (üzerinde Linux/Mac).</span><span class="sxs-lookup"><span data-stu-id="2576a-169">After loading the CoreCLR library, the next step is to get references to these functions using `GetProcAddress` (on Windows) or `dlsym` (on Linux/Mac).</span></span>

[!code-cpp[CoreClrHost#2](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#2)]

### <a name="step-3---prepare-runtime-properties"></a><span data-ttu-id="2576a-170">Adım 3 - çalışma zamanı özellikleri hazırlama</span><span class="sxs-lookup"><span data-stu-id="2576a-170">Step 3 - Prepare runtime properties</span></span>

<span data-ttu-id="2576a-171">Çalışma zamanı'nı başlatmadan önce bazı özellikler (bütünleştirilmiş kod yükleyicisini özellikle ilgili) davranışını belirtmek için hazırlamak üzere gereklidir.</span><span class="sxs-lookup"><span data-stu-id="2576a-171">Before starting the runtime, it is necessary to prepare some properties to specify behavior (especially concerning the assembly loader).</span></span>

<span data-ttu-id="2576a-172">Ortak özellikler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="2576a-172">Common properties include:</span></span>

* <span data-ttu-id="2576a-173">`TRUSTED_PLATFORM_ASSEMBLIES` Bu bir bütünleştirilmiş kodu yolları listesidir (Windows üzerinde ';' ile ayrılmış ve ':' Linux üzerinde), çalışma zamanı varsayılan olarak çözümleyebilmesi.</span><span class="sxs-lookup"><span data-stu-id="2576a-173">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Linux) which the runtime will be able to resolve by default.</span></span> <span data-ttu-id="2576a-174">Bazı ana bilgisayarlar, sabit kodlanmış bildirimlerinin derlemeleri yüklemek listesi vardır.</span><span class="sxs-lookup"><span data-stu-id="2576a-174">Some hosts have hard-coded manifests listing assemblies they can load.</span></span> <span data-ttu-id="2576a-175">Diğer tüm kitaplık belirli konumlara koyduğunuzdan (yanındaki *coreclr.dll*, örneğin) bu listede.</span><span class="sxs-lookup"><span data-stu-id="2576a-175">Others will put any library in certain locations (next to *coreclr.dll*, for example) on this list.</span></span>
* <span data-ttu-id="2576a-176">`APP_PATHS` Bu araştırma için bir derleme'da güvenilir platform derlemeleri (TPA) listesinde bulunamazsa yollarının bir listesidir.</span><span class="sxs-lookup"><span data-stu-id="2576a-176">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="2576a-177">Daha fazla denetim TPA listesini kullanarak derlemeleri üzerinde yüklü olan konak olduğundan, yüklemek ve bunları doğrudan belirterek listelemek için beklediği hangi derlemelerin belirlemek ana bilgisayarlar için en iyi yöntem var.</span><span class="sxs-lookup"><span data-stu-id="2576a-177">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="2576a-178">Ancak, çalışma zamanında yoklama gerekirse bu özellik bu senaryonun etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2576a-178">If probing at runtime is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="2576a-179">`APP_NI_PATHS` Bu liste, yerel görüntüler için araştırıldığı yolları olacak şekilde hazırlanmıştır dışında APP_PATHS için benzerdir.</span><span class="sxs-lookup"><span data-stu-id="2576a-179">`APP_NI_PATHS` This list is similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="2576a-180">`NATIVE_DLL_SEARCH_DIRECTORIES` Bu özellik, p/Invoke yerel kitaplıklar aranıyor çağrıldığı zaman yükleyici araştırma yolları bir listesidir.</span><span class="sxs-lookup"><span data-stu-id="2576a-180">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native libraries called via p/invoke.</span></span>
* <span data-ttu-id="2576a-181">`PLATFORM_RESOURCE_ROOTS` Bu liste, kaynak uydu derlemelerine (kültüre özgü alt dizinlerde) için araştırmaya yolları içerir.</span><span class="sxs-lookup"><span data-stu-id="2576a-181">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific sub-directories).</span></span>

<span data-ttu-id="2576a-182">Bu örnek konak TPA listenin geçerli dizindeki tüm kitaplıkları listeleyerek oluşturulur:</span><span class="sxs-lookup"><span data-stu-id="2576a-182">In this sample host, the TPA list is constructed by simply listing all libraries in the current directory:</span></span>

[!code-cpp[CoreClrHost#7](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#7)]

<span data-ttu-id="2576a-183">Örneği basit olduğundan, yalnızca gereken `TRUSTED_PLATFORM_ASSEMBLIES` özelliği:</span><span class="sxs-lookup"><span data-stu-id="2576a-183">Because the sample is simple, it only needs the `TRUSTED_PLATFORM_ASSEMBLIES` property:</span></span>

[!code-cpp[CoreClrHost#3](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#3)]

### <a name="step-4---start-the-runtime"></a><span data-ttu-id="2576a-184">4\. adım: çalışma zamanını başlatma</span><span class="sxs-lookup"><span data-stu-id="2576a-184">Step 4 - Start the runtime</span></span>

<span data-ttu-id="2576a-185">Mscoree.h aksine (aşağıda açıklanmıştır) barındırma API'si, CoreCLRHost.h API'leri çalışma zamanını başlatma ve tümü tek bir çağrı ile ' % s'varsayılan uygulama etki alanı oluşturun.</span><span class="sxs-lookup"><span data-stu-id="2576a-185">Unlike the mscoree.h hosting API (described below), CoreCLRHost.h APIs start the runtime and create the default AppDomain all with a single call.</span></span> <span data-ttu-id="2576a-186">`coreclr_initialize` İşlevini, daha önce açıklanan özellikler taban yolu ve adı alır ve döndürür, barındırmak için bir tanıtıcı geri `hostHandle` parametresi.</span><span class="sxs-lookup"><span data-stu-id="2576a-186">The `coreclr_initialize` function takes a base path, name, and the properties described earlier and returns back a handle to the host via the `hostHandle` parameter.</span></span>

[!code-cpp[CoreClrHost#4](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#4)]

### <a name="step-5---run-managed-code"></a><span data-ttu-id="2576a-187">5\. adım - yönetilen kodu çalıştırma!</span><span class="sxs-lookup"><span data-stu-id="2576a-187">Step 5 - Run managed code!</span></span>

<span data-ttu-id="2576a-188">Başlatıldı çalışma zamanı ile yönetilen kod ana bilgisayar çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2576a-188">With the runtime started, the host can call managed code.</span></span> <span data-ttu-id="2576a-189">Bu, birkaç farklı yöntemle içinde yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-189">This can be done in a couple of different ways.</span></span> <span data-ttu-id="2576a-190">Örnek kod, Bu öğretici kullanım bağlı `coreclr_create_delegate` statik bir yönetilen yöntemi temsilci oluşturmak için işlev.</span><span class="sxs-lookup"><span data-stu-id="2576a-190">The sample code linked to this tutorial uses the `coreclr_create_delegate` function to create a delegate to a static managed method.</span></span> <span data-ttu-id="2576a-191">Bu API alan [derleme adı](../../framework/app-domains/assembly-names.md), ad alanıyla nitelenen tür adı ve girdi ve yöntemini çağırmak için kullanılan bir temsilci döndürür yöntemi adı.</span><span class="sxs-lookup"><span data-stu-id="2576a-191">This API takes the [assembly name](../../framework/app-domains/assembly-names.md), namespace-qualified type name, and method name as inputs and returns a delegate that can be used to invoke the method.</span></span>

[!code-cpp[CoreClrHost#5](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#5)]

<span data-ttu-id="2576a-192">Bu örnekte, konak çağırabilirsiniz `managedDelegate` çalıştırılacak `ManagedWorker.DoWork` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="2576a-192">In this sample, the host can now call `managedDelegate` to run the `ManagedWorker.DoWork` method.</span></span>

<span data-ttu-id="2576a-193">Alternatif olarak, `coreclr_execute_assembly` işlevi, yönetilen bir yürütülebilir dosyayı başlatmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-193">Alternatively, the `coreclr_execute_assembly` function can be used to launch a managed executable.</span></span> <span data-ttu-id="2576a-194">Bu API, bir derleme yolu ve bağımsız değişken dizisi, giriş parametre olarak alır.</span><span class="sxs-lookup"><span data-stu-id="2576a-194">This API takes an assembly path and array of arguments as input parameters.</span></span> <span data-ttu-id="2576a-195">Bu yol, derleme yüklenir ve onun ana yöntemini çağırır.</span><span class="sxs-lookup"><span data-stu-id="2576a-195">It loads the assembly at that path and invokes its main method.</span></span>

```C++
int hr = executeAssembly(
        hostHandle,
        domainId,
        argumentCount,
        arguments,
        "HelloWorld.exe",
        (unsigned int*)&exitCode);
```

### <a name="step-6---shutdown-and-clean-up"></a><span data-ttu-id="2576a-196">Adım 6 - Kapat ve Temizle</span><span class="sxs-lookup"><span data-stu-id="2576a-196">Step 6 - Shutdown and clean up</span></span>

<span data-ttu-id="2576a-197">Ana çalışan yönetilen kod yapıldığında, son olarak, .NET Core çalışma zamanı ile kapatılmış `coreclr_shutdown` veya `coreclr_shutdown_2`.</span><span class="sxs-lookup"><span data-stu-id="2576a-197">Finally, when the host is done running managed code, the .NET Core runtime is shut down with `coreclr_shutdown` or `coreclr_shutdown_2`.</span></span>

[!code-cpp[CoreClrHost#6](~/samples/core/hosting/HostWithCoreClrHost/src/SampleHost.cpp#6)]

<span data-ttu-id="2576a-198">CoreCLR, yeniden başlatma veya kaldırılmasını desteklemez.</span><span class="sxs-lookup"><span data-stu-id="2576a-198">CoreCLR does not support reinitialization or unloading.</span></span> <span data-ttu-id="2576a-199">Çağırmayın `coreclr_initialize` yeniden veya CoreCLR kitaplığı kaldırma.</span><span class="sxs-lookup"><span data-stu-id="2576a-199">Do not call `coreclr_initialize` again or unload the CoreCLR library.</span></span>

## <a name="create-a-host-using-mscoreeh"></a><span data-ttu-id="2576a-200">Mscoree.h kullanarak bir konağı oluşturma</span><span class="sxs-lookup"><span data-stu-id="2576a-200">Create a host using Mscoree.h</span></span>

<span data-ttu-id="2576a-201">Daha önce belirtildiği gibi CoreClrHost.h artık .NET Core çalışma zamanı barındırma için tercih edilen yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="2576a-201">As mentioned previously, CoreClrHost.h is now the preferred method of hosting the .NET Core runtime.</span></span> <span data-ttu-id="2576a-202">`ICLRRuntimeHost4` Arabirimi hala kullanılabilir, ancak CoreClrHost.h arabirimleri yeterli değilse (standart başlangıç bayrakları gibi gerekli olup olmadığını veya varsayılan etki alanına bir AppDomainManager gerekiyorsa).</span><span class="sxs-lookup"><span data-stu-id="2576a-202">The `ICLRRuntimeHost4` interface can still be used, though, if the CoreClrHost.h interfaces aren't sufficient (if non-standard startup flags are needed, for example, or if an AppDomainManager is needed on the default domain).</span></span> <span data-ttu-id="2576a-203">Bu yönergeler mscoree.h kullanarak .NET Core barındırma aracılığıyla size yol gösterir.</span><span class="sxs-lookup"><span data-stu-id="2576a-203">These instructions will guide you through hosting .NET Core using mscoree.h.</span></span>

<span data-ttu-id="2576a-204">[CoreRun konak](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun) mscoree.h kullanarak barındırma daha karmaşık, gerçek bir örnek gösterir.</span><span class="sxs-lookup"><span data-stu-id="2576a-204">The [CoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun) shows a more complex, real-world example of hosting using mscoree.h.</span></span>

### <a name="a-note-about-mscoreeh"></a><span data-ttu-id="2576a-205">Mscoree.h hakkında bir Not</span><span class="sxs-lookup"><span data-stu-id="2576a-205">A note about mscoree.h</span></span>
<span data-ttu-id="2576a-206">`ICLRRuntimeHost4` .NET Core barındırma arabiriminin tanımlanmış [MSCOREE. IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL).</span><span class="sxs-lookup"><span data-stu-id="2576a-206">The `ICLRRuntimeHost4` .NET Core hosting interface is defined in [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL).</span></span> <span data-ttu-id="2576a-207">Bir üst bilgi sürümü ana başvuruda bulunmanız gerekir, bu dosyanın (mscoree.h) MIDL üretilen olduğunda [.NET Core çalışma zamanı](https://github.com/dotnet/coreclr/) oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="2576a-207">A header version of this file (mscoree.h), which your host will need to reference, is produced via MIDL when the [.NET Core runtime](https://github.com/dotnet/coreclr/) is built.</span></span> <span data-ttu-id="2576a-208">.NET Core çalışma zamanı oluşturmak istemiyorsanız mscoree.h olarak da kullanılabilir bir [önceden derlenmiş üst bilgi](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) dotnet/coreclr deposunda.</span><span class="sxs-lookup"><span data-stu-id="2576a-208">If you do not want to build the .NET Core runtime, mscoree.h is also available as a [pre-built header](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) in the dotnet/coreclr repository.</span></span> <span data-ttu-id="2576a-209">[.NET Core çalışma zamanı oluşturma hakkında yönergeler](https://github.com/dotnet/coreclr#building-the-repository) kendi GitHub deposunda bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-209">[Instructions on building the .NET Core runtime](https://github.com/dotnet/coreclr#building-the-repository) can be found in its GitHub repository.</span></span>

### <a name="step-1---identify-the-managed-entry-point"></a><span data-ttu-id="2576a-210">1\. adım - yönetilen giriş noktasını tanımlayın</span><span class="sxs-lookup"><span data-stu-id="2576a-210">Step 1 - Identify the managed entry point</span></span>
<span data-ttu-id="2576a-211">Gerekli üst bilgileri başvuran sonra ([mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) ve örneğin, stdıo.h), bir .NET Core konak gerçekleştirmelisiniz gereken ilk unsur biridir, kullanacağınız yönetilen giriş noktasını bulun.</span><span class="sxs-lookup"><span data-stu-id="2576a-211">After referencing necessary headers ([mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) and stdio.h, for example), one of the first things a .NET Core host must do is locate the managed entry point it will be using.</span></span> <span data-ttu-id="2576a-212">Bizim örnek konak bu yalnızca ilk komut satırı bağımsız değişkeni bizim konağa yönetilen ikili bir yolu olarak yararlanarak gerçekleştirilir, `main` yöntemi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="2576a-212">In our sample host, this is done by just taking the first command line argument to our host as the path to a managed binary whose `main` method will be executed.</span></span>

[!code-cpp[NetCoreHost#1](~/samples/core/hosting/HostWithMscoree/host.cpp#1)]

### <a name="step-2---find-and-load-coreclr"></a><span data-ttu-id="2576a-213">Adım 2 - bulma ve yükleme CoreCLR</span><span class="sxs-lookup"><span data-stu-id="2576a-213">Step 2 - Find and load CoreCLR</span></span>
<span data-ttu-id="2576a-214">.NET Core çalışma zamanı API'leri bulunan *CoreCLR.dll* (Windows üzerinde).</span><span class="sxs-lookup"><span data-stu-id="2576a-214">The .NET Core runtime APIs are in *CoreCLR.dll* (on Windows).</span></span> <span data-ttu-id="2576a-215">Barındırma arabirimimizi almak için (`ICLRRuntimeHost4`), bulmak ve yüklemek için gerekli olan *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="2576a-215">To get our hosting interface (`ICLRRuntimeHost4`), it's necessary to find and load *CoreCLR.dll*.</span></span> <span data-ttu-id="2576a-216">Nasıl bulur bir kural tanımlamak için ana kadar olan *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="2576a-216">It is up to the host to define a convention for how it will locate *CoreCLR.dll*.</span></span> <span data-ttu-id="2576a-217">Bazı konakların dosyanın iyi bilinen bir makineye konumda mevcut olmasını beklediğiniz (gibi *%programfiles%\dotnet\shared\Microsoft.NETCore.App\2.1.6*).</span><span class="sxs-lookup"><span data-stu-id="2576a-217">Some hosts expect the file to be present in a well-known machine-wide location (such as *%programfiles%\dotnet\shared\Microsoft.NETCore.App\2.1.6*).</span></span> <span data-ttu-id="2576a-218">Başkalarının beklediğiniz *CoreCLR.dll* ya da yanında bir konumdan kendisini veya barındırılması için uygulama yüklenmeyecek.</span><span class="sxs-lookup"><span data-stu-id="2576a-218">Others expect that *CoreCLR.dll* will be loaded from a location next to either the host itself or the app to be hosted.</span></span> <span data-ttu-id="2576a-219">Yine de diğer kitaplığı bulmak için bir ortam değişkeni başvurun.</span><span class="sxs-lookup"><span data-stu-id="2576a-219">Still others might consult an environment variable to find the library.</span></span>

<span data-ttu-id="2576a-220">Linux veya Mac üzerinde temel çalışma zamanı kitaplığı olan *libcoreclr.so* veya *libcoreclr.dylib*sırasıyla.</span><span class="sxs-lookup"><span data-stu-id="2576a-220">On Linux or Mac, the core runtime library is *libcoreclr.so* or *libcoreclr.dylib*, respectively.</span></span>

<span data-ttu-id="2576a-221">Bizim örnek konak için bazı ortak konumları araştırmaları *CoreCLR.dll*.</span><span class="sxs-lookup"><span data-stu-id="2576a-221">Our sample host probes a few common locations for *CoreCLR.dll*.</span></span> <span data-ttu-id="2576a-222">Bir kez bulundu, onu aracılığıyla yüklenmesi gereken `LoadLibrary` (veya `dlopen` Linux/Mac üzerinde).</span><span class="sxs-lookup"><span data-stu-id="2576a-222">Once found, it must be loaded via `LoadLibrary` (or `dlopen` on Linux/Mac).</span></span>

[!code-cpp[NetCoreHost#2](~/samples/core/hosting/HostWithMscoree/host.cpp#2)]

### <a name="step-3---get-an-iclrruntimehost4-instance"></a><span data-ttu-id="2576a-223">3\. adım: ICLRRuntimeHost4 örneğini alma</span><span class="sxs-lookup"><span data-stu-id="2576a-223">Step 3 - Get an ICLRRuntimeHost4 Instance</span></span>
<span data-ttu-id="2576a-224">`ICLRRuntimeHost4` Arabirimi barındırma alınır çağırarak `GetProcAddress` (veya `dlsym` Linux/Mac üzerinde) üzerinde `GetCLRRuntimeHost`ve ardından bu işlev çağırma.</span><span class="sxs-lookup"><span data-stu-id="2576a-224">The `ICLRRuntimeHost4` hosting interface is retrieved by calling `GetProcAddress` (or `dlsym` on Linux/Mac) on `GetCLRRuntimeHost`, and then invoking that function.</span></span>

[!code-cpp[NetCoreHost#3](~/samples/core/hosting/HostWithMscoree/host.cpp#3)]

### <a name="step-4---set-startup-flags-and-start-the-runtime"></a><span data-ttu-id="2576a-225">4\. adım - başlangıç bayraklarını ayarlayın ve çalışma zamanını başlatma</span><span class="sxs-lookup"><span data-stu-id="2576a-225">Step 4 - Set startup flags and start the runtime</span></span>
<span data-ttu-id="2576a-226">İle bir `ICLRRuntimeHost4` yakından, biz artık çalışma zamanı genelinde başlangıç bayrakları belirtin ve çalışma zamanı'nı başlatın.</span><span class="sxs-lookup"><span data-stu-id="2576a-226">With an `ICLRRuntimeHost4` in-hand, we can now specify runtime-wide startup flags and start the runtime.</span></span> <span data-ttu-id="2576a-227">Başlangıç bayrakları, hangi atık tek bir AppDomain veya birden çok AppDomains kullanacağız olup olmadığını (eşzamanlı veya sunucu) kullanmak için toplayıcı (GC) ve (etki alanından bağımsız derlemeler için yüklenmesini) kullanmak için hangi yükleyici iyileştirme ilkesini belirler.</span><span class="sxs-lookup"><span data-stu-id="2576a-227">Startup flags determine which garbage collector (GC) to use (concurrent or server), whether we will use a single AppDomain or multiple AppDomains, and what loader optimization policy to use (for domain-neutral loading of assemblies).</span></span>

[!code-cpp[NetCoreHost#4](~/samples/core/hosting/HostWithMscoree/host.cpp#4)]

<span data-ttu-id="2576a-228">Çalışma zamanı, çağrı kullanmaya `Start` işlevi.</span><span class="sxs-lookup"><span data-stu-id="2576a-228">The runtime is started with a call to the `Start` function.</span></span>

```C++
hr = runtimeHost->Start();
```

### <a name="step-5---preparing-appdomain-settings"></a><span data-ttu-id="2576a-229">Adım 5 - AppDomain hazırlama ayarları</span><span class="sxs-lookup"><span data-stu-id="2576a-229">Step 5 - Preparing AppDomain settings</span></span>
<span data-ttu-id="2576a-230">Çalışma zamanı başlatıldıktan sonra biz AppDomain ayarlamak istersiniz.</span><span class="sxs-lookup"><span data-stu-id="2576a-230">Once the runtime is started, we will want to set up an AppDomain.</span></span> <span data-ttu-id="2576a-231">Bu ilk hazırlamak gereklidir, ancak bir .NET AppDomain oluştururken belirtilmelidir birkaç seçenek vardır.</span><span class="sxs-lookup"><span data-stu-id="2576a-231">There are a number of options that must be specified when creating a .NET AppDomain, however, so it's necessary to prepare those first.</span></span>

<span data-ttu-id="2576a-232">AppDomain bayrakları, güvenlik ve birlikte çalışabilirlik ile ilgili AppDomain davranışları belirtin.</span><span class="sxs-lookup"><span data-stu-id="2576a-232">AppDomain flags specify AppDomain behaviors related to security and interop.</span></span> <span data-ttu-id="2576a-233">Bu ayarlar için korumalı alan kullanıcı kodu eski Silverlight ana kullanılan, ancak çoğu modern .NET Core konakları kullanıcı kod tam güven çalıştırın ve birlikte çalışabilirliği etkinleştirmek.</span><span class="sxs-lookup"><span data-stu-id="2576a-233">Older Silverlight hosts used these settings to sandbox user code, but most modern .NET Core hosts run user code as full trust and enable interop.</span></span>

[!code-cpp[NetCoreHost#5](~/samples/core/hosting/HostWithMscoree/host.cpp#5)]

<span data-ttu-id="2576a-234">Hangi kullanılacak AppDomain bayrakları karar verdikten sonra AppDomain özellikleri tanımlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="2576a-234">After deciding which AppDomain flags to use, AppDomain properties must be defined.</span></span> <span data-ttu-id="2576a-235">Anahtar/değer çiftlerinin dize özelliklerdir.</span><span class="sxs-lookup"><span data-stu-id="2576a-235">The properties are key/value pairs of strings.</span></span> <span data-ttu-id="2576a-236">Özelliklerin birçoğu, AppDomain derlemeleri nasıl yükleneceğini için ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="2576a-236">Many of the properties relate to how the AppDomain will load assemblies.</span></span>

<span data-ttu-id="2576a-237">Ortak AppDomain özellikler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="2576a-237">Common AppDomain properties include:</span></span>

* <span data-ttu-id="2576a-238">`TRUSTED_PLATFORM_ASSEMBLIES` Bu bir bütünleştirilmiş kodu yolları listesidir (tarafından ayrılmış `;` Windows üzerinde ve `:` Linux/Mac üzerinde), AppDomain (kısmen güvenilen etki alanlarında çift için), yükleme ve verin tam güven öncelik vermelisiniz.</span><span class="sxs-lookup"><span data-stu-id="2576a-238">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by `;` on Windows and `:` on Linux/Mac) which the AppDomain should prioritize loading and give full trust to (even in partially-trusted domains).</span></span> <span data-ttu-id="2576a-239">Bu liste 'Framework' derlemeleri ve diğer güvenilen modüller, .NET Framework senaryoları GAC'de benzer içerecek şekilde tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="2576a-239">This list is meant to contain 'Framework' assemblies and other trusted modules, similar to the GAC in .NET Framework scenarios.</span></span> <span data-ttu-id="2576a-240">Bazı konakların kitaplık yanındaki sokar *coreclr.dll* bu listede, diğer sabit kodlanmış bildirimleri kendi amaçları için güvenilir bütünleştirilmiş kodların listesi vardır.</span><span class="sxs-lookup"><span data-stu-id="2576a-240">Some hosts will put any library next to *coreclr.dll* on this list, others have hard-coded manifests listing trusted assemblies for their purposes.</span></span>
* <span data-ttu-id="2576a-241">`APP_PATHS` Bu araştırma için bir derleme'da güvenilir platform derlemeleri (TPA) listesinde bulunamazsa yollarının bir listesidir.</span><span class="sxs-lookup"><span data-stu-id="2576a-241">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="2576a-242">Daha fazla denetim TPA listesini kullanarak derlemeleri üzerinde yüklü olan konak olduğundan, yüklemek ve bunları doğrudan belirterek listelemek için beklediği hangi derlemelerin belirlemek ana bilgisayarlar için en iyi yöntem var.</span><span class="sxs-lookup"><span data-stu-id="2576a-242">Because the host has more control over which assemblies are loaded using the TPA list, it is a best practice for hosts to determine which assemblies they expect to load and list them explicitly.</span></span> <span data-ttu-id="2576a-243">Ancak, çalışma zamanında yoklama gerekirse bu özellik bu senaryonun etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2576a-243">If probing at runtime is needed, however, this property can enable that scenario.</span></span>
* <span data-ttu-id="2576a-244">`APP_NI_PATHS` Yerel görüntüler için araştırıldığı yolları olacak şekilde hazırlanmıştır dışında bu liste için APP_PATHS çok benzer.</span><span class="sxs-lookup"><span data-stu-id="2576a-244">`APP_NI_PATHS` This list is very similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
* <span data-ttu-id="2576a-245">`NATIVE_DLL_SEARCH_DIRECTORIES` Bu özellik, p/Invoke Yerel DLL'leri çağrıldığı zaman yükleyici araştırma yolları bir listesidir.</span><span class="sxs-lookup"><span data-stu-id="2576a-245">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native DLLs called via p/invoke.</span></span>
* <span data-ttu-id="2576a-246">`PLATFORM_RESOURCE_ROOTS` Bu liste, kaynak uydu derlemelerine (kültüre özgü alt dizinlerde) için araştırmaya yolları içerir.</span><span class="sxs-lookup"><span data-stu-id="2576a-246">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific sub-directories).</span></span>

<span data-ttu-id="2576a-247">İçinde bizim [basit örnek konak](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithMscoree), bu özellikler aşağıdaki ayarlamaları yapın:</span><span class="sxs-lookup"><span data-stu-id="2576a-247">In our [simple sample host](https://github.com/dotnet/samples/tree/master/core/hosting/HostWithMscoree), these properties are set up as follows:</span></span>

[!code-cpp[NetCoreHost#6](~/samples/core/hosting/HostWithMscoree/host.cpp#6)]

### <a name="step-6---create-the-appdomain"></a><span data-ttu-id="2576a-248">6\. adım: uygulama etki alanı oluşturma</span><span class="sxs-lookup"><span data-stu-id="2576a-248">Step 6 - Create the AppDomain</span></span>
<span data-ttu-id="2576a-249">Tüm AppDomain bayraklar ve Özellikler hazır sonra `ICLRRuntimeHost4::CreateAppDomainWithManager` AppDomain ayarlamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-249">Once all AppDomain flags and properties are prepared, `ICLRRuntimeHost4::CreateAppDomainWithManager` can be used to set up the AppDomain.</span></span> <span data-ttu-id="2576a-250">Bu işlev, isteğe bağlı olarak bir tam derleme adını ve etki alanının AppDomain Yöneticisi kullanmak üzere tür adı alır.</span><span class="sxs-lookup"><span data-stu-id="2576a-250">This function optionally takes a fully qualified assembly name and type name to use as the domain's AppDomain manager.</span></span> <span data-ttu-id="2576a-251">AppDomain Yöneticisi bazı yönlerini AppDomain davranışını denetlemek bir konak izin verebilir ve giriş noktaları, konak kullanıcı kodu doğrudan çağırmak istiyorsanız değil, yönetilen kod başlatmak için sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-251">An AppDomain manager can allow a host to control some aspects of AppDomain behavior and may provide entry points for launching managed code if the host doesn't intend to invoke user code directly.</span></span>

[!code-cpp[NetCoreHost#7](~/samples/core/hosting/HostWithMscoree/host.cpp#7)]

### <a name="step-7---run-managed-code"></a><span data-ttu-id="2576a-252">7\. adım - yönetilen kodu çalıştırma!</span><span class="sxs-lookup"><span data-stu-id="2576a-252">Step 7 - Run managed code!</span></span>
<span data-ttu-id="2576a-253">AppDomain ile çalışmaya, ana bilgisayar artık yönetilen kod başlatabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2576a-253">With an AppDomain up and running, the host can now start executing managed code.</span></span> <span data-ttu-id="2576a-254">Bunu yapmanın en kolay yolu kullanmaktır `ICLRRuntimeHost4::ExecuteAssembly` yönetilen derlemenin giriş noktası yöntemini çağırmak için.</span><span class="sxs-lookup"><span data-stu-id="2576a-254">The easiest way to do this is to use `ICLRRuntimeHost4::ExecuteAssembly` to invoke a managed assembly's entry point method.</span></span> <span data-ttu-id="2576a-255">Bu işlev yalnızca tek etki alanlı senaryolarda çalıştığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="2576a-255">Note that this function only works in single-domain scenarios.</span></span>

[!code-cpp[NetCoreHost#8](~/samples/core/hosting/HostWithMscoree/host.cpp#8)]

<span data-ttu-id="2576a-256">Başka bir seçenek, varsa `ExecuteAssembly` ana bilgisayarınızın gereksinimlerini karşılamıyor, kullanmaktır `CreateDelegate` Yönetilen yöntemi statik bir işlev işaretçisine oluşturmak için.</span><span class="sxs-lookup"><span data-stu-id="2576a-256">Another option, if `ExecuteAssembly` doesn't meet your host's needs, is to use `CreateDelegate` to create a function pointer to a static managed method.</span></span> <span data-ttu-id="2576a-257">Bu konak noktası (işlev işaretçisi türü oluşturmak için) çağırma olan ancak ana bilgisayar bütünleştirilmiş kodun giriş dışındaki kod çağırmak esneklik sağlar metodun imzası bilmek gerektirir.</span><span class="sxs-lookup"><span data-stu-id="2576a-257">This requires the host to know the signature of the method it is calling into (in order to create the function pointer type) but allows hosts the flexibility to invoke code other than an assembly's entry point.</span></span> <span data-ttu-id="2576a-258">İkinci parametre sağlanan derleme adı [tam yönetilen bütünleştirilmiş kod adı](../../framework/app-domains/assembly-names.md) kitaplığı yüklenemedi.</span><span class="sxs-lookup"><span data-stu-id="2576a-258">The assembly name provided in the second parameter is the [full managed assembly name](../../framework/app-domains/assembly-names.md) of the library to load.</span></span>

```C++
void *pfnDelegate = NULL;
hr = runtimeHost->CreateDelegate(
    domainId,
    L"HW, Version=1.0.0.0, Culture=neutral", // Target managed assembly
    L"ConsoleApplication.Program",           // Target managed type
    L"Main",                                 // Target entry point (static method)
    (INT_PTR*)&pfnDelegate);

((MainMethodFp*)pfnDelegate)(NULL);
```

### <a name="step-8---clean-up"></a><span data-ttu-id="2576a-259">8 - temizleme adım</span><span class="sxs-lookup"><span data-stu-id="2576a-259">Step 8 - Clean up</span></span>
<span data-ttu-id="2576a-260">Son olarak, ana bilgisayar kendisini sonra uygulama etki alanları kaldırma, çalışma zamanı durdurma ve serbest bırakma temizlemek `ICLRRuntimeHost4` başvuru.</span><span class="sxs-lookup"><span data-stu-id="2576a-260">Finally, the host should clean up after itself by unloading AppDomains, stopping the runtime, and releasing the `ICLRRuntimeHost4` reference.</span></span>

[!code-cpp[NetCoreHost#9](~/samples/core/hosting/HostWithMscoree/host.cpp#9)]

<span data-ttu-id="2576a-261">CoreCLR kaldırılmasını desteklemez.</span><span class="sxs-lookup"><span data-stu-id="2576a-261">CoreCLR does not support unloading.</span></span> <span data-ttu-id="2576a-262">CoreCLR kitaplığı bellekten değil.</span><span class="sxs-lookup"><span data-stu-id="2576a-262">Do not unload the CoreCLR library.</span></span>

## <a name="conclusion"></a><span data-ttu-id="2576a-263">Sonuç</span><span class="sxs-lookup"><span data-stu-id="2576a-263">Conclusion</span></span>
<span data-ttu-id="2576a-264">Konağınız oluşturulduktan sonra komut satırından çalıştırarak test edilebilir ve konak herhangi bir bağımsız değişken geçirme (gibi mscoree örnek ana bilgisayar için çalıştırmak istediğiniz yönetilen uygulamayı) bekliyor.</span><span class="sxs-lookup"><span data-stu-id="2576a-264">Once your host is built, it can be tested by running it from the command line and passing any arguments the host expects (like the managed app to run for the mscoree example host).</span></span> <span data-ttu-id="2576a-265">.NET Core uygulaması çalıştırmak ana bilgisayar için belirtirken tarafından üretilen .dll dosyasını kullanmaya dikkat edin `dotnet build`.</span><span class="sxs-lookup"><span data-stu-id="2576a-265">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="2576a-266">Yürütülebilir dosyalar (.exe dosyaları) tarafından üretilen `dotnet publish` gerçekten varsayılan kendi içindeki uygulamaları için .NET Core barındıran (uygulamayı doğrudan ana hat senaryolarda komut satırından başlatılabilir böylece); kullanıcı kodu aynı ada sahip bir dll içine derlenmiş.</span><span class="sxs-lookup"><span data-stu-id="2576a-266">Executables (.exe files) produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span>

<span data-ttu-id="2576a-267">Şeyler başlangıçta işe yaramazsa, sağlayamazsanız *coreclr.dll* TPA listesinde gerekli tüm Framework kitaplıkları ve o CoreCLR'ın bit genişliği (32 veya 64-bit) ile eşleşen konak tarafından beklenen konumda kullanılabilir nasıl konak oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="2576a-267">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32- or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="2576a-268">.NET Core çalışma zamanı barındırma birçok geliştiricinin yapılması gerekmez, ancak bunlar için yönetilen koddan yerel işlem veya .NET Core çalışma zamanı davranışı hakkında daha fazla denetime gereksinim duyan başlatmak gereksinim duyan İleri düzey bir senaryodur, çok kullanışlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="2576a-268">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span>

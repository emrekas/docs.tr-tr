---
ms.openlocfilehash: b0e6d6f228647148083d3df64e65f817dc3455d5
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/22/2019
ms.locfileid: "59981693"
---
### <a name="exceptions-during-unobserved-processing-in-systemthreadingtaskstask-no-longer-propagate-on-finalizer-thread"></a><span data-ttu-id="686a7-101">Artık System.Threading.Tasks.Task içinde gözetimsiz işleme sırasında özel durumları Sonlandırıcı iş parçacığında yayılmaz</span><span class="sxs-lookup"><span data-stu-id="686a7-101">Exceptions during unobserved processing in System.Threading.Tasks.Task no longer propagate on finalizer thread</span></span>

|   |   |
|---|---|
|<span data-ttu-id="686a7-102">Ayrıntılar</span><span class="sxs-lookup"><span data-stu-id="686a7-102">Details</span></span>|<span data-ttu-id="686a7-103">Çünkü <xref:System.Threading.Tasks.Task?displayProperty=name> sınıfı zaman uyumsuz bir işlem sunduğundan, zaman uyumsuz işleme süresince ortaya çıkan tüm önemli olmayan özel durumları yakalar.</span><span class="sxs-lookup"><span data-stu-id="686a7-103">Because the <xref:System.Threading.Tasks.Task?displayProperty=name> class represents an asynchronous operation, it catches all non-severe exceptions that occur during asynchronous processing.</span></span> <span data-ttu-id="686a7-104">.NET Framework 4.5, bir durum gözlenmezse ve kodunuz görevde beklemezse, özel durum artık Sonlandırıcı iş parçacığında yayılmaz ve çöp toplama sırasında işlemi kilitlenme.</span><span class="sxs-lookup"><span data-stu-id="686a7-104">In the .NET Framework 4.5, if an exception is not observed and your code never waits on the task, the exception will no longer propagate on the finalizer thread and crash the process during garbage collection.</span></span> <span data-ttu-id="686a7-105">Bu değişiklik, gözetimsiz zaman uyumsuz işleme gerçekleştirmek için görev sınıfını kullanan uygulamaların güvenilirliğini arttırır.</span><span class="sxs-lookup"><span data-stu-id="686a7-105">This change enhances the reliability of applications that use the Task class to perform unobserved asynchronous processing.</span></span>|
|<span data-ttu-id="686a7-106">Öneri</span><span class="sxs-lookup"><span data-stu-id="686a7-106">Suggestion</span></span>|<span data-ttu-id="686a7-107">Gözetimsiz zaman uyumsuz özel durumları Sonlandırıcı iş parçacığı için yayma uygulama bağlıdır, önceki davranışı için uygun tanıtıcının sağlanmasıyla geri alınabilir <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> olay veya ayarlayarak bir [çalışma zamanı yapılandırma öğesi ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md).</span><span class="sxs-lookup"><span data-stu-id="686a7-107">If an app depends on unobserved asynchronous exceptions propagating to the finalizer thread, the previous behavior can be restored by providing an appropriate handler for the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> event, or by setting a [runtime configuration element](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md).</span></span>|
|<span data-ttu-id="686a7-108">Kapsam</span><span class="sxs-lookup"><span data-stu-id="686a7-108">Scope</span></span>|<span data-ttu-id="686a7-109">Kenar</span><span class="sxs-lookup"><span data-stu-id="686a7-109">Edge</span></span>|
|<span data-ttu-id="686a7-110">Sürüm</span><span class="sxs-lookup"><span data-stu-id="686a7-110">Version</span></span>|<span data-ttu-id="686a7-111">4,5</span><span class="sxs-lookup"><span data-stu-id="686a7-111">4.5</span></span>|
|<span data-ttu-id="686a7-112">Tür</span><span class="sxs-lookup"><span data-stu-id="686a7-112">Type</span></span>|<span data-ttu-id="686a7-113">Çalışma zamanı</span><span class="sxs-lookup"><span data-stu-id="686a7-113">Runtime</span></span>|
|<span data-ttu-id="686a7-114">Etkilenen API’ler</span><span class="sxs-lookup"><span data-stu-id="686a7-114">Affected APIs</span></span>|<ul><li><xref:System.Threading.Tasks.Task.Run(System.Action)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run%60%601(System.Func{%60%600})?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run%60%601(System.Func{%60%600},System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run%60%601(System.Func{System.Threading.Tasks.Task{%60%600}})?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Run%60%601(System.Func{System.Threading.Tasks.Task{%60%600}},System.Threading.CancellationToken)?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Start?displayProperty=nameWithType></li><li><xref:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)?displayProperty=nameWithType></li></ul>|
